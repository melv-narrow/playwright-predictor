{
  "language": "javascript",
  "code": "import { test as baseTest, request } from '@playwright/test';  \nimport fs from 'fs';  \nimport path from 'path';  \n  \nexport * from '@playwright/test';  \nexport const test = baseTest.extend<{}, { workerStorageState: string }>({  \n  // Use the same storage state for all tests in this worker.  \n  storageState: ({ workerStorageState }, use) => use(workerStorageState),  \n  \n  // Authenticate once per worker with a worker-scoped fixture.  \n  workerStorageState: [async ({}, use) => {  \n    // Use parallelIndex as a unique identifier for each worker.  \n    const id = test.info().parallelIndex;  \n    const fileName = path.resolve(test.info().project.outputDir, `.auth/${id}.json`);  \n  \n    if (fs.existsSync(fileName)) {  \n      // Reuse existing authentication state if any.  \n      await use(fileName);  \n      return;  \n    }  \n  \n    // Important: make sure we authenticate in a clean environment by unsetting storage state.  \n    const context = await request.newContext({ storageState: undefined });  \n  \n    // Acquire a unique account, for example create a new one.  \n    // Alternatively, you can have a list of precreated accounts for testing.  \n    // Make sure that accounts are unique, so that multiple team members  \n    // can run tests at the same time without interference.  \n    const account = await acquireAccount(id);  \n  \n    // Send authentication request. Replace with your own.  \n    await context.post('https://github.com/login', {  \n      form: {  \n        'user': 'user',  \n        'password': 'password'  \n      }  \n    });  \n  \n    await context.storageState({ path: fileName });  \n    await context.dispose();  \n    await use(fileName);  \n  }, { scope: 'worker' }],  \n});",
  "context": "Alternatively, in a worker fixture: | playwright/fixtures.ts",
  "source_url": "https://playwright.dev/docs/auth",
  "pattern": "fixture"
}