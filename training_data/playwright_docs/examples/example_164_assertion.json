{
  "language": "javascript",
  "code": "test('gets the json from api and adds a new fruit', async ({ page }) => {  \n  // Get the response and add to it  \n  await page.route('*/**/api/v1/fruits', async route => {  \n    const response = await route.fetch();  \n    const json = await response.json();  \n    json.push({ name: 'Loquat', id: 100 });  \n    // Fulfill using the original response, while patching the response body  \n    // with the given JSON object.  \n    await route.fulfill({ response, json });  \n  });  \n  \n  // Go to the page  \n  await page.goto('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the new fruit is visible  \n  await expect(page.getByText('Loquat', { exact: true })).toBeVisible();  \n});",
  "context": "Sometimes, it is essential to make an API request, but the response needs to be patched to allow for reproducible testing. In that case, instead of mocking the request, one can perform the request and fulfill it with the modified response. | In the example below we intercept the call to the fruit API and add a new fruit called 'Loquat', to the data. We then go to the url and assert that this data is there:",
  "source_url": "https://playwright.dev/docs/mock",
  "pattern": "assertion"
}