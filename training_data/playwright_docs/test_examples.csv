language,code,context,source_url,pattern
javascript,"import { test, expect } from '@playwright/test';  
import AxeBuilder from '@axe-core/playwright'; // 1  
  
test.describe('homepage', () => { // 2  
  test('should not have any automatically detectable accessibility issues', async ({ page }) => {  
    await page.goto('https://your-site.com/'); // 3  
  
    const accessibilityScanResults = await new AxeBuilder({ page }).analyze(); // 4  
  
    expect(accessibilityScanResults.violations).toEqual([]); // 5  
  });  
});  



const { test, expect } = require('@playwright/test');  
const AxeBuilder = require('@axe-core/playwright').default; // 1  
  
test.describe('homepage', () => { // 2  
  test('should not have any automatically detectable accessibility issues', async ({ page }) => {  
    await page.goto('https://your-site.com/'); // 3  
  
    const accessibilityScanResults = await new AxeBuilder({ page }).analyze(); // 4  
  
    expect(accessibilityScanResults.violations).toEqual([]); // 5  
  });  
});",JavaScript,https://playwright.dev/docs/accessibility-testing,assertion
javascript,"test('navigation menu should not have automatically detectable accessibility violations', async ({  
  page,  
}) => {  
  await page.goto('https://your-site.com/');  
  
  await page.getByRole('button', { name: 'Navigation Menu' }).click();  
  
  // It is important to waitFor() the page to be in the desired  
  // state *before* running analyze(). Otherwise, axe might not  
  // find all the elements your test expects it to scan.  
  await page.locator('#navigation-menu-flyout').waitFor();  
  
  const accessibilityScanResults = await new AxeBuilder({ page })  
      .include('#navigation-menu-flyout')  
      .analyze();  
  
  expect(accessibilityScanResults.violations).toEqual([]);  
});","For example, you can use [`AxeBuilder.include()`](https://github.com/dequelabs/axe-core-npm/blob/develop/packages/playwright/README.md#axebuilderincludeselector-string--string) to constrain an accessibility scan to only run against one specific part of a page. | `AxeBuilder.analyze()` will scan the page _in its current state_ when you call it. To scan parts of a page that are revealed based on UI interactions, use [Locators](/docs/locators) to interact with the page before invoking `analyze()`:",https://playwright.dev/docs/accessibility-testing,assertion
javascript,"test('should not have any automatically detectable WCAG A or AA violations', async ({ page }) => {  
  await page.goto('https://your-site.com/');  
  
  const accessibilityScanResults = await new AxeBuilder({ page })  
      .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])  
      .analyze();  
  
  expect(accessibilityScanResults.violations).toEqual([]);  
});","You can constrain an accessibility scan to only run those rules which are ""tagged"" as corresponding to specific WCAG success criteria by using [`AxeBuilder.withTags()`](https://github.com/dequelabs/axe-core-npm/blob/develop/packages/playwright/README.md#axebuilderwithtagstags-stringarray). For example, [Accessibility Insights for Web's Automated Checks](https://accessibilityinsights.io/docs/web/getstarted/fastpass/?referrer=playwright-accessibility-testing-js) only include axe rules that test for violations of WCAG A and AA success criteria; to match that behavior, you would use the tags `wcag2a`, `wcag2aa`, `wcag21a`, and `wcag21aa`. | Note that automated testing cannot detect all types of WCAG violations.",https://playwright.dev/docs/accessibility-testing,assertion
javascript,"test('should not have any accessibility violations outside of elements with known issues', async ({  
  page,  
}) => {  
  await page.goto('https://your-site.com/page-with-known-issues');  
  
  const accessibilityScanResults = await new AxeBuilder({ page })  
      .exclude('#element-with-known-issue')  
      .analyze();  
  
  expect(accessibilityScanResults.violations).toEqual([]);  
});",Here is an example of excluding one element from being scanned in one specific test:,https://playwright.dev/docs/accessibility-testing,assertion
javascript,"test('should not have any accessibility violations outside of rules with known issues', async ({  
  page,  
}) => {  
  await page.goto('https://your-site.com/page-with-known-issues');  
  
  const accessibilityScanResults = await new AxeBuilder({ page })  
      .disableRules(['duplicate-id'])  
      .analyze();  
  
  expect(accessibilityScanResults.violations).toEqual([]);  
});","If your application contains many different preexisting violations of a specific rule, you can use [`AxeBuilder.disableRules()`](https://github.com/dequelabs/axe-core-npm/blob/develop/packages/playwright/README.md#axebuilderdisablerulesrules-stringarray) to temporarily disable individual rules until you're able to fix the issues. | You can find the rule IDs to pass to `disableRules()` in the `id` property of the violations you want to suppress. A [complete list of axe's rules](https://github.com/dequelabs/axe-core/blob/master/doc/rule-descriptions.md) can be found in `axe-core`'s documentation.",https://playwright.dev/docs/accessibility-testing,assertion
javascript,"// This is less fragile than snapshotting the entire violations array.  
expect(violationFingerprints(accessibilityScanResults)).toMatchSnapshot();  
  
// my-test-utils.js  
function violationFingerprints(accessibilityScanResults) {  
  const violationFingerprints = accessibilityScanResults.violations.map(violation => ({  
    rule: violation.id,  
    // These are CSS selectors which uniquely identify each element with  
    // a violation of the rule in question.  
    targets: violation.nodes.map(node => node.target),  
  }));  
  
  return JSON.stringify(violationFingerprints, null, 2);  
}","Instead, create a _fingerprint_ of the violation(s) in question that contains only enough information to uniquely identify the issue, and use a snapshot of the fingerprint:",https://playwright.dev/docs/accessibility-testing,assertion
javascript,"test('example with attachment', async ({ page }, testInfo) => {  
  await page.goto('https://your-site.com/');  
  
  const accessibilityScanResults = await new AxeBuilder({ page }).analyze();  
  
  await testInfo.attach('accessibility-scan-results', {  
    body: JSON.stringify(accessibilityScanResults, null, 2),  
    contentType: 'application/json'  
  });  
  
  expect(accessibilityScanResults.violations).toEqual([]);  
});","To include _all_ of the scan results as part of your test results for debugging purposes, you can add the scan results as a test attachment with [`testInfo.attach()`](/docs/api/class-testinfo#test-info-attach). [Reporters](/docs/test-reporters) can then embed or link the full results as part of your test output. | The following example demonstrates attaching scan results to a test:",https://playwright.dev/docs/accessibility-testing,assertion
javascript,"import { test as base } from '@playwright/test';  
import AxeBuilder from '@axe-core/playwright';  
  
type AxeFixture = {  
  makeAxeBuilder: () => AxeBuilder;  
};  
  
// Extend base test by providing ""makeAxeBuilder""  
//  
// This new ""test"" can be used in multiple test files, and each of them will get  
// a consistently configured AxeBuilder instance.  
export const test = base.extend<AxeFixture>({  
  makeAxeBuilder: async ({ page }, use, testInfo) => {  
    const makeAxeBuilder = () => new AxeBuilder({ page })  
        .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])  
        .exclude('#commonly-reused-element-with-known-issue');  
  
    await use(makeAxeBuilder);  
  }  
});  
export { expect } from '@playwright/test';  



// axe-test.js  
const base = require('@playwright/test');  
const AxeBuilder = require('@axe-core/playwright').default;  
  
// Extend base test by providing ""makeAxeBuilder""  
//  
// This new ""test"" can be used in multiple test files, and each of them will get  
// a consistently configured AxeBuilder instance.  
exports.test = base.test.extend({  
  makeAxeBuilder: async ({ page }, use, testInfo) => {  
    const makeAxeBuilder = () => new AxeBuilder({ page })  
        .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])  
        .exclude('#commonly-reused-element-with-known-issue');  
  
    await use(makeAxeBuilder);  
  }  
});  
exports.expect = base.expect;",axe-test.ts,https://playwright.dev/docs/accessibility-testing,fixture
javascript,"import { defineConfig } from '@playwright/test';  
export default defineConfig({  
  use: {  
    // All requests we send go to this API endpoint.  
    baseURL: 'https://api.github.com',  
    extraHTTPHeaders: {  
      // We set this header per GitHub guidelines.  
      'Accept': 'application/vnd.github.v3+json',  
      // Add authorization token to all requests.  
      // Assuming personal access token available in the environment.  
      'Authorization': `token ${process.env.API_TOKEN}`,  
    },  
  }  
});","GitHub API requires authorization, so we'll configure the token once for all tests. While at it, we'll also set the `baseURL` to simplify the tests. You can either put them in the configuration file, or in the test file with `test.use()`. | playwright.config.ts",https://playwright.dev/docs/api-testing,general
javascript,"import { defineConfig } from '@playwright/test';  
export default defineConfig({  
  use: {  
    proxy: {  
      server: 'http://my-proxy:8080',  
      username: 'user',  
      password: 'secret'  
    },  
  }  
});","If your tests need to run behind a proxy, you can specify this in the config and the `request` fixture will pick it up automatically: | playwright.config.ts",https://playwright.dev/docs/api-testing,general
javascript,"const REPO = 'test-repo-1';  
const USER = 'github-username';  
  
test('should create a bug report', async ({ request }) => {  
  const newIssue = await request.post(`/repos/${USER}/${REPO}/issues`, {  
    data: {  
      title: '[Bug] report 1',  
      body: 'Bug description',  
    }  
  });  
  expect(newIssue.ok()).toBeTruthy();  
  
  const issues = await request.get(`/repos/${USER}/${REPO}/issues`);  
  expect(issues.ok()).toBeTruthy();  
  expect(await issues.json()).toContainEqual(expect.objectContaining({  
    title: '[Bug] report 1',  
    body: 'Bug description'  
  }));  
});  
  
test('should create a feature request', async ({ request }) => {  
  const newIssue = await request.post(`/repos/${USER}/${REPO}/issues`, {  
    data: {  
      title: '[Feature] request 1',  
      body: 'Feature description',  
    }  
  });  
  expect(newIssue.ok()).toBeTruthy();  
  
  const issues = await request.get(`/repos/${USER}/${REPO}/issues`);  
  expect(issues.ok()).toBeTruthy();  
  expect(await issues.json()).toContainEqual(expect.objectContaining({  
    title: '[Feature] request 1',  
    body: 'Feature description'  
  }));  
});",Playwright Test comes with the built-in `request` fixture that respects configuration options like `baseURL` or `extraHTTPHeaders` we specified and is ready to send some requests. | Now we can add a few tests that will create new issues in the repository.,https://playwright.dev/docs/api-testing,assertion
javascript,"test.beforeAll(async ({ request }) => {  
  // Create a new repository  
  const response = await request.post('/user/repos', {  
    data: {  
      name: REPO  
    }  
  });  
  expect(response.ok()).toBeTruthy();  
});  
  
test.afterAll(async ({ request }) => {  
  // Delete the repository  
  const response = await request.delete(`/repos/${USER}/${REPO}`);  
  expect(response.ok()).toBeTruthy();  
});",Setup and teardownâ€‹ | These tests assume that repository exists. You probably want to create a new one before running tests and delete it afterwards. Use `beforeAll` and `afterAll` hooks for that.,https://playwright.dev/docs/api-testing,fixture
javascript,"import { request } from '@playwright/test';  
const REPO = 'test-repo-1';  
const USER = 'github-username';  
  
(async () => {  
  // Create a context that will issue http requests.  
  const context = await request.newContext({  
    baseURL: 'https://api.github.com',  
  });  
  
  // Create a repository.  
  await context.post('/user/repos', {  
    headers: {  
      'Accept': 'application/vnd.github.v3+json',  
      // Add GitHub personal access token.  
      'Authorization': `token ${process.env.API_TOKEN}`,  
    },  
    data: {  
      name: REPO  
    }  
  });  
  
  // Delete a repository.  
  await context.delete(`/repos/${USER}/${REPO}`, {  
    headers: {  
      'Accept': 'application/vnd.github.v3+json',  
      // Add GitHub personal access token.  
      'Authorization': `token ${process.env.API_TOKEN}`,  
    }  
  });  
})();","Using request contextâ€‹ | Behind the scenes, [`request` fixture](/docs/api/class-fixtures#fixtures-request) will actually call [apiRequest.newContext()](/docs/api/class-apirequest#api-request-new-context). You can always do that manually if you'd like more control. Below is a standalone script that does the same as `beforeAll` and `afterAll` from above.",https://playwright.dev/docs/api-testing,wait_strategy
javascript,"import { test, expect } from '@playwright/test';  
  
const REPO = 'test-repo-1';  
const USER = 'github-username';  
  
// Request context is reused by all tests in the file.  
let apiContext;  
  
test.beforeAll(async ({ playwright }) => {  
  apiContext = await playwright.request.newContext({  
    // All requests we send go to this API endpoint.  
    baseURL: 'https://api.github.com',  
    extraHTTPHeaders: {  
      // We set this header per GitHub guidelines.  
      'Accept': 'application/vnd.github.v3+json',  
      // Add authorization token to all requests.  
      // Assuming personal access token available in the environment.  
      'Authorization': `token ${process.env.API_TOKEN}`,  
    },  
  });  
});  
  
test.afterAll(async ({ }) => {  
  // Dispose all responses.  
  await apiContext.dispose();  
});  
  
test('last created issue should be first in the list', async ({ page }) => {  
  const newIssue = await apiContext.post(`/repos/${USER}/${REPO}/issues`, {  
    data: {  
      title: '[Feature] request 1',  
    }  
  });  
  expect(newIssue.ok()).toBeTruthy();  
  
  await page.goto(`https://github.com/${USER}/${REPO}/issues`);  
  const firstIssue = page.locator(`a[data-hovercard-type='issue']`).first();  
  await expect(firstIssue).toHaveText('[Feature] request 1');  
});",Establishing preconditionsâ€‹ | The following test creates a new issue via API and then navigates to the list of all issues in the project to check that it appears at the top of the list.,https://playwright.dev/docs/api-testing,fixture
javascript,"import { test, expect } from '@playwright/test';  
  
const REPO = 'test-repo-1';  
const USER = 'github-username';  
  
// Request context is reused by all tests in the file.  
let apiContext;  
  
test.beforeAll(async ({ playwright }) => {  
  apiContext = await playwright.request.newContext({  
    // All requests we send go to this API endpoint.  
    baseURL: 'https://api.github.com',  
    extraHTTPHeaders: {  
      // We set this header per GitHub guidelines.  
      'Accept': 'application/vnd.github.v3+json',  
      // Add authorization token to all requests.  
      // Assuming personal access token available in the environment.  
      'Authorization': `token ${process.env.API_TOKEN}`,  
    },  
  });  
});  
  
test.afterAll(async ({ }) => {  
  // Dispose all responses.  
  await apiContext.dispose();  
});  
  
test('last created issue should be on the server', async ({ page }) => {  
  await page.goto(`https://github.com/${USER}/${REPO}/issues`);  
  await page.getByText('New Issue').click();  
  await page.getByRole('textbox', { name: 'Title' }).fill('Bug report 1');  
  await page.getByRole('textbox', { name: 'Comment body' }).fill('Bug description');  
  await page.getByText('Submit new issue').click();  
  const issueId = page.url().substr(page.url().lastIndexOf('/'));  
  
  const newIssue = await apiContext.get(  
      `https://api.github.com/repos/${USER}/${REPO}/issues/${issueId}`  
  );  
  expect(newIssue.ok()).toBeTruthy();  
  expect(newIssue.json()).toEqual(expect.objectContaining({  
    title: 'Bug report 1'  
  }));  
});",Validating postconditionsâ€‹ | The following test creates a new issue via user interface in the browser and then uses checks if it was created via API:,https://playwright.dev/docs/api-testing,fixture
javascript,"const requestContext = await request.newContext({  
  httpCredentials: {  
    username: 'user',  
    password: 'passwd'  
  }  
});  
await requestContext.get(`https://api.example.com/login`);  
// Save storage state into the file.  
await requestContext.storageState({ path: 'state.json' });  
  
// Create a new context with the saved storage state.  
const context = await browser.newContext({ storageState: 'state.json' });","Web apps use cookie-based or token-based authentication, where authenticated state is stored as [cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies). Playwright provides [apiRequestContext.storageState()](/docs/api/class-apirequestcontext#api-request-context-storage-state) method that can be used to retrieve storage state from an authenticated context and then create new contexts with that state. | Storage state is interchangeable between [BrowserContext](/docs/api/class-browsercontext ""BrowserContext"") and [APIRequestContext](/docs/api/class-apirequestcontext ""APIRequestContext""). You can use it to log in via API calls and then create a new context with cookies already there. The following code snippet retrieves state from an authenticated [APIRequestContext](/docs/api/class-apirequestcontext ""APIRequestContext"") and creates a new [BrowserContext](/docs/api/class-browsercontext ""BrowserContext"") with that state.",https://playwright.dev/docs/api-testing,wait_strategy
javascript,"test('context request will share cookie storage with its browser context', async ({  
  page,  
  context,  
}) => {  
  await context.route('https://www.github.com/', async route => {  
    // Send an API request that shares cookie storage with the browser context.  
    const response = await context.request.fetch(route.request());  
    const responseHeaders = response.headers();  
  
    // The response will have 'Set-Cookie' header.  
    const responseCookies = new Map(responseHeaders['set-cookie']  
        .split('\n')  
        .map(c => c.split(';', 2)[0].split('=')));  
    // The response will have 3 cookies in 'Set-Cookie' header.  
    expect(responseCookies.size).toBe(3);  
    const contextCookies = await context.cookies();  
    // The browser context will already contain all the cookies from the API response.  
    expect(new Map(contextCookies.map(({ name, value }) =>  
      [name, value])  
    )).toEqual(responseCookies);  
  
    await route.fulfill({  
      response,  
      headers: { ...responseHeaders, foo: 'bar' },  
    });  
  });  
  await page.goto('https://www.github.com/');  
});","The main difference is that [APIRequestContext](/docs/api/class-apirequestcontext ""APIRequestContext"") accessible via [browserContext.request](/docs/api/class-browsercontext#browser-context-request) and [page.request](/docs/api/class-page#page-request) will populate request's `Cookie` header from the browser context and will automatically update browser cookies if [APIResponse](/docs/api/class-apiresponse ""APIResponse"") has `Set-Cookie` header:",https://playwright.dev/docs/api-testing,assertion
javascript,"const { chromium, firefox, webkit } = require('playwright');  
  
(async () => {  
  const browser = await chromium.launch();  // Or 'firefox' or 'webkit'.  
  const page = await browser.newPage();  
  await page.goto('http://example.com');  
  // other actions...  
  await browser.close();  
})();",Playwright Library | Playwright module provides a method to launch a browser instance. The following is a typical example of using Playwright to drive automation:,https://playwright.dev/docs/api/class-playwright,navigation
javascript,"const { webkit, devices } = require('playwright');  
const iPhone = devices['iPhone 6'];  
  
(async () => {  
  const browser = await webkit.launch();  
  const context = await browser.newContext({  
    ...iPhone  
  });  
  const page = await context.newPage();  
  await page.goto('http://example.com');  
  // other actions...  
  await browser.close();  
})();",Added before v1.9 playwright.devices | Returns a dictionary of devices to be used with [browser.newContext()](/docs/api/class-browser#browser-new-context) or [browser.newPage()](/docs/api/class-browser#browser-new-page).,https://playwright.dev/docs/api/class-playwright,navigation
javascript,"try {  
  await page.locator('.foo').waitFor();  
} catch (e) {  
  if (e instanceof playwright.errors.TimeoutError) {  
    // Do something if this is a timeout.  
  }  
}",For certain types of errors Playwright uses specific error classes. These classes are available via `playwright.errors`. | An example of handling a timeout error:,https://playwright.dev/docs/api/class-playwright,wait_strategy
javascript,"await expect(page.locator('body')).toMatchAriaSnapshot(`  
  - heading ""title""  
`);",You can match it using the following snapshot template:,https://playwright.dev/docs/aria-snapshots,assertion
javascript,await expect(locator).toMatchAriaSnapshot('');,Empty template for snapshot generationâ€‹ | Passing an empty string as the template in an assertion generates a snapshot on-the-fly:,https://playwright.dev/docs/aria-snapshots,assertion
javascript,"const snapshot = await page.locator('body').ariaSnapshot();  
console.log(snapshot);","The [locator.ariaSnapshot()](/docs/api/class-locator#locator-aria-snapshot) method allows you to programmatically create a YAML representation of accessible elements within a locatorâ€™s scope, especially helpful for generating snapshots dynamically during test execution. | **Example** :",https://playwright.dev/docs/aria-snapshots,wait_strategy
javascript,"import { test as setup, expect } from '@playwright/test';  
import path from 'path';  
  
const authFile = path.join(__dirname, '../playwright/.auth/user.json');  
  
setup('authenticate', async ({ page }) => {  
  // Perform authentication steps. Replace these actions with your own.  
  await page.goto('https://github.com/login');  
  await page.getByLabel('Username or email address').fill('username');  
  await page.getByLabel('Password').fill('password');  
  await page.getByRole('button', { name: 'Sign in' }).click();  
  // Wait until the page receives the cookies.  
  //  
  // Sometimes login flow sets cookies in the process of several redirects.  
  // Wait for the final URL to ensure that the cookies are actually set.  
  await page.waitForURL('https://github.com/');  
  // Alternatively, you can wait until the page reaches a state where all cookies are set.  
  await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  
  
  // End of authentication steps.  
  
  await page.context().storageState({ path: authFile });  
});",Create `tests/auth.setup.ts` that will prepare authenticated browser state for all other tests. | tests/auth.setup.ts,https://playwright.dev/docs/auth,assertion
javascript,"import { defineConfig, devices } from '@playwright/test';  
  
export default defineConfig({  
  projects: [  
    // Setup project  
    { name: 'setup', testMatch: /.*\.setup\.ts/ },  
  
    {  
      name: 'chromium',  
      use: {  
        ...devices['Desktop Chrome'],  
        // Use prepared auth state.  
        storageState: 'playwright/.auth/user.json',  
      },  
      dependencies: ['setup'],  
    },  
  
    {  
      name: 'firefox',  
      use: {  
        ...devices['Desktop Firefox'],  
        // Use prepared auth state.  
        storageState: 'playwright/.auth/user.json',  
      },  
      dependencies: ['setup'],  
    },  
  ],  
});",Create a new `setup` project in the config and declare it as a [dependency](/docs/test-projects#dependencies) for all your testing projects. This project will always run and authenticate before all the tests. All testing projects should use the authenticated state as `storageState`. | playwright.config.ts,https://playwright.dev/docs/auth,general
javascript,"import { test } from '@playwright/test';  
  
test('test', async ({ page }) => {  
  // page is authenticated  
});",Tests start already authenticated because we specified `storageState` in the config. | tests/example.spec.ts,https://playwright.dev/docs/auth,general
javascript,"import { test as baseTest, expect } from '@playwright/test';  
import fs from 'fs';  
import path from 'path';  
  
export * from '@playwright/test';  
export const test = baseTest.extend<{}, { workerStorageState: string }>({  
  // Use the same storage state for all tests in this worker.  
  storageState: ({ workerStorageState }, use) => use(workerStorageState),  
  
  // Authenticate once per worker with a worker-scoped fixture.  
  workerStorageState: [async ({ browser }, use) => {  
    // Use parallelIndex as a unique identifier for each worker.  
    const id = test.info().parallelIndex;  
    const fileName = path.resolve(test.info().project.outputDir, `.auth/${id}.json`);  
  
    if (fs.existsSync(fileName)) {  
      // Reuse existing authentication state if any.  
      await use(fileName);  
      return;  
    }  
  
    // Important: make sure we authenticate in a clean environment by unsetting storage state.  
    const page = await browser.newPage({ storageState: undefined });  
  
    // Acquire a unique account, for example create a new one.  
    // Alternatively, you can have a list of precreated accounts for testing.  
    // Make sure that accounts are unique, so that multiple team members  
    // can run tests at the same time without interference.  
    const account = await acquireAccount(id);  
  
    // Perform authentication steps. Replace these actions with your own.  
    await page.goto('https://github.com/login');  
    await page.getByLabel('Username or email address').fill(account.username);  
    await page.getByLabel('Password').fill(account.password);  
    await page.getByRole('button', { name: 'Sign in' }).click();  
    // Wait until the page receives the cookies.  
    //  
    // Sometimes login flow sets cookies in the process of several redirects.  
    // Wait for the final URL to ensure that the cookies are actually set.  
    await page.waitForURL('https://github.com/');  
    // Alternatively, you can wait until the page reaches a state where all cookies are set.  
    await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  
  
    // End of authentication steps.  
  
    await page.context().storageState({ path: fileName });  
    await page.close();  
    await use(fileName);  
  }, { scope: 'worker' }],  
});",Create `playwright/fixtures.ts` file that will [override `storageState` fixture](/docs/test-fixtures#overriding-fixtures) to authenticate once per worker. Use [testInfo.parallelIndex](/docs/api/class-testinfo#test-info-parallel-index) to differentiate between workers. | playwright/fixtures.ts,https://playwright.dev/docs/auth,fixture
javascript,"// Important: import our fixtures.  
import { test, expect } from '../playwright/fixtures';  
  
test('test', async ({ page }) => {  
  // page is authenticated  
});","Now, each test file should import `test` from our fixtures file instead of `@playwright/test`. No changes are needed in the config. | tests/example.spec.ts",https://playwright.dev/docs/auth,fixture
javascript,"import { test as setup } from '@playwright/test';  
  
const authFile = 'playwright/.auth/user.json';  
  
setup('authenticate', async ({ request }) => {  
  // Send authentication request. Replace with your own.  
  await request.post('https://github.com/login', {  
    form: {  
      'user': 'user',  
      'password': 'password'  
    }  
  });  
  await request.storageState({ path: authFile });  
});",In the setup project: | tests/auth.setup.ts,https://playwright.dev/docs/auth,wait_strategy
javascript,"import { test as baseTest, request } from '@playwright/test';  
import fs from 'fs';  
import path from 'path';  
  
export * from '@playwright/test';  
export const test = baseTest.extend<{}, { workerStorageState: string }>({  
  // Use the same storage state for all tests in this worker.  
  storageState: ({ workerStorageState }, use) => use(workerStorageState),  
  
  // Authenticate once per worker with a worker-scoped fixture.  
  workerStorageState: [async ({}, use) => {  
    // Use parallelIndex as a unique identifier for each worker.  
    const id = test.info().parallelIndex;  
    const fileName = path.resolve(test.info().project.outputDir, `.auth/${id}.json`);  
  
    if (fs.existsSync(fileName)) {  
      // Reuse existing authentication state if any.  
      await use(fileName);  
      return;  
    }  
  
    // Important: make sure we authenticate in a clean environment by unsetting storage state.  
    const context = await request.newContext({ storageState: undefined });  
  
    // Acquire a unique account, for example create a new one.  
    // Alternatively, you can have a list of precreated accounts for testing.  
    // Make sure that accounts are unique, so that multiple team members  
    // can run tests at the same time without interference.  
    const account = await acquireAccount(id);  
  
    // Send authentication request. Replace with your own.  
    await context.post('https://github.com/login', {  
      form: {  
        'user': 'user',  
        'password': 'password'  
      }  
    });  
  
    await context.storageState({ path: fileName });  
    await context.dispose();  
    await use(fileName);  
  }, { scope: 'worker' }],  
});","Alternatively, in a worker fixture: | playwright/fixtures.ts",https://playwright.dev/docs/auth,fixture
javascript,"import { test as setup, expect } from '@playwright/test';  
  
const adminFile = 'playwright/.auth/admin.json';  
  
setup('authenticate as admin', async ({ page }) => {  
  // Perform authentication steps. Replace these actions with your own.  
  await page.goto('https://github.com/login');  
  await page.getByLabel('Username or email address').fill('admin');  
  await page.getByLabel('Password').fill('password');  
  await page.getByRole('button', { name: 'Sign in' }).click();  
  // Wait until the page receives the cookies.  
  //  
  // Sometimes login flow sets cookies in the process of several redirects.  
  // Wait for the final URL to ensure that the cookies are actually set.  
  await page.waitForURL('https://github.com/');  
  // Alternatively, you can wait until the page reaches a state where all cookies are set.  
  await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  
  
  // End of authentication steps.  
  
  await page.context().storageState({ path: adminFile });  
});  
  
const userFile = 'playwright/.auth/user.json';  
  
setup('authenticate as user', async ({ page }) => {  
  // Perform authentication steps. Replace these actions with your own.  
  await page.goto('https://github.com/login');  
  await page.getByLabel('Username or email address').fill('user');  
  await page.getByLabel('Password').fill('password');  
  await page.getByRole('button', { name: 'Sign in' }).click();  
  // Wait until the page receives the cookies.  
  //  
  // Sometimes login flow sets cookies in the process of several redirects.  
  // Wait for the final URL to ensure that the cookies are actually set.  
  await page.waitForURL('https://github.com/');  
  // Alternatively, you can wait until the page reaches a state where all cookies are set.  
  await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  
  
  // End of authentication steps.  
  
  await page.context().storageState({ path: userFile });  
});",We will authenticate multiple times in the setup project. | tests/auth.setup.ts,https://playwright.dev/docs/auth,assertion
javascript,"import { test } from '@playwright/test';  
  
test.use({ storageState: 'playwright/.auth/admin.json' });  
  
test('admin test', async ({ page }) => {  
  // page is authenticated as admin  
});  
  
test.describe(() => {  
  test.use({ storageState: 'playwright/.auth/user.json' });  
  
  test('user test', async ({ page }) => {  
    // page is authenticated as a user  
  });  
});","After that, specify `storageState` for each test file or test group, **instead of** setting it in the config. | tests/example.spec.ts",https://playwright.dev/docs/auth,general
javascript,"import { test } from '@playwright/test';  
  
test('admin and user', async ({ browser }) => {  
  // adminContext and all pages inside, including adminPage, are signed in as ""admin"".  
  const adminContext = await browser.newContext({ storageState: 'playwright/.auth/admin.json' });  
  const adminPage = await adminContext.newPage();  
  
  // userContext and all pages inside, including userPage, are signed in as ""user"".  
  const userContext = await browser.newContext({ storageState: 'playwright/.auth/user.json' });  
  const userPage = await userContext.newPage();  
  
  // ... interact with both adminPage and userPage ...  
  
  await adminContext.close();  
  await userContext.close();  
});","Use multiple [BrowserContext](/docs/api/class-browsercontext ""BrowserContext"")s and [Page](/docs/api/class-page ""Page"")s with different storage states in the same test. | tests/example.spec.ts",https://playwright.dev/docs/auth,wait_strategy
javascript,"import { test as base, type Page, type Locator } from '@playwright/test';  
  
// Page Object Model for the ""admin"" page.  
// Here you can add locators and helper methods specific to the admin page.  
class AdminPage {  
  // Page signed in as ""admin"".  
  page: Page;  
  
  // Example locator pointing to ""Welcome, Admin"" greeting.  
  greeting: Locator;  
  
  constructor(page: Page) {  
    this.page = page;  
    this.greeting = page.locator('#greeting');  
  }  
}  
  
// Page Object Model for the ""user"" page.  
// Here you can add locators and helper methods specific to the user page.  
class UserPage {  
  // Page signed in as ""user"".  
  page: Page;  
  
  // Example locator pointing to ""Welcome, User"" greeting.  
  greeting: Locator;  
  
  constructor(page: Page) {  
    this.page = page;  
    this.greeting = page.locator('#greeting');  
  }  
}  
  
// Declare the types of your fixtures.  
type MyFixtures = {  
  adminPage: AdminPage;  
  userPage: UserPage;  
};  
  
export * from '@playwright/test';  
export const test = base.extend<MyFixtures>({  
  adminPage: async ({ browser }, use) => {  
    const context = await browser.newContext({ storageState: 'playwright/.auth/admin.json' });  
    const adminPage = new AdminPage(await context.newPage());  
    await use(adminPage);  
    await context.close();  
  },  
  userPage: async ({ browser }, use) => {  
    const context = await browser.newContext({ storageState: 'playwright/.auth/user.json' });  
    const userPage = new UserPage(await context.newPage());  
    await use(userPage);  
    await context.close();  
  },  
});",Below is an example that [creates fixtures](/docs/test-fixtures#creating-a-fixture) for two [Page Object Models](/docs/pom) \- admin POM and user POM. It assumes `adminStorageState.json` and `userStorageState.json` files were created in the global setup. | playwright/fixtures.ts,https://playwright.dev/docs/auth,page_object
javascript,"// Import test with our new fixtures.  
import { test, expect } from '../playwright/fixtures';  
  
// Use adminPage and userPage fixtures in the test.  
test('admin and user', async ({ adminPage, userPage }) => {  
  // ... interact with both adminPage and userPage ...  
  await expect(adminPage.greeting).toHaveText('Welcome, Admin');  
  await expect(userPage.greeting).toHaveText('Welcome, User');  
});",tests/example.spec.ts,https://playwright.dev/docs/auth,fixture
javascript,"// Get session storage and store as env variable  
const sessionStorage = await page.evaluate(() => JSON.stringify(sessionStorage));  
fs.writeFileSync('playwright/.auth/session.json', sessionStorage, 'utf-8');  
  
// Set session storage in a new context  
const sessionStorage = JSON.parse(fs.readFileSync('playwright/.auth/session.json', 'utf-8'));  
await context.addInitScript(storage => {  
  if (window.location.hostname === 'example.com') {  
    for (const [key, value] of Object.entries(storage))  
      window.sessionStorage.setItem(key, value);  
  }  
}, sessionStorage);","Session storageâ€‹ | Reusing authenticated state covers [cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies) and [local storage](https://developer.mozilla.org/en-US/docs/Web/API/Storage) based authentication. Rarely, [session storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage) is used for storing information associated with the signed-in state. Session storage is specific to a particular domain and is not persisted across page loads. Playwright does not provide API to persist session storage, but the following snippet can be used to save/load session storage.",https://playwright.dev/docs/auth,wait_strategy
javascript,"import { test } from '@playwright/test';  
  
test.beforeEach(async ({ page }) => {  
  // Runs before each test and signs in each page.  
  await page.goto('https://github.com/login');  
  await page.getByLabel('Username or email address').fill('username');  
  await page.getByLabel('Password').fill('password');  
  await page.getByRole('button', { name: 'Sign in' }).click();  
});  
  
test('first', async ({ page }) => {  
  // page is signed in.  
});  
  
test('second', async ({ page }) => {  
  // page is signed in.  
});","Each test should be completely isolated from another test and should run independently with its own local storage, session storage, data, cookies etc. [Test isolation](/docs/browser-contexts) improves reproducibility, makes debugging easier and prevents cascading test failures. | In order to avoid repetition for a particular part of your test you can use [before and after hooks](/docs/api/class-test). Within your test file add a before hook to run a part of your test before each test such as going to a particular URL or logging in to a part of your app. This keeps your tests isolated as no test relies on another. However it is also ok to have a little duplication when tests are simple enough especially if it keeps your tests clearer and easier to read and maintain.",https://playwright.dev/docs/best-practices,navigation
javascript,"await page.route('**/api/fetch_data_third_party_dependency', route => route.fulfill({  
  status: 200,  
  body: testData,  
}));  
await page.goto('https://example.com');","Only test what you control. Don't try to test links to external sites or third party servers that you do not control. Not only is it time consuming and can slow down your tests but also you cannot control the content of the page you are linking to, or if there are cookie banners or overlay pages or anything else that might cause your test to fail. | Instead, use the [Playwright Network API](/docs/network#handle-requests) and guarantee the response needed.",https://playwright.dev/docs/best-practices,navigation
javascript,const product = page.getByRole('listitem').filter({ hasText: 'Product 2' });,Use chaining and filteringâ€‹ | Locators can be [chained](/docs/locators#matching-inside-a-locator) to narrow down the search to a particular part of the page.,https://playwright.dev/docs/best-practices,general
javascript,"await page  
    .getByRole('listitem')  
    .filter({ hasText: 'Product 2' })  
    .getByRole('button', { name: 'Add to cart' })  
    .click();",You can also [filter locators](/docs/locators#filtering-locators) by text or by another locator.,https://playwright.dev/docs/best-practices,navigation
javascript,"// ðŸ‘  
await expect(page.getByText('welcome')).toBeVisible();  
  
// ðŸ‘Ž  
expect(await page.getByText('welcome').isVisible()).toBe(true);","Use web first assertionsâ€‹ | Assertions are a way to verify that the expected result and the actual result matched or not. By using [web first assertions](/docs/test-assertions) Playwright will wait until the expected condition is met. For example, when testing an alert message, a test would click a button that makes a message appear and check that the alert message is there. If the alert message takes half a second to appear, assertions such as `toBeVisible()` will wait and retry if needed.",https://playwright.dev/docs/best-practices,assertion
javascript,"// ðŸ‘Ž  
expect(await page.getByText('welcome').isVisible()).toBe(true);","Don't use manual assertionsâ€‹ | Don't use manual assertions that are not awaiting the expect. In the code below the await is inside the expect rather than before it. When using assertions such as `isVisible()` the test won't wait a single second, it will just check the locator is there and return immediately.",https://playwright.dev/docs/best-practices,assertion
javascript,"// ðŸ‘  
await expect(page.getByText('welcome')).toBeVisible();",Use web first assertions such as `toBeVisible()` instead.,https://playwright.dev/docs/best-practices,assertion
javascript,"import { defineConfig, devices } from '@playwright/test';  
  
export default defineConfig({  
  projects: [  
    {  
      name: 'chromium',  
      use: { ...devices['Desktop Chrome'] },  
    },  
    {  
      name: 'firefox',  
      use: { ...devices['Desktop Firefox'] },  
    },  
    {  
      name: 'webkit',  
      use: { ...devices['Desktop Safari'] },  
    },  
  ],  
});",Playwright makes it easy to test your site across all [browsers](/docs/test-projects#configure-projects-for-multiple-browsers) no matter what platform you are on. Testing across all browsers ensures your app works for all users. In your config file you can set up projects adding the name and which browser or device to use. | playwright.config.ts,https://playwright.dev/docs/best-practices,general
javascript,"import { test } from '@playwright/test';  
  
test.describe.configure({ mode: 'parallel' });  
  
test('runs in parallel 1', async ({ page }) => { /* ... */ });  
test('runs in parallel 2', async ({ page }) => { /* ... */ });","Use parallelism and shardingâ€‹ | Playwright runs tests in [parallel](/docs/test-parallel) by default. Tests in a single file are run in order, in the same worker process. If you have many independent tests in a single file, you might want to run them in parallel",https://playwright.dev/docs/best-practices,general
javascript,"import { test } from '@playwright/test';  
  
test('example test', async ({ page, context }) => {  
  // ""context"" is an isolated BrowserContext, created for this specific test.  
  // ""page"" belongs to this context.  
});  
  
test('another test', async ({ page, context }) => {  
  // ""context"" and ""page"" in this second test are completely  
  // isolated from the first test.  
});  



const browser = await chromium.launch();  
const context = await browser.newContext();  
const page = await context.newPage();",Library,https://playwright.dev/docs/browser-contexts,wait_strategy
javascript,"import { defineConfig, devices } from '@playwright/test';  
  
export default defineConfig({  
  projects: [  
    /* Test against desktop browsers */  
    {  
      name: 'chromium',  
      use: { ...devices['Desktop Chrome'] },  
    },  
    {  
      name: 'firefox',  
      use: { ...devices['Desktop Firefox'] },  
    },  
    {  
      name: 'webkit',  
      use: { ...devices['Desktop Safari'] },  
    },  
    /* Test against mobile viewports. */  
    {  
      name: 'Mobile Chrome',  
      use: { ...devices['Pixel 5'] },  
    },  
    {  
      name: 'Mobile Safari',  
      use: { ...devices['iPhone 12'] },  
    },  
    /* Test against branded browsers. */  
    {  
      name: 'Google Chrome',  
      use: { ...devices['Desktop Chrome'], channel: 'chrome' }, // or 'chrome-beta'  
    },  
    {  
      name: 'Microsoft Edge',  
      use: { ...devices['Desktop Edge'], channel: 'msedge' }, // or 'msedge-dev'  
    },  
  ],  
});",Run tests on different browsersâ€‹ | Playwright can run your tests in multiple browsers and configurations by setting up **projects** in the config. You can also add [different options](/docs/test-configuration) for each project.,https://playwright.dev/docs/browsers,general
javascript,"import { defineConfig, devices } from '@playwright/test';  
  
export default defineConfig({  
  projects: [  
    {  
      name: 'chromium',  
      use: { ...devices['Desktop Chrome'], channel: 'chromium' },  
    },  
  ],  
});","> New Headless on the other hand is the real Chrome browser, and is thus more authentic, reliable, and offers more features. This makes it more suitable for high-accuracy end-to-end web app testing or browser extension testing. | See [issue #33566](https://github.com/microsoft/playwright/issues/33566) for details.",https://playwright.dev/docs/browsers,general
javascript,"import { defineConfig, devices } from '@playwright/test';  
  
export default defineConfig({  
  projects: [  
    /* Test against branded browsers. */  
    {  
      name: 'Google Chrome',  
      use: { ...devices['Desktop Chrome'], channel: 'chrome' }, // or 'chrome-beta'  
    },  
    {  
      name: 'Microsoft Edge',  
      use: { ...devices['Desktop Edge'], channel: 'msedge' }, // or ""msedge-beta"" or 'msedge-dev'  
    },  
  ],  
});","warning | Google Chrome and Microsoft Edge have switched to a [new headless mode](https://developer.chrome.com/docs/chromium/headless) implementation that is closer to a regular headed mode. This differs from [chromium headless shell](https://developer.chrome.com/blog/chrome-headless-shell) that is used in Playwright by default when running headless, so expect different behavior in some cases. See [issue #33566](https://github.com/microsoft/playwright/issues/33566) fore details.",https://playwright.dev/docs/browsers,general
javascript,"const { chromium } = require('playwright');  
  
(async () => {  
  const pathToExtension = require('path').join(__dirname, 'my-extension');  
  const userDataDir = '/tmp/test-user-data-dir';  
  const browserContext = await chromium.launchPersistentContext(userDataDir, {  
    headless: false,  
    args: [  
      `--disable-extensions-except=${pathToExtension}`,  
      `--load-extension=${pathToExtension}`  
    ]  
  });  
  let [backgroundPage] = browserContext.backgroundPages();  
  if (!backgroundPage)  
    backgroundPage = await browserContext.waitForEvent('backgroundpage');  
  
  // Test the background page as you would any other page.  
  await browserContext.close();  
})();","Extensions only work in Chrome / Chromium launched with a persistent context. Use custom browser args at your own risk, as some of them may break Playwright functionality. | The following is code for getting a handle to the [background page](https://developer.chrome.com/extensions/background_pages) of a [Manifest v2](https://developer.chrome.com/docs/extensions/mv2/) extension whose source is located in `./my-extension`:",https://playwright.dev/docs/chrome-extensions,wait_strategy
javascript,"import { test as base, chromium, type BrowserContext } from '@playwright/test';  
import path from 'path';  
  
export const test = base.extend<{  
  context: BrowserContext;  
  extensionId: string;  
}>({  
  context: async ({ }, use) => {  
    const pathToExtension = path.join(__dirname, 'my-extension');  
    const context = await chromium.launchPersistentContext('', {  
      headless: false,  
      args: [  
        `--disable-extensions-except=${pathToExtension}`,  
        `--load-extension=${pathToExtension}`,  
      ],  
    });  
    await use(context);  
    await context.close();  
  },  
  extensionId: async ({ context }, use) => {  
    /*  
    // for manifest v2:  
    let [background] = context.backgroundPages()  
    if (!background)  
      background = await context.waitForEvent('backgroundpage')  
    */  
  
    // for manifest v3:  
    let [background] = context.serviceWorkers();  
    if (!background)  
      background = await context.waitForEvent('serviceworker');  
  
    const extensionId = background.url().split('/')[2];  
    await use(extensionId);  
  },  
});  
export const expect = test.expect;","First, add fixtures that will load the extension: | fixtures.ts",https://playwright.dev/docs/chrome-extensions,assertion
javascript,"import { test, expect } from './fixtures';  
  
test('example test', async ({ page }) => {  
  await page.goto('https://example.com');  
  await expect(page.locator('body')).toHaveText('Changed by my-extension');  
});  
  
test('popup page', async ({ page, extensionId }) => {  
  await page.goto(`chrome-extension://${extensionId}/popup.html`);  
  await expect(page.locator('body')).toHaveText('my-extension popup');  
});",Then use these fixtures in a test:,https://playwright.dev/docs/chrome-extensions,fixture
javascript,"<div id=""current-time"" data-testid=""current-time""></div>  
<script>  
  const renderTime = () => {  
    document.getElementById('current-time').textContent =  
        new Date().toLocaleString();  
  };  
  setInterval(renderTime, 1000);  
</script>  



await page.clock.setFixedTime(new Date('2024-02-02T10:00:00'));  
await page.goto('http://localhost:3333');  
await expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  
  
await page.clock.setFixedTime(new Date('2024-02-02T10:30:00'));  
// We know that the page has a timer that updates the time every second.  
await expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:30:00 AM');","Test with predefined timeâ€‹ | Often you only need to fake `Date.now` while keeping the timers going. That way the time flows naturally, but `Date.now` always returns a fixed value.",https://playwright.dev/docs/clock,assertion
javascript,"<div id=""current-time"" data-testid=""current-time""></div>  
<script>  
  const renderTime = () => {  
    document.getElementById('current-time').textContent =  
        new Date().toLocaleString();  
  };  
  setInterval(renderTime, 1000);  
</script>  



// Initialize clock with some time before the test time and let the page load  
// naturally. `Date.now` will progress as the timers fire.  
await page.clock.install({ time: new Date('2024-02-02T08:00:00') });  
await page.goto('http://localhost:3333');  
  
// Pretend that the user closed the laptop lid and opened it again at 10am,  
// Pause the time once reached that point.  
await page.clock.pauseAt(new Date('2024-02-02T10:00:00'));  
  
// Assert the page state.  
await expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  
  
// Close the laptop lid again and open it at 10:30am.  
await page.clock.fastForward('30:00');  
await expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:30:00 AM');","Consistent time and timersâ€‹ | Sometimes your timers depend on `Date.now` and are confused when the `Date.now` value does not change over time. In this case, you can install the clock and fast forward to the time of interest when testing.",https://playwright.dev/docs/clock,assertion
javascript,"<div id=""remaining-time"" data-testid=""remaining-time""></div>  
<script>  
  const endTime = Date.now() + 5 * 60_000;  
  const renderTime = () => {  
    const diffInSeconds = Math.round((endTime - Date.now()) / 1000);  
    if (diffInSeconds <= 0) {  
      document.getElementById('remaining-time').textContent =  
        'You have been logged out due to inactivity.';  
    } else {  
      document.getElementById('remaining-time').textContent =  
        `You will be logged out in ${diffInSeconds} seconds.`;  
    }  
    setTimeout(renderTime, 1000);  
  };  
  renderTime();  
</script>  
<button type=""button"">Interaction</button>  



// Initial time does not matter for the test, so we can pick current time.  
await page.clock.install();  
await page.goto('http://localhost:3333');  
// Interact with the page  
await page.getByRole('button').click();  
  
// Fast forward time 5 minutes as if the user did not do anything.  
// Fast forward is like closing the laptop lid and opening it after 5 minutes.  
// All the timers due will fire once immediately, as in the real browser.  
await page.clock.fastForward('05:00');  
  
// Check that the user was logged out automatically.  
await expect(page.getByText('You have been logged out due to inactivity.')).toBeVisible();","Test inactivity monitoringâ€‹ | Inactivity monitoring is a common feature in web applications that logs out users after a period of inactivity. Testing this feature can be tricky because you need to wait for a long time to see the effect. With the help of the clock, you can speed up time and test this feature quickly.",https://playwright.dev/docs/clock,assertion
javascript,"<div id=""current-time"" data-testid=""current-time""></div>  
<script>  
  const renderTime = () => {  
    document.getElementById('current-time').textContent =  
        new Date().toLocaleString();  
  };  
  setInterval(renderTime, 1000);  
</script>  



// Initialize clock with a specific time, let the page load naturally.  
await page.clock.install({ time: new Date('2024-02-02T08:00:00') });  
await page.goto('http://localhost:3333');  
  
// Pause the time flow, stop the timers, you now have manual control  
// over the page time.  
await page.clock.pauseAt(new Date('2024-02-02T10:00:00'));  
await expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  
  
// Tick through time manually, firing all timers in the process.  
// In this case, time will be updated in the screen 2 times.  
await page.clock.runFor(2000);  
await expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:02 AM');","Tick through time manually, firing all the timers consistentlyâ€‹ | In rare cases, you may want to tick through time manually, firing all timers and animation frames in the process to achieve a fine-grained control over the passage of time.",https://playwright.dev/docs/clock,assertion
javascript,await page.pause();,Run a test from a specific breakpointâ€‹ | To speed up the debugging process you can add a [page.pause()](/docs/api/class-page#page-pause) method to your test. This way you won't have to step through each action of your test to get to the point where you want to debug.,https://playwright.dev/docs/debug,wait_strategy
javascript,await page.pause();,"This will also set the default timeouts of Playwright to 0 (= no timeout). | To debug your tests using the browser developer tools, start by setting a breakpoint in your test to pause the execution using the [page.pause()](/docs/api/class-page#page-pause) method.",https://playwright.dev/docs/debug,wait_strategy
javascript,"page.on('dialog', dialog => dialog.accept());  
await page.getByRole('button').click();","alert(), confirm(), prompt() dialogsâ€‹ | By default, dialogs are auto-dismissed by Playwright, so you don't have to handle them. However, you can register a dialog handler before the action that triggers the dialog to either [dialog.accept()](/docs/api/class-dialog#dialog-accept) or [dialog.dismiss()](/docs/api/class-dialog#dialog-dismiss) it.",https://playwright.dev/docs/dialogs,navigation
javascript,"page.on('dialog', dialog => console.log(dialog.message()));  
await page.getByRole('button').click(); // Will hang here",warning | WRONG!,https://playwright.dev/docs/dialogs,navigation
javascript,"page.on('dialog', async dialog => {  
  assert(dialog.type() === 'beforeunload');  
  await dialog.dismiss();  
});  
await page.close({ runBeforeUnload: true });","When [page.close()](/docs/api/class-page#page-close) is invoked with the truthy [runBeforeUnload](/docs/api/class-page#page-close-option-run-before-unload) value, the page runs its unload handlers. This is the only case when [page.close()](/docs/api/class-page#page-close) does not wait for the page to actually close, because it might be that the page stays open in the end of the operation. | You can register a dialog handler to handle the `beforeunload` dialog yourself:",https://playwright.dev/docs/dialogs,assertion
javascript,"await page.goto('<url>');  
  
await page.evaluate('(() => {window.waitForPrintDialog = new Promise(f => window.print = f);})()');  
await page.getByText('Print it!').click();  
  
await page.waitForFunction('window.waitForPrintDialog');","Print dialogsâ€‹ | In order to assert that a print dialog via [`window.print`](https://developer.mozilla.org/en-US/docs/Web/API/Window/print) was triggered, you can use the following snippet:",https://playwright.dev/docs/dialogs,navigation
javascript,"// Start waiting for download before clicking. Note no await.  
const downloadPromise = page.waitForEvent('download');  
await page.getByText('Download file').click();  
const download = await downloadPromise;  
  
// Wait for the download process to complete and save the downloaded file somewhere.  
await download.saveAs('/path/to/save/at/' + download.suggestedFilename());",Downloaded files are deleted when the browser context that produced them is closed. | Here is the simplest way to handle the file download:,https://playwright.dev/docs/downloads,navigation
javascript,"import { defineConfig, devices } from '@playwright/test'; // import devices  
  
export default defineConfig({  
  projects: [  
    {  
      name: 'chromium',  
      use: {  
        ...devices['Desktop Chrome'],  
      },  
    },  
    {  
      name: 'Mobile Safari',  
      use: {  
        ...devices['iPhone 13'],  
      },  
    },  
  ],  
});  



const { chromium, devices } = require('playwright');  
const browser = await chromium.launch();  
  
const iphone13 = devices['iPhone 13'];  
const context = await browser.newContext({  
  ...iphone13,  
});",playwright.config.ts,https://playwright.dev/docs/emulation,wait_strategy
javascript,"import { defineConfig, devices } from '@playwright/test';  
  
export default defineConfig({  
  projects: [  
    {  
      name: 'chromium',  
      use: {  
        ...devices['Desktop Chrome'],  
        // It is important to define the `viewport` property after destructuring `devices`,  
        // since devices also define the `viewport` for that device.  
        viewport: { width: 1280, height: 720 },  
      },  
    },  
  ]  
});  



// Create context with given viewport  
const context = await browser.newContext({  
  viewport: { width: 1280, height: 1024 }  
});",playwright.config.ts,https://playwright.dev/docs/emulation,wait_strategy
javascript,"import { test, expect } from '@playwright/test';  
  
test.use({  
  viewport: { width: 1600, height: 1200 },  
});  
  
test('my test', async ({ page }) => {  
  // ...  
});  



// Create context with given viewport  
const context = await browser.newContext({  
  viewport: { width: 1280, height: 1024 }  
});  
  
// Resize viewport for individual page  
await page.setViewportSize({ width: 1600, height: 1200 });  
  
// Emulate high-DPI  
const context = await browser.newContext({  
  viewport: { width: 2560, height: 1440 },  
  deviceScaleFactor: 2,  
});",tests/example.spec.ts,https://playwright.dev/docs/emulation,assertion
javascript,"import { test, expect } from '@playwright/test';  
  
test.describe('specific viewport block', () => {  
  test.use({ viewport: { width: 1600, height: 1200 } });  
  
  test('my test', async ({ page }) => {  
    // ...  
  });  
});  



// Create context with given viewport  
const context = await browser.newContext({  
  viewport: { width: 1600, height: 1200 }  
});  
const page = await context.newPage();",tests/example.spec.ts,https://playwright.dev/docs/emulation,assertion
javascript,"import { defineConfig, devices } from '@playwright/test';  
  
export default defineConfig({  
  projects: [  
    {  
      name: 'chromium',  
      use: {  
        ...devices['Desktop Chrome'],  
        // It is important to define the `isMobile` property after destructuring `devices`,  
        // since devices also define the `isMobile` for that device.  
        isMobile: false,  
      },  
    },  
  ]  
});",Whether the meta viewport tag is taken into account and touch events are enabled. | playwright.config.ts,https://playwright.dev/docs/emulation,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  use: {  
    // Emulates the user locale.  
    locale: 'en-GB',  
  
    // Emulates the user timezone.  
    timezoneId: 'Europe/Paris',  
  },  
});",Emulate the user Locale and Timezone which can be set globally for all tests in the config and then overridden for particular tests. | playwright.config.ts,https://playwright.dev/docs/emulation,general
javascript,"import { test, expect } from '@playwright/test';  
  
test.use({  
  locale: 'de-DE',  
  timezoneId: 'Europe/Berlin',  
});  
  
test('my test for de lang in Berlin timezone', async ({ page }) => {  
  await page.goto('https://www.bing.com');  
  // ...  
});  



const context = await browser.newContext({  
  locale: 'de-DE',  
  timezoneId: 'Europe/Berlin',  
});",tests/example.spec.ts,https://playwright.dev/docs/emulation,assertion
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  use: {  
    // Grants specified permissions to the browser context.  
    permissions: ['notifications'],  
  },  
});  



const context = await browser.newContext({  
  permissions: ['notifications'],  
});",playwright.config.ts,https://playwright.dev/docs/emulation,wait_strategy
javascript,"import { test } from '@playwright/test';  
  
test.beforeEach(async ({ context }) => {  
  // Runs before each test and signs in each page.  
  await context.grantPermissions(['notifications'], { origin: 'https://skype.com' });  
});  
  
test('first', async ({ page }) => {  
  // page has notifications permission for https://skype.com.  
});  



await context.grantPermissions(['notifications'], { origin: 'https://skype.com' });",tests/example.spec.ts,https://playwright.dev/docs/emulation,wait_strategy
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  use: {  
    // Context geolocation  
    geolocation: { longitude: 12.492507, latitude: 41.889938 },  
    permissions: ['geolocation'],  
  },  
});","Grant `""geolocation""` permissions and set geolocation to a specific area. | playwright.config.ts",https://playwright.dev/docs/emulation,general
javascript,"import { test, expect } from '@playwright/test';  
  
test.use({  
  geolocation: { longitude: 41.890221, latitude: 12.492348 },  
  permissions: ['geolocation'],  
});  
  
test('my test with geolocation', async ({ page }) => {  
  // ...  
});  



const context = await browser.newContext({  
  geolocation: { longitude: 41.890221, latitude: 12.492348 },  
  permissions: ['geolocation']  
});",tests/example.spec.ts,https://playwright.dev/docs/emulation,assertion
javascript,"import { test, expect } from '@playwright/test';  
  
test.use({  
  geolocation: { longitude: 41.890221, latitude: 12.492348 },  
  permissions: ['geolocation'],  
});  
  
test('my test with geolocation', async ({ page, context }) => {  
  // overwrite the location for this test  
  await context.setGeolocation({ longitude: 48.858455, latitude: 2.294474 });  
});  



await context.setGeolocation({ longitude: 48.858455, latitude: 2.294474 });",tests/example.spec.ts,https://playwright.dev/docs/emulation,assertion
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  use: {  
    colorScheme: 'dark',  
  },  
});","Emulate the users `""colorScheme""`. Supported values are 'light' and 'dark'. You can also emulate the media type with [page.emulateMedia()](/docs/api/class-page#page-emulate-media). | playwright.config.ts",https://playwright.dev/docs/emulation,general
javascript,"import { test, expect } from '@playwright/test';  
  
test.use({  
  colorScheme: 'dark' // or 'light'  
});  
  
test('my test with dark mode', async ({ page }) => {  
  // ...  
});  



// Create context with dark mode  
const context = await browser.newContext({  
  colorScheme: 'dark' // or 'light'  
});  
  
// Create page with dark mode  
const page = await browser.newPage({  
  colorScheme: 'dark' // or 'light'  
});  
  
// Change color scheme for the page  
await page.emulateMedia({ colorScheme: 'dark' });  
  
// Change media for page  
await page.emulateMedia({ media: 'print' });",tests/example.spec.ts,https://playwright.dev/docs/emulation,assertion
javascript,"import { test, expect } from '@playwright/test';  
  
test.use({ userAgent: 'My user agent' });  
  
test('my user agent test', async ({ page }) => {  
  // ...  
});  



const context = await browser.newContext({  
  userAgent: 'My user agent'  
});",tests/example.spec.ts,https://playwright.dev/docs/emulation,assertion
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  use: {  
    offline: true  
  },  
});",Emulate the network being offline. | playwright.config.ts,https://playwright.dev/docs/emulation,general
javascript,const href = await page.evaluate(() => document.location.href);,"Playwright scripts run in your Playwright environment. Your page scripts run in the browser page environment. Those environments don't intersect, they are running in different virtual machines in different processes and even potentially on different computers. | The [page.evaluate()](/docs/api/class-page#page-evaluate) API can run a JavaScript function in the context of the web page and bring results back to the Playwright environment. Browser globals like `window` and `document` can be used in `evaluate`.",https://playwright.dev/docs/evaluating,wait_strategy
javascript,"const status = await page.evaluate(async () => {  
  const response = await fetch(location.href);  
  return response.status;  
});",If the result is a Promise or if the function is asynchronous evaluate will automatically wait until it's resolved:,https://playwright.dev/docs/evaluating,wait_strategy
javascript,"const data = 'some data';  
const result = await page.evaluate(() => {  
  // WRONG: there is no ""data"" in the web page.  
  window.myApp.use(data);  
});","Evaluated scripts run in the browser environment, while your test runs in a testing environments. This means you cannot use variables from your test in the page and vice versa. Instead, you should pass them explicitly as an argument. | The following snippet is **WRONG** because it uses the variable directly:",https://playwright.dev/docs/evaluating,wait_strategy
javascript,"const data = 'some data';  
// Pass |data| as a parameter.  
const result = await page.evaluate(data => {  
  window.myApp.use(data);  
}, data);",The following snippet is **CORRECT** because it passes the value explicitly as an argument:,https://playwright.dev/docs/evaluating,wait_strategy
javascript,"// A primitive value.  
await page.evaluate(num => num, 42);  
  
// An array.  
await page.evaluate(array => array.length, [1, 2, 3]);  
  
// An object.  
await page.evaluate(object => object.foo, { foo: 'bar' });  
  
// A single handle.  
const button = await page.evaluateHandle('window.button');  
await page.evaluate(button => button.textContent, button);  
  
// Alternative notation using JSHandle.evaluate.  
await button.evaluate((button, from) => button.textContent.substring(from), 5);  
  
// Object with multiple handles.  
const button1 = await page.evaluateHandle('window.button1');  
const button2 = await page.evaluateHandle('window.button2');  
await page.evaluate(  
    o => o.button1.textContent + o.button2.textContent,  
    { button1, button2 });  
  
// Object destructuring works. Note that property names must match  
// between the destructured object and the argument.  
// Also note the required parenthesis.  
await page.evaluate(  
    ({ button1, button2 }) => button1.textContent + button2.textContent,  
    { button1, button2 });  
  
// Array works as well. Arbitrary names can be used for destructuring.  
// Note the required parenthesis.  
await page.evaluate(  
    ([b1, b2]) => b1.textContent + b2.textContent,  
    [button1, button2]);  
  
// Any mix of serializables and handles works.  
await page.evaluate(  
    x => x.button1.textContent + x.list[0].textContent + String(x.foo),  
    { button1, list: [button2], foo: null });","Evaluation Argumentâ€‹ | Playwright evaluation methods like [page.evaluate()](/docs/api/class-page#page-evaluate) take a single optional argument. This argument can be a mix of [Serializable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description ""Serializable"") values and [JSHandle](/docs/api/class-jshandle ""JSHandle"") instances. Handles are automatically converted to the value they represent.",https://playwright.dev/docs/evaluating,wait_strategy
javascript,"import { test, expect } from '@playwright/test';  
import path from 'path';  
  
test.beforeEach(async ({ page }) => {  
  // Add script for every test in the beforeEach hook.  
  // Make sure to correctly resolve the script path.  
  await page.addInitScript({ path: path.resolve(__dirname, '../mocks/preload.js') });  
});","Next, add init script to the page.",https://playwright.dev/docs/evaluating,assertion
javascript,"// Start waiting for request before goto. Note no await.  
const requestPromise = page.waitForRequest('**/*logo*.png');  
await page.goto('https://wikipedia.org');  
const request = await requestPromise;  
console.log(request.url());","Most of the time, scripts will need to wait for a particular event to happen. Below are some of the typical event awaiting patterns. | Wait for a request with the specified url using [page.waitForRequest()](/docs/api/class-page#page-wait-for-request):",https://playwright.dev/docs/events,navigation
javascript,"// Start waiting for popup before clicking. Note no await.  
const popupPromise = page.waitForEvent('popup');  
await page.getByText('open the popup').click();  
const popup = await popupPromise;  
await popup.goto('https://wikipedia.org');",Wait for popup window:,https://playwright.dev/docs/events,navigation
javascript,"page.on('request', request => console.log(`Request sent: ${request.url()}`));  
const listener = request => console.log(`Request finished: ${request.url()}`);  
page.on('requestfinished', listener);  
await page.goto('https://wikipedia.org');  
  
page.off('requestfinished', listener);  
await page.goto('https://www.openstreetmap.org/');","Adding/removing event listenerâ€‹ | Sometimes, events happen in random time and instead of waiting for them, they need to be handled. Playwright supports traditional language mechanisms for subscribing and unsubscribing from the events:",https://playwright.dev/docs/events,navigation
javascript,"import { test as base } from '@playwright/test';  
  
export { expect } from '@playwright/test';  
  
// Must be a function that evaluates to a selector engine instance.  
const createTagNameEngine = () => ({  
  // Returns the first element matching given selector in the root's subtree.  
  query(root, selector) {  
    return root.querySelector(selector);  
  },  
  
  // Returns all elements matching given selector in the root's subtree.  
  queryAll(root, selector) {  
    return Array.from(root.querySelectorAll(selector));  
  }  
});  
  
export const test = base.extend<{}, { selectorRegistration: void }>({  
  // Register selectors once per worker.  
  selectorRegistration: [async ({ playwright }, use) => {  
    // Register the engine. Selectors will be prefixed with ""tag="".  
    await playwright.selectors.register('tag', createTagNameEngine);  
    await use();  
  }, { scope: 'worker', auto: true }],  
});",An example of registering selector engine that queries elements based on a tag name: | baseTest.ts,https://playwright.dev/docs/extensibility,assertion
javascript,"// Locate element inside frame  
const username = await page.frameLocator('.frame-class').getByLabel('User Name');  
await username.fill('John');","A [Page](/docs/api/class-page ""Page"") can have one or more [Frame](/docs/api/class-frame ""Frame"") objects attached to it. Each page has a main frame and page-level interactions (like `click`) are assumed to operate in the main frame. | A page can have additional frames attached with the `iframe` HTML tag. These frames can be accessed for interactions inside the frame.",https://playwright.dev/docs/frames,form_interaction
javascript,"const jsHandle = await page.evaluateHandle('window');  
//  Use jsHandle for evaluations.","Here is the easiest way to obtain a [JSHandle](/docs/api/class-jshandle ""JSHandle"").",https://playwright.dev/docs/handles,wait_strategy
javascript,"// Get the element handle  
const elementHandle = page.waitForSelector('#box');  
  
// Assert bounding box for the element  
const boundingBox = await elementHandle.boundingBox();  
expect(boundingBox.width).toBe(100);  
  
// Assert attribute for the element  
const classNames = await elementHandle.getAttribute('class');  
expect(classNames.includes('highlighted')).toBeTruthy();","The use of [ElementHandle](/docs/api/class-elementhandle ""ElementHandle"") is discouraged, use [Locator](/docs/api/class-locator ""Locator"") objects and web-first assertions instead. | When [ElementHandle](/docs/api/class-elementhandle ""ElementHandle"") is required, it is recommended to fetch it with the [page.waitForSelector()](/docs/api/class-page#page-wait-for-selector) or [frame.waitForSelector()](/docs/api/class-frame#frame-wait-for-selector) methods. These APIs wait for the element to be attached and visible.",https://playwright.dev/docs/handles,assertion
javascript,"// Create new array in page.  
const myArrayHandle = await page.evaluateHandle(() => {  
  window.myArray = [1];  
  return myArray;  
});  
  
// Get the length of the array.  
const length = await page.evaluate(a => a.length, myArrayHandle);  
  
// Add one more element to the array using the handle  
await page.evaluate(arg => arg.myArray.push(arg.newElement), {  
  myArray: myArrayHandle,  
  newElement: 2  
});  
  
// Release the object when it's no longer needed.  
await myArrayHandle.dispose();","Handles as parametersâ€‹ | Handles can be passed into the [page.evaluate()](/docs/api/class-page#page-evaluate) and similar methods. The following snippet creates a new array in the page, initializes it with data and returns a handle to this array into Playwright. It then uses the handle in subsequent evaluations:",https://playwright.dev/docs/handles,wait_strategy
javascript,"const handle = await page.$('text=Submit');  
// ...  
await handle.hover();  
await handle.click();","The difference between the [Locator](/docs/api/class-locator ""Locator"") and [ElementHandle](/docs/api/class-elementhandle ""ElementHandle"") is that the latter points to a particular element, while Locator captures the logic of how to retrieve that element. | In the example below, handle points to a particular DOM element on page. If that element changes text or is used by React to render an entirely different component, handle is still pointing to that very stale DOM element. This can lead to unexpected behaviors.",https://playwright.dev/docs/handles,navigation
javascript,"// Text input  
await page.getByRole('textbox').fill('Peter');  
  
// Date input  
await page.getByLabel('Birth date').fill('2020-02-02');  
  
// Time input  
await page.getByLabel('Appointment time').fill('13:15');  
  
// Local datetime input  
await page.getByLabel('Local time').fill('2020-03-02T05:15');","Text inputâ€‹ | Using [locator.fill()](/docs/api/class-locator#locator-fill) is the easiest way to fill out the form fields. It focuses the element and triggers an `input` event with the entered text. It works for `<input>`, `<textarea>` and `[contenteditable]` elements.",https://playwright.dev/docs/input,form_interaction
javascript,"// Check the checkbox  
await page.getByLabel('I agree to the terms above').check();  
  
// Assert the checked state  
expect(page.getByLabel('Subscribe to newsletter')).toBeChecked();  
  
// Select the radio button  
await page.getByLabel('XL').check();","Checkboxes and radio buttonsâ€‹ | Using [locator.setChecked()](/docs/api/class-locator#locator-set-checked) is the easiest way to check and uncheck a checkbox or a radio button. This method can be used with `input[type=checkbox]`, `input[type=radio]` and `[role=checkbox]` elements.",https://playwright.dev/docs/input,assertion
javascript,"// Single selection matching the value or label  
await page.getByLabel('Choose a color').selectOption('blue');  
  
// Single selection matching the label  
await page.getByLabel('Choose a color').selectOption({ label: 'Blue' });  
  
// Multiple selected items  
await page.getByLabel('Choose multiple colors').selectOption(['red', 'green', 'blue']);","Select optionsâ€‹ | Selects one or multiple options in the `<select>` element with [locator.selectOption()](/docs/api/class-locator#locator-select-option). You can specify option `value`, or `label` to select. Multiple options can be selected.",https://playwright.dev/docs/input,form_interaction
javascript,"// Generic click  
await page.getByRole('button').click();  
  
// Double click  
await page.getByText('Item').dblclick();  
  
// Right click  
await page.getByText('Item').click({ button: 'right' });  
  
// Shift + click  
await page.getByText('Item').click({ modifiers: ['Shift'] });  
  
// Ctrl + click or Windows and Linux  
// Meta + click on macOS  
await page.getByText('Item').click({ modifiers: ['ControlOrMeta'] });  
  
// Hover over element  
await page.getByText('Item').hover();  
  
// Click the top left corner  
await page.getByText('Item').click({ position: { x: 0, y: 0 } });",Mouse clickâ€‹ | Performs a simple human click.,https://playwright.dev/docs/input,navigation
javascript,await page.getByRole('button').click({ force: true });,"Forcing the clickâ€‹ | Sometimes, apps use non-trivial logic where hovering the element overlays it with another element that intercepts the click. This behavior is indistinguishable from a bug where element gets covered and the click is dispatched elsewhere. If you know this is taking place, you can bypass the [actionability](/docs/actionability) checks and force the click:",https://playwright.dev/docs/input,navigation
javascript,await page.getByRole('button').dispatchEvent('click');,"Programmatic clickâ€‹ | If you are not interested in testing your app under the real conditions and want to simulate the click by any means possible, you can trigger the [`HTMLElement.click()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click) behavior via simply dispatching a click event on the element with [locator.dispatchEvent()](/docs/api/class-locator#locator-dispatch-event):",https://playwright.dev/docs/input,navigation
javascript,"// Press keys one by one  
await page.locator('#area').pressSequentially('Hello World!');","Most of the time, you should input text with [locator.fill()](/docs/api/class-locator#locator-fill). See the Text input section above. You only need to type characters if there is special keyboard handling on the page. | Type into the field character by character, as if it was a user with a real keyboard with [locator.pressSequentially()](/docs/api/class-locator#locator-press-sequentially).",https://playwright.dev/docs/input,wait_strategy
javascript,"// Hit Enter  
await page.getByText('Submit').press('Enter');  
  
// Dispatch Control+Right  
await page.getByRole('textbox').press('Control+ArrowRight');  
  
// Press $ sign on keyboard  
await page.getByRole('textbox').press('$');","This method will emit all the necessary keyboard events, with all the `keydown`, `keyup`, `keypress` events in place. You can even specify the optional `delay` between the key presses to simulate real user behavior. | Keys and shortcutsâ€‹",https://playwright.dev/docs/input,wait_strategy
javascript,"// <input id=name>  
await page.locator('#name').press('Shift+A');  
  
// <input id=name>  
await page.locator('#name').press('Shift+ArrowLeft');","Simple version produces a single character. This character is case-sensitive, so `""a""` and `""A""` will produce different results.",https://playwright.dev/docs/input,wait_strategy
javascript,"// Select one file  
await page.getByLabel('Upload file').setInputFiles(path.join(__dirname, 'myfile.pdf'));  
  
// Select multiple files  
await page.getByLabel('Upload files').setInputFiles([  
  path.join(__dirname, 'file1.txt'),  
  path.join(__dirname, 'file2.txt'),  
]);  
  
// Select a directory  
await page.getByLabel('Upload directory').setInputFiles(path.join(__dirname, 'mydir'));  
  
// Remove all the selected files  
await page.getByLabel('Upload file').setInputFiles([]);  
  
// Upload buffer from memory  
await page.getByLabel('Upload file').setInputFiles({  
  name: 'file.txt',  
  mimeType: 'text/plain',  
  buffer: Buffer.from('this is test')  
});","Upload filesâ€‹ | You can select input files for upload using the [locator.setInputFiles()](/docs/api/class-locator#locator-set-input-files) method. It expects first argument to point to an [input element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input) with the type `""file""`. Multiple files can be passed in the array. If some of the file paths are relative, they are resolved relative to the current working directory. Empty array clears the selected files.",https://playwright.dev/docs/input,form_interaction
javascript,"// Start waiting for file chooser before clicking. Note no await.  
const fileChooserPromise = page.waitForEvent('filechooser');  
await page.getByLabel('Upload file').click();  
const fileChooser = await fileChooserPromise;  
await fileChooser.setFiles(path.join(__dirname, 'myfile.pdf'));","If you don't have input element in hand (it is created dynamically), you can handle the [page.on('filechooser')](/docs/api/class-page#page-event-file-chooser) event or use a corresponding waiting method upon your action:",https://playwright.dev/docs/input,navigation
javascript,await page.getByLabel('Password').focus();,"Focus elementâ€‹ | For the dynamic pages that handle focus events, you can focus the given element with [locator.focus()](/docs/api/class-locator#locator-focus).",https://playwright.dev/docs/input,wait_strategy
javascript,await page.locator('#item-to-be-dragged').dragTo(page.locator('#item-to-drop-at'));,Release left mouse button.,https://playwright.dev/docs/input,wait_strategy
javascript,"await page.locator('#item-to-be-dragged').hover();  
await page.mouse.down();  
await page.locator('#item-to-drop-at').hover();  
await page.mouse.up();","Dragging manuallyâ€‹ | If you want precise control over the drag operation, use lower-level methods like [locator.hover()](/docs/api/class-locator#locator-hover), [mouse.down()](/docs/api/class-mouse#mouse-down), [mouse.move()](/docs/api/class-mouse#mouse-move) and [mouse.up()](/docs/api/class-mouse#mouse-up).",https://playwright.dev/docs/input,wait_strategy
javascript,"// Scrolls automatically so that button is visible  
await page.getByRole('button').click();","Scrollingâ€‹ | Most of the time, Playwright will automatically scroll for you before doing any actions. Therefore, you do not need to scroll explicitly.",https://playwright.dev/docs/input,navigation
javascript,"// Scroll the footer into view, forcing an ""infinite list"" to load more content  
await page.getByText('Footer text').scrollIntoViewIfNeeded();","However, in rare cases you might need to manually scroll. For example, you might want to force an ""infinite list"" to load more elements, or position the page for a specific screenshot. In such a case, the most reliable way is to find an element that you want to make visible at the bottom, and scroll it into view.",https://playwright.dev/docs/input,wait_strategy
javascript,"import { chromium, devices } from 'playwright';  
import assert from 'node:assert';  
  
(async () => {  
  // Setup  
  const browser = await chromium.launch();  
  const context = await browser.newContext(devices['iPhone 11']);  
  const page = await context.newPage();  
  
  // The actual interesting bit  
  await context.route('**.jpg', route => route.abort());  
  await page.goto('https://example.com/');  
  
  assert(await page.title() === 'Example Domain'); // ðŸ‘Ž not a Web First assertion  
  
  // Teardown  
  await context.close();  
  await browser.close();  
})();  



const assert = require('node:assert');  
const { chromium, devices } = require('playwright');  
  
(async () => {  
  // Setup  
  const browser = await chromium.launch();  
  const context = await browser.newContext(devices['iPhone 11']);  
  const page = await context.newPage();  
  
  // The actual interesting bit  
  await context.route('**.jpg', route => route.abort());  
  await page.goto('https://example.com/');  
  
  assert(await page.title() === 'Example Domain'); // ðŸ‘Ž not a Web First assertion  
  
  // Teardown  
  await context.close();  
  await browser.close();  
})();",JavaScript,https://playwright.dev/docs/library,assertion
javascript,"import { expect, test, devices } from '@playwright/test';  
  
test.use(devices['iPhone 11']);  
  
test('should be titled', async ({ page, context }) => {  
  await context.route('**.jpg', route => route.abort());  
  await page.goto('https://example.com/');  
  
  await expect(page).toHaveTitle('Example');  
});  



const { expect, test, devices } = require('@playwright/test');  
  
test.use(devices['iPhone 11']);  
  
test('should be titled', async ({ page, context }) => {  
  await context.route('**.jpg', route => route.abort());  
  await page.goto('https://example.com/');  
  
  await expect(page).toHaveTitle('Example');  
});",JavaScript,https://playwright.dev/docs/library,assertion
javascript,"const { chromium } = require('playwright');  
  
(async () => {  
  const browser = await chromium.launch();  
  // Create pages, interact with UI elements, assert values  
  await browser.close();  
})();","See [managing browsers](/docs/browsers#managing-browser-binaries) for more options. | Once installed, you can import Playwright in a Node.js script, and launch any of the 3 browsers (`chromium`, `firefox` and `webkit`).",https://playwright.dev/docs/library,assertion
javascript,"const { webkit } = require('playwright');  
  
(async () => {  
  const browser = await webkit.launch();  
  const page = await browser.newPage();  
  await page.goto('https://playwright.dev/');  
  await page.screenshot({ path: `example.png` });  
  await browser.close();  
})();","First scriptâ€‹ | In our first script, we will navigate to `https://playwright.dev/` and take a screenshot in WebKit.",https://playwright.dev/docs/library,navigation
javascript,"await page.getByLabel('User Name').fill('John');  
  
await page.getByLabel('Password').fill('secret-password');  
  
await page.getByRole('button', { name: 'Sign in' }).click();  
  
await expect(page.getByText('Welcome, John!')).toBeVisible();",page.getByTestId() to locate an element based on its `data-testid` attribute (other attributes can be configured).,https://playwright.dev/docs/locators,assertion
javascript,"await page.getByRole('button', { name: 'Sign in' }).click();","Locate the element by its role of `button` with name ""Sign in"".",https://playwright.dev/docs/locators,navigation
javascript,"const locator = page.getByRole('button', { name: 'Sign in' });  
  
await locator.hover();  
await locator.click();","Use the [code generator](/docs/codegen) to generate a locator, and then edit it as you'd like. | Every time a locator is used for an action, an up-to-date DOM element is located in the page. In the snippet below, the underlying DOM element will be located twice, once prior to every action. This means that if the DOM changes in between the calls due to re-render, the new element corresponding to the locator will be used.",https://playwright.dev/docs/locators,navigation
javascript,"const locator = page  
    .frameLocator('#my-frame')  
    .getByRole('button', { name: 'Sign in' });  
  
await locator.click();","Note that all methods that create a locator, such as [page.getByLabel()](/docs/api/class-page#page-get-by-label), are also available on the [Locator](/docs/api/class-locator ""Locator"") and [FrameLocator](/docs/api/class-framelocator ""FrameLocator"") classes, so you can chain them and iteratively narrow down your locator.",https://playwright.dev/docs/locators,navigation
javascript,"await expect(page.getByRole('heading', { name: 'Sign up' })).toBeVisible();  
  
await page.getByRole('checkbox', { name: 'Subscribe' }).check();  
  
await page.getByRole('button', { name: /submit/i }).click();",You can locate each element by its implicit role:,https://playwright.dev/docs/locators,assertion
javascript,await page.getByLabel('Password').fill('secret');,You can fill the input after locating it by the label text:,https://playwright.dev/docs/locators,form_interaction
javascript,"await page  
    .getByPlaceholder('name@example.com')  
    .fill('playwright@microsoft.com');",You can fill the input after locating it by the placeholder text:,https://playwright.dev/docs/locators,form_interaction
javascript,"await expect(page.getByText('Welcome, John')).toBeVisible();",You can locate the element by the text it contains:,https://playwright.dev/docs/locators,assertion
javascript,"await expect(page.getByText('Welcome, John', { exact: true })).toBeVisible();",Set an exact match:,https://playwright.dev/docs/locators,assertion
javascript,"await expect(page.getByText(/welcome, [A-Za-z]+$/i)).toBeVisible();",Match with a regular expression:,https://playwright.dev/docs/locators,assertion
javascript,await page.getByAltText('playwright logo').click();,You can click on the image after locating it by the text alternative:,https://playwright.dev/docs/locators,navigation
javascript,await expect(page.getByTitle('Issues count')).toHaveText('25 issues');,You can check the issues count after locating it by the title text:,https://playwright.dev/docs/locators,assertion
javascript,await page.getByTestId('directions').click();,You can locate the element by its test id:,https://playwright.dev/docs/locators,navigation
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  use: {  
    testIdAttribute: 'data-pw'  
  }  
});",Set the test id to use a custom data attribute for your tests. | playwright.config.ts,https://playwright.dev/docs/locators,general
javascript,await page.getByTestId('directions').click();,And then locate the element as you would normally do:,https://playwright.dev/docs/locators,navigation
javascript,"await page.locator('css=button').click();  
await page.locator('xpath=//button').click();  
  
await page.locator('button').click();  
await page.locator('//button').click();","Locate by CSS or XPathâ€‹ | If you absolutely must use CSS or XPath locators, you can use [page.locator()](/docs/api/class-page#page-locator) to create a locator that takes a selector describing how to find an element in the page. Playwright supports CSS and XPath selectors, and auto-detects them if you omit `css=` or `xpath=` prefix.",https://playwright.dev/docs/locators,navigation
javascript,"await page.locator(  
    '#tsf > div:nth-child(2) > div.A8SBwf > div.RNNXgb > div > div.a4bIc > input'  
).click();  
  
await page  
    .locator('//*[@id=""tsf""]/div[2]/div[1]/div[1]/div/div[2]/input')  
    .click();",XPath and CSS selectors can be tied to the DOM structure or implementation. These selectors can break when the DOM structure changes. Long CSS or XPath chains below are an example of a **bad practice** that leads to unstable tests:,https://playwright.dev/docs/locators,navigation
javascript,"await page.getByText('Details').click();  



<x-details role=button aria-expanded=true aria-controls=inner-details>  
  <div>Title</div>  
  #shadow-root  
    <div id=inner-details>Details</div>  
</x-details>",You can locate in the same way as if the shadow root was not present at all. | To click `<div>Details</div>`:,https://playwright.dev/docs/locators,navigation
javascript,"await page.locator('x-details', { hasText: 'Details' }).click();  



<x-details role=button aria-expanded=true aria-controls=inner-details>  
  <div>Title</div>  
  #shadow-root  
    <div id=inner-details>Details</div>  
</x-details>",To click `<x-details>`:,https://playwright.dev/docs/locators,navigation
javascript,await expect(page.locator('x-details')).toContainText('Details');,"To ensure that `<x-details>` contains the text ""Details"":",https://playwright.dev/docs/locators,assertion
javascript,"await page  
    .getByRole('listitem')  
    .filter({ hasText: 'Product 2' })  
    .getByRole('button', { name: 'Add to cart' })  
    .click();","Filter by textâ€‹ | Locators can be filtered by text with the [locator.filter()](/docs/api/class-locator#locator-filter) method. It will search for a particular string somewhere inside the element, possibly in a descendant element, case-insensitively. You can also pass a regular expression.",https://playwright.dev/docs/locators,navigation
javascript,"await page  
    .getByRole('listitem')  
    .filter({ hasText: /Product 2/ })  
    .getByRole('button', { name: 'Add to cart' })  
    .click();",Use a regular expression:,https://playwright.dev/docs/locators,navigation
javascript,"// 5 in-stock items  
await expect(page.getByRole('listitem').filter({ hasNotText: 'Out of stock' })).toHaveCount(5);","Filter by not having textâ€‹ | Alternatively, filter by **not having** text:",https://playwright.dev/docs/locators,assertion
javascript,"<ul>  
  <li>  
    <h3>Product 1</h3>  
    <button>Add to cart</button>  
  </li>  
  <li>  
    <h3>Product 2</h3>  
    <button>Add to cart</button>  
  </li>  
</ul>  



await page  
    .getByRole('listitem')  
    .filter({ has: page.getByRole('heading', { name: 'Product 2' }) })  
    .getByRole('button', { name: 'Add to cart' })  
    .click();",Add to cart,https://playwright.dev/docs/locators,navigation
javascript,"await expect(page  
    .getByRole('listitem')  
    .filter({ has: page.getByRole('heading', { name: 'Product 2' }) }))  
    .toHaveCount(1);",We can also assert the product card to make sure there is only one:,https://playwright.dev/docs/locators,assertion
javascript,"// âœ– WRONG  
await expect(page  
    .getByRole('listitem')  
    .filter({ has: page.getByRole('list').getByText('Product 2') }))  
    .toHaveCount(1);","The filtering locator **must be relative** to the original locator and is queried starting with the original locator match, not the document root. Therefore, the following will not work, because the filtering locator starts matching from the `<ul>` list element that is outside of the `<li>` list item matched by the original locator:",https://playwright.dev/docs/locators,assertion
javascript,"await expect(page  
    .getByRole('listitem')  
    .filter({ hasNot: page.getByText('Product 2') }))  
    .toHaveCount(1);",Filter by not having child/descendantâ€‹ | We can also filter by **not having** a matching element inside.,https://playwright.dev/docs/locators,assertion
javascript,"const product = page.getByRole('listitem').filter({ hasText: 'Product 2' });  
  
await product.getByRole('button', { name: 'Add to cart' }).click();  
  
await expect(product).toHaveCount(1);","You can chain methods that create a locator, like [page.getByText()](/docs/api/class-page#page-get-by-text) or [locator.getByRole()](/docs/api/class-locator#locator-get-by-role), to narrow down the search to a particular part of the page. | In this example we first create a locator called product by locating its role of `listitem`. We then filter by text. We can use the product locator again to get by role of button and click it and then use an assertion to make sure there is only one product with the text ""Product 2"".",https://playwright.dev/docs/locators,assertion
javascript,"const saveButton = page.getByRole('button', { name: 'Save' });  
// ...  
const dialog = page.getByTestId('settings-dialog');  
await dialog.locator(saveButton).click();","You can also chain two locators together, for example to find a ""Save"" button inside a particular dialog:",https://playwright.dev/docs/locators,navigation
javascript,const button = page.getByRole('button').and(page.getByTitle('Subscribe'));,"Matching two locators simultaneouslyâ€‹ | Method [locator.and()](/docs/api/class-locator#locator-and) narrows down an existing locator by matching an additional locator. For example, you can combine [page.getByRole()](/docs/api/class-page#page-get-by-role) and [page.getByTitle()](/docs/api/class-page#page-get-by-title) to match by both role and title.",https://playwright.dev/docs/locators,general
javascript,"const newEmail = page.getByRole('button', { name: 'New' });  
const dialog = page.getByText('Confirm security settings');  
await expect(newEmail.or(dialog).first()).toBeVisible();  
if (await dialog.isVisible())  
  await page.getByRole('button', { name: 'Dismiss' }).click();  
await newEmail.click();","note | If both ""New email"" button and security dialog appear on screen, the ""or"" locator will match both of them, possibly throwing the ""strict mode violation"" error. In this case, you can use [locator.first()](/docs/api/class-locator#locator-first) to only match one of them.",https://playwright.dev/docs/locators,assertion
javascript,await page.locator('button').click();,This will find both buttons and throw a [strictness](/docs/locators#strictness) violation error:,https://playwright.dev/docs/locators,navigation
javascript,await page.locator('button').locator('visible=true').click();,"This will only find a second button, because it is visible, and then click it.",https://playwright.dev/docs/locators,navigation
javascript,await expect(page.getByRole('listitem')).toHaveCount(3);,Use the count assertion to ensure that the list has 3 items.,https://playwright.dev/docs/locators,assertion
javascript,"await expect(page  
    .getByRole('listitem'))  
    .toHaveText(['apple', 'banana', 'orange']);","Use [expect(locator).toHaveText()](/docs/api/class-locatorassertions#locator-assertions-to-have-text) to ensure that the list has the text ""apple"", ""banana"" and ""orange"".",https://playwright.dev/docs/locators,assertion
javascript,await page.getByText('orange').click();,Locate an item by its text content and click it.,https://playwright.dev/docs/locators,navigation
javascript,"await page  
    .getByRole('listitem')  
    .filter({ hasText: 'orange' })  
    .click();","Locate an item by the role of ""listitem"" and then filter by the text of ""orange"" and then click it.",https://playwright.dev/docs/locators,navigation
javascript,await page.getByTestId('orange').click();,"Locate an item by its test id of ""orange"" and then click it.",https://playwright.dev/docs/locators,navigation
javascript,const banana = await page.getByRole('listitem').nth(1);,"Get by nth itemâ€‹ | If you have a list of identical elements, and the only way to distinguish between them is the order, you can choose a specific element from a list with [locator.first()](/docs/api/class-locator#locator-first), [locator.last()](/docs/api/class-locator#locator-last) or [locator.nth()](/docs/api/class-locator#locator-nth).",https://playwright.dev/docs/locators,wait_strategy
javascript,"const rowLocator = page.getByRole('listitem');  
  
await rowLocator  
    .filter({ hasText: 'Mary' })  
    .filter({ has: page.getByRole('button', { name: 'Say goodbye' }) })  
    .screenshot({ path: 'screenshot.png' });","To take a screenshot of the row with ""Mary"" and ""Say goodbye"":",https://playwright.dev/docs/locators,wait_strategy
javascript,"for (const row of await page.getByRole('listitem').all())  
  console.log(await row.textContent());",Do something with each element in the listâ€‹ | Iterate elements:,https://playwright.dev/docs/locators,wait_strategy
javascript,"const rows = page.getByRole('listitem');  
const count = await rows.count();  
for (let i = 0; i < count; ++i)  
  console.log(await rows.nth(i).textContent());",Iterate using regular for loop:,https://playwright.dev/docs/locators,wait_strategy
javascript,"const rows = page.getByRole('listitem');  
const texts = await rows.evaluateAll(  
    list => list.map(element => element.textContent));","Evaluate in the pageâ€‹ | The code inside [locator.evaluateAll()](/docs/api/class-locator#locator-evaluate-all) runs in the page, you can call any DOM apis there.",https://playwright.dev/docs/locators,wait_strategy
javascript,await page.getByRole('button').click();,"Locators are strict. This means that all operations on locators that imply some target DOM element will throw an exception if more than one element matches. For example, the following call throws if there are several buttons in the DOM: | Throws an error if more than oneâ€‹",https://playwright.dev/docs/locators,navigation
javascript,await page.getByRole('button').count();,"On the other hand, Playwright understands when you perform a multiple-element operation, so the following call works perfectly fine when the locator resolves to multiple elements. | Works fine with multiple elementsâ€‹",https://playwright.dev/docs/locators,wait_strategy
javascript,"await page.addInitScript(() => {  
  const mockBattery = {  
    level: 0.75,  
    charging: true,  
    chargingTime: 1800,  
    dischargingTime: Infinity,  
    addEventListener: () => { }  
  };  
  // Override the method to always return mock battery info.  
  window.navigator.getBattery = async () => mockBattery;  
});",Creating mocksâ€‹ | Since the page may be calling the API very early while loading it's important to setup all the mocks before the page started loading. The easiest way to achieve that is to call [page.addInitScript()](/docs/api/class-page#page-add-init-script):,https://playwright.dev/docs/mock-browser-apis,wait_strategy
javascript,"// Configure mock API before each test.  
test.beforeEach(async ({ page }) => {  
  await page.addInitScript(() => {  
    const mockBattery = {  
      level: 0.90,  
      charging: true,  
      chargingTime: 1800, // seconds  
      dischargingTime: Infinity,  
      addEventListener: () => { }  
    };  
    // Override the method to always return mock battery info.  
    window.navigator.getBattery = async () => mockBattery;  
  });  
});  
  
test('show battery status', async ({ page }) => {  
  await page.goto('/');  
  await expect(page.locator('.battery-percentage')).toHaveText('90%');  
  await expect(page.locator('.battery-status')).toHaveText('Adapter');  
  await expect(page.locator('.battery-fully')).toHaveText('00:30');  
});",Once this is done you can navigate the page and check its UI state:,https://playwright.dev/docs/mock-browser-apis,assertion
javascript,"await page.addInitScript(() => {  
  Object.defineProperty(Object.getPrototypeOf(navigator), 'cookieEnabled', { value: false });  
});","However, if the property is [configurable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#configurable), you can still override it using the plain JavaScript:",https://playwright.dev/docs/mock-browser-apis,form_interaction
javascript,"test('log battery calls', async ({ page }) => {  
  const log = [];  
  // Expose function for pushing messages to the Node.js script.  
  await page.exposeFunction('logCall', msg => log.push(msg));  
  await page.addInitScript(() => {  
    const mockBattery = {  
      level: 0.75,  
      charging: true,  
      chargingTime: 1800,  
      dischargingTime: Infinity,  
      // Log addEventListener calls.  
      addEventListener: (name, cb) => logCall(`addEventListener:${name}`)  
    };  
    // Override the method to always return mock battery info.  
    window.navigator.getBattery = async () => {  
      logCall('getBattery');  
      return mockBattery;  
    };  
  });  
  
  await page.goto('/');  
  await expect(page.locator('.battery-percentage')).toHaveText('75%');  
  
  // Compare actual calls with golden.  
  expect(log).toEqual([  
    'getBattery',  
    'addEventListener:chargingchange',  
    'addEventListener:levelchange'  
  ]);  
});",Verifying API callsâ€‹ | Sometimes it is useful to check if the page made all expected APIs calls. You can record all API method invocations and then compare them with golden result. [page.exposeFunction()](/docs/api/class-page#page-expose-function) may come in handy for passing message from the page back to the test code:,https://playwright.dev/docs/mock-browser-apis,assertion
javascript,"test(""mocks a fruit and doesn't call api"", async ({ page }) => {  
  // Mock the api call before navigating  
  await page.route('*/**/api/v1/fruits', async route => {  
    const json = [{ name: 'Strawberry', id: 21 }];  
    await route.fulfill({ json });  
  });  
  // Go to the page  
  await page.goto('https://demo.playwright.dev/api-mocking');  
  
  // Assert that the Strawberry fruit is visible  
  await expect(page.getByText('Strawberry')).toBeVisible();  
});",Mock API requestsâ€‹ | The following code will intercept all the calls to `*/**/api/v1/fruits` and will return a custom response instead. No requests to the API will be made. The test goes to the URL that uses the mocked route and asserts that mock data is present on the page.,https://playwright.dev/docs/mock,assertion
javascript,"test('gets the json from api and adds a new fruit', async ({ page }) => {  
  // Get the response and add to it  
  await page.route('*/**/api/v1/fruits', async route => {  
    const response = await route.fetch();  
    const json = await response.json();  
    json.push({ name: 'Loquat', id: 100 });  
    // Fulfill using the original response, while patching the response body  
    // with the given JSON object.  
    await route.fulfill({ response, json });  
  });  
  
  // Go to the page  
  await page.goto('https://demo.playwright.dev/api-mocking');  
  
  // Assert that the new fruit is visible  
  await expect(page.getByText('Loquat', { exact: true })).toBeVisible();  
});","Sometimes, it is essential to make an API request, but the response needs to be patched to allow for reproducible testing. In that case, instead of mocking the request, one can perform the request and fulfill it with the modified response. | In the example below we intercept the call to the fruit API and add a new fruit called 'Loquat', to the data. We then go to the url and assert that this data is there:",https://playwright.dev/docs/mock,assertion
javascript,"test('records or updates the HAR file', async ({ page }) => {  
  // Get the response from the HAR file  
  await page.routeFromHAR('./hars/fruit.har', {  
    url: '*/**/api/v1/fruits',  
    update: true,  
  });  
  
  // Go to the page  
  await page.goto('https://demo.playwright.dev/api-mocking');  
  
  // Assert that the fruit is visible  
  await expect(page.getByText('Strawberry')).toBeVisible();  
});","To record a HAR file we use [page.routeFromHAR()](/docs/api/class-page#page-route-from-har) or [browserContext.routeFromHAR()](/docs/api/class-browsercontext#browser-context-route-from-har) method. This method takes in the path to the HAR file and an optional object of options. The options object can contain the URL so that only requests with the URL matching the specified glob pattern will be served from the HAR File. If not specified, all requests will be served from the HAR file. | Setting `update` option to true will create or update the HAR file with the actual network information instead of serving the requests from the HAR file. Use it when creating a test to populate the HAR with real data.",https://playwright.dev/docs/mock,assertion
javascript,"test('gets the json from HAR and checks the new fruit has been added', async ({ page }) => {  
  // Replay API requests from HAR.  
  // Either use a matching response from the HAR,  
  // or abort the request if nothing matches.  
  await page.routeFromHAR('./hars/fruit.har', {  
    url: '*/**/api/v1/fruits',  
    update: false,  
  });  
  
  // Go to the page  
  await page.goto('https://demo.playwright.dev/api-mocking');  
  
  // Assert that the Playwright fruit is visible  
  await expect(page.getByText('Playwright', { exact: true })).toBeVisible();  
});","Replaying from HARâ€‹ | Now that you have the HAR file recorded and modified the mock data, it can be used to serve matching responses in the test. For this, just turn off or simply remove the `update` option. This will run the test against the HAR file instead of hitting the API.",https://playwright.dev/docs/mock,assertion
javascript,"await page.routeWebSocket('wss://example.com/ws', ws => {  
  ws.onMessage(message => {  
    if (message === 'request')  
      ws.send('response');  
  });  
});","Mock WebSocketsâ€‹ | The following code will intercept WebSocket connections and mock entire communcation over the WebSocket, instead of connecting to the server. This example responds to a `""request""` with a `""response""`.",https://playwright.dev/docs/mock,wait_strategy
javascript,"await page.routeWebSocket('wss://example.com/ws', ws => {  
  const server = ws.connectToServer();  
  ws.onMessage(message => {  
    if (message === 'request')  
      server.send('request2');  
    else  
      server.send(message);  
  });  
});","Alternatively, you may want to connect to the actual server, but intercept messages in-between and modify or block them. Here is an example that modifies some of the messages sent by the page to the server, and leaves the rest unmodified.",https://playwright.dev/docs/mock,wait_strategy
javascript,"// Navigate the page  
await page.goto('https://example.com');",Basic navigationâ€‹ | Simplest form of a navigation is opening a URL:,https://playwright.dev/docs/navigations,navigation
javascript,"// Navigate and click element  
// Click will auto-wait for the element  
await page.goto('https://example.com');  
await page.getByText('Example Domain').click();","Modern pages perform numerous activities after the `load` event was fired. They fetch data lazily, populate UI, load expensive resources, scripts and styles after the `load` event was fired. There is no way to tell that the page is `loaded`, it depends on the page, framework, etc. So when can you start interacting with it? | In Playwright you can interact with the page at any moment. It will automatically wait for the target elements to become [actionable](/docs/actionability).",https://playwright.dev/docs/navigations,navigation
javascript,"await page.getByText('Click me').click();  
await page.waitForURL('**/login');","Waiting for navigationâ€‹ | Clicking an element could trigger multiple navigations. In these cases, it is recommended to explicitly [page.waitForURL()](/docs/api/class-page#page-wait-for-url) to a specific url.",https://playwright.dev/docs/navigations,navigation
javascript,"import { test, expect } from '@playwright/test';  
  
test.beforeEach(async ({ context }) => {  
  // Block any css requests for each test in this file.  
  await context.route(/.css$/, route => route.abort());  
});  
  
test('loads page without css', async ({ page }) => {  
  await page.goto('https://playwright.dev');  
  // ... test goes here  
});","You don't have to configure anything to mock network requests. Just define a custom [Route](/docs/api/class-route ""Route"") that mocks network for a browser context. | example.spec.ts",https://playwright.dev/docs/network,assertion
javascript,"import { test, expect } from '@playwright/test';  
  
test('loads page without images', async ({ page }) => {  
  // Block png and jpeg images.  
  await page.route(/(png|jpeg)$/, route => route.abort());  
  
  await page.goto('https://playwright.dev');  
  // ... test goes here  
});","Alternatively, you can use [page.route()](/docs/api/class-page#page-route) to mock network in a single page. | example.spec.ts",https://playwright.dev/docs/network,assertion
javascript,"import { defineConfig } from '@playwright/test';  
export default defineConfig({  
  use: {  
    httpCredentials: {  
      username: 'bill',  
      password: 'pa55w0rd',  
    }  
  }  
});  



const context = await browser.newContext({  
  httpCredentials: {  
    username: 'bill',  
    password: 'pa55w0rd',  
  },  
});  
const page = await context.newPage();  
await page.goto('https://example.com');",playwright.config.ts,https://playwright.dev/docs/network,navigation
javascript,"import { defineConfig } from '@playwright/test';  
export default defineConfig({  
  use: {  
    proxy: {  
      server: 'http://myproxy.com:3128',  
      username: 'usr',  
      password: 'pwd'  
    }  
  }  
});  



const browser = await chromium.launch({  
  proxy: {  
    server: 'http://myproxy.com:3128',  
    username: 'usr',  
    password: 'pwd'  
  }  
});",playwright.config.ts,https://playwright.dev/docs/network,wait_strategy
javascript,"import { test, expect } from '@playwright/test';  
  
test('should use custom proxy on a new context', async ({ browser }) => {  
  const context = await browser.newContext({  
    proxy: {  
      server: 'http://myproxy.com:3128',  
    }  
  });  
  const page = await context.newPage();  
  
  await context.close();  
});  



const browser = await chromium.launch();  
const context = await browser.newContext({  
  proxy: { server: 'http://myproxy.com:3128' }  
});",example.spec.ts,https://playwright.dev/docs/network,assertion
javascript,"// Subscribe to 'request' and 'response' events.  
page.on('request', request => console.log('>>', request.method(), request.url()));  
page.on('response', response => console.log('<<', response.status(), response.url()));  
  
await page.goto('https://example.com');","Network eventsâ€‹ | You can monitor all the [Request](/docs/api/class-request ""Request"")s and [Response](/docs/api/class-response ""Response"")s:",https://playwright.dev/docs/network,navigation
javascript,"// Use a glob URL pattern. Note no await.  
const responsePromise = page.waitForResponse('**/api/fetch_data');  
await page.getByText('Update').click();  
const response = await responsePromise;",Or wait for a network response after the button click with [page.waitForResponse()](/docs/api/class-page#page-wait-for-response):,https://playwright.dev/docs/network,navigation
javascript,"// Use a RegExp. Note no await.  
const responsePromise = page.waitForResponse(/\.jpeg$/);  
await page.getByText('Update').click();  
const response = await responsePromise;  
  
// Use a predicate taking a Response object. Note no await.  
const responsePromise = page.waitForResponse(response => response.url().includes(token));  
await page.getByText('Update').click();  
const response = await responsePromise;","Variationsâ€‹ | Wait for [Response](/docs/api/class-response ""Response"")s with [page.waitForResponse()](/docs/api/class-page#page-wait-for-response)",https://playwright.dev/docs/network,navigation
javascript,"await page.route('**/api/fetch_data', route => route.fulfill({  
  status: 200,  
  body: testData,  
}));  
await page.goto('https://example.com');",Handle requestsâ€‹,https://playwright.dev/docs/network,navigation
javascript,"await browserContext.route('**/api/login', route => route.fulfill({  
  status: 200,  
  body: 'accept',  
}));  
await page.goto('https://example.com');",Variationsâ€‹ | Set up route on the entire browser context with [browserContext.route()](/docs/api/class-browsercontext#browser-context-route) or page with [page.route()](/docs/api/class-page#page-route). It will apply to popup windows and opened links.,https://playwright.dev/docs/network,navigation
javascript,"// Delete header  
await page.route('**/*', async route => {  
  const headers = route.request().headers();  
  delete headers['X-Secret'];  
  await route.continue({ headers });  
});  
  
// Continue requests as POST.  
await page.route('**/*', route => route.continue({ method: 'POST' }));",Modify requestsâ€‹,https://playwright.dev/docs/network,wait_strategy
javascript,"await page.route('**/*.{png,jpg,jpeg}', route => route.abort());  
  
// Abort based on the request type  
await page.route('**/*', route => {  
  return route.request().resourceType() === 'image' ? route.abort() : route.continue();  
});",Abort requestsâ€‹ | You can abort requests using [page.route()](/docs/api/class-page#page-route) and [route.abort()](/docs/api/class-route#route-abort).,https://playwright.dev/docs/network,form_interaction
javascript,"await page.route('**/title.html', async route => {  
  // Fetch original response.  
  const response = await route.fetch();  
  // Add a prefix to the title.  
  let body = await response.text();  
  body = body.replace('<title>', '<title>My prefix:');  
  await route.fulfill({  
    // Pass all fields from the response.  
    response,  
    // Override response body.  
    body,  
    // Force content type to be html.  
    headers: {  
      ...response.headers(),  
      'content-type': 'text/html'  
    }  
  });  
});","Modify responsesâ€‹ | To modify a response use [APIRequestContext](/docs/api/class-apirequestcontext ""APIRequestContext"") to get the original response and then pass the response to [route.fulfill()](/docs/api/class-route#route-fulfill). You can override individual fields on the response via options:",https://playwright.dev/docs/network,form_interaction
javascript,await page.locator('css=button').click();,We recommend prioritizing [user-visible locators](/docs/locators#quick-guide) like text or accessible role instead of using CSS that is tied to the implementation and could break when the page changes. | Playwright can locate an element by CSS selector.,https://playwright.dev/docs/other-locators,navigation
javascript,"// Wrong, will match many elements including <body>  
await page.locator(':has-text(""Playwright"")').click();  
// Correct, only matches the <article> element  
await page.locator('article:has-text(""Playwright"")').click();","For example, `article:has-text(""Playwright"")` matches `<article><div>Playwright</div></article>`. | Note that `:has-text()` should be used together with other CSS specifiers, otherwise it will match all the elements containing specified text, including the `<body>`.",https://playwright.dev/docs/other-locators,navigation
javascript,"await page.locator('#nav-bar :text(""Home"")').click();","`#nav-bar :text(""Home"")` \- the `:text()` pseudo-class matches the smallest element containing specified text. Matching is case-insensitive, trims whitespace and searches for a substring. | For example, this will find an element with text ""Home"" somewhere inside the `#nav-bar` element:",https://playwright.dev/docs/other-locators,navigation
javascript,await page.locator('button').click();,This will find both buttons and throw a [strictness](/docs/locators#strictness) violation error:,https://playwright.dev/docs/other-locators,navigation
javascript,await page.locator('button:visible').click();,"This will only find a second button, because it is visible, and then click it.",https://playwright.dev/docs/other-locators,navigation
javascript,await page.locator('article:has(div.promo)').textContent();,The `:has()` pseudo-class is an [experimental CSS pseudo-class](https://developer.mozilla.org/en-US/docs/Web/CSS/:has). It returns an element if any of the selectors passed as parameters relative to the `:scope` of the given element match at least one element. | Following snippet returns text content of an `<article>` element that has a `<div class=promo>` inside.,https://playwright.dev/docs/other-locators,wait_strategy
javascript,"// Clicks a <button> that has either a ""Log in"" or ""Sign in"" text.  
await page.locator('button:has-text(""Log in""), button:has-text(""Sign in"")').click();",CSS: elements matching one of the conditionsâ€‹ | Comma-separated list of CSS selectors will match all elements that can be selected by one of the selectors in that list.,https://playwright.dev/docs/other-locators,navigation
javascript,"// Fill an input to the right of ""Username"".  
await page.locator('input:right-of(:text(""Username""))').fill('value');  
  
// Click a button near the promo card.  
await page.locator('button:near(.promo-card)').click();  
  
// Click the radio input in the list closest to the ""Label 3"".  
await page.locator('[type=radio]:left-of(:text(""Label 3""))').first().click();","Note that resulting matches are sorted by their distance to the anchor element, so you can use [locator.first()](/docs/api/class-locator#locator-first) to pick the closest one. This is only useful if you have something like a list of similar elements, where the closest is obviously the right one. However, using [locator.first()](/docs/api/class-locator#locator-first) in other cases most likely won't work as expected - it will not target the element you are searching for, but some other element that happens to be the closest like a random empty `<div>`, or an element that is scrolled out and is not currently visible.",https://playwright.dev/docs/other-locators,navigation
javascript,"// Click the third ""Buy"" button  
await page.locator(':nth-match(:text(""Buy""), 3)').click();","In this case, `:nth-match(:text(""Buy""), 3)` will select the third button from the snippet above. Note that index is one-based.",https://playwright.dev/docs/other-locators,navigation
javascript,"// Wait until all three buttons are visible  
await page.locator(':nth-match(:text(""Buy""), 3)').waitFor();","`:nth-match()` is also useful to wait until a specified number of elements appear, using [locator.waitFor()](/docs/api/class-locator#locator-wait-for).",https://playwright.dev/docs/other-locators,wait_strategy
javascript,"// Click first button  
await page.locator('button').locator('nth=0').click();  
  
// Click last button  
await page.locator('button').locator('nth=-1').click();",N-th element locatorâ€‹ | You can narrow down query to the n-th match using the `nth=` locator passing a zero-based index.,https://playwright.dev/docs/other-locators,navigation
javascript,"const child = page.getByText('Hello');  
const parent = page.getByRole('listitem').filter({ has: child });","If you'd like to target the parent `<li>` of a label with text `""Hello""`, using [locator.filter()](/docs/api/class-locator#locator-filter) works best:",https://playwright.dev/docs/other-locators,general
javascript,const parent = page.getByText('Hello').locator('xpath=..');,"Alternatively, if you cannot find a suitable locator for the parent element, use `xpath=..`. Note that this method is not as reliable, because any changes to the DOM structure will break your tests. Prefer [locator.filter()](/docs/api/class-locator#locator-filter) when possible.",https://playwright.dev/docs/other-locators,general
javascript,await page.locator('_react=BookItem').click();,"React locator allows finding elements by their component name and property values. The syntax is very similar to [CSS attribute selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors) and supports all CSS attribute selector operators. | In React locator, component names are transcribed with **CamelCase**.",https://playwright.dev/docs/other-locators,navigation
javascript,await page.locator('_vue=book-item').click();,"Vue locator allows finding elements by their component name and property values. The syntax is very similar to [CSS attribute selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors) and supports all CSS attribute selector operators. | In Vue locator, component names are transcribed with **kebab-case**.",https://playwright.dev/docs/other-locators,navigation
javascript,await page.locator('xpath=//button').click();,We recommend prioritizing [user-visible locators](/docs/locators#quick-guide) like text or accessible role instead of using XPath that is tied to the implementation and easily break when the page changes. | XPath locators are equivalent to calling [`Document.evaluate`](https://developer.mozilla.org/en/docs/Web/API/Document/evaluate).,https://playwright.dev/docs/other-locators,navigation
javascript,"// Waits for either confirmation dialog or load spinner.  
await page.locator(  
    `//span[contains(@class, 'spinner__loading')]|//div[@id='confirmation']`  
).waitFor();",XPath unionâ€‹ | Pipe operator (`|`) can be used to specify multiple selectors in XPath. It will match all elements that can be selected by one of the selectors in that list.,https://playwright.dev/docs/other-locators,wait_strategy
javascript,"// Fill the input by targeting the label.  
await page.getByText('Password').fill('secret');",[locator.selectOption()](/docs/api/class-locator#locator-select-option) will select an option from the select box.,https://playwright.dev/docs/other-locators,form_interaction
javascript,"// Fill the input by targeting the label.  
await expect(page.locator('label')).toHaveText('Password');","However, other methods will target the label itself, for example [expect(locator).toHaveText()](/docs/api/class-locatorassertions#locator-assertions-to-have-text) will assert the text content of the label, not the input field.",https://playwright.dev/docs/other-locators,assertion
javascript,await page.locator('text=Log in').click();,We recommend the modern [text locator](/docs/locators#get-by-text) instead. | Legacy text locator matches elements that contain passed text.,https://playwright.dev/docs/other-locators,navigation
javascript,await page.locator('text=Log in').click();,"Legacy text locator has a few variations: | `text=Log in` \- default matching is case-insensitive, trims whitespace and searches for a substring. For example, `text=Log` matches `<button>Log in</button>`.",https://playwright.dev/docs/other-locators,navigation
javascript,"await page.locator('text=""Log in""').click();","For example, `text=""Log""` does not match `<button>Log in</button>` because `<button>` contains a single text node `""Log in""` that is not equal to `""Log""`. However, `text=""Log""` matches `<button> Log <span>in</span></button>`, because `<button>` contains a text node `"" Log ""`. This exact mode implies case-sensitive matching, so `text=""Download""` will not match `<button>download</button>`. | Quoted body follows the usual escaping rules, e.g. use `\""` to escape double quote in a double-quoted string: `text=""foo\""bar""`.",https://playwright.dev/docs/other-locators,navigation
javascript,await page.locator('text=/Log\\s*in/i').click();,"`/Log\s*in/i` \- body can be a [JavaScript-like regex](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp) wrapped in `/` symbols. For example, `text=/Log\s*in/i` matches `<button>Login</button>` and `<button>log IN</button>`.",https://playwright.dev/docs/other-locators,navigation
javascript,"// Fill an input with the id ""username""  
await page.locator('id=username').fill('value');  
  
// Click an element with data-test-id ""submit""  
await page.locator('data-test-id=submit').click();",`data-test`,https://playwright.dev/docs/other-locators,navigation
javascript,"// Create a page.  
const page = await context.newPage();  
  
// Navigate explicitly, similar to entering a URL in the browser.  
await page.goto('http://example.com');  
// Fill an input.  
await page.locator('#search').fill('query');  
  
// Navigate implicitly by clicking a link.  
await page.locator('#submit').click();  
// Expect a new url.  
console.log(page.url());","Pagesâ€‹ | Each [BrowserContext](/docs/api/class-browsercontext ""BrowserContext"") can have multiple pages. A [Page](/docs/api/class-page ""Page"") refers to a single tab or a popup window within a browser context. It should be used to navigate to URLs and interact with the page content.",https://playwright.dev/docs/pages,assertion
javascript,"// Start waiting for new page before clicking. Note no await.  
const pagePromise = context.waitForEvent('page');  
await page.getByText('open new tab').click();  
const newPage = await pagePromise;  
// Interact with the new page normally.  
await newPage.getByRole('button').click();  
console.log(await newPage.title());","Handling new pagesâ€‹ | The `page` event on browser contexts can be used to get new pages that are created in the context. This can be used to handle new pages opened by `target=""_blank""` links.",https://playwright.dev/docs/pages,navigation
javascript,"// Get all new pages (including popups) in the context  
context.on('page', async page => {  
  await page.waitForLoadState();  
  console.log(await page.title());  
});","If the action that triggers the new page is unknown, the following pattern can be used.",https://playwright.dev/docs/pages,wait_strategy
javascript,"// Start waiting for popup before clicking. Note no await.  
const popupPromise = page.waitForEvent('popup');  
await page.getByText('open the popup').click();  
const popup = await popupPromise;  
// Interact with the new popup normally.  
await popup.getByRole('button').click();  
console.log(await popup.title());","If the page opens a pop-up (e.g. pages opened by `target=""_blank""` links), you can get a reference to it by listening to the `popup` event on the page. | This event is emitted in addition to the `browserContext.on('page')` event, but only for popups relevant to this page.",https://playwright.dev/docs/pages,navigation
javascript,"import { expect, type Locator, type Page } from '@playwright/test';  
  
export class PlaywrightDevPage {  
  readonly page: Page;  
  readonly getStartedLink: Locator;  
  readonly gettingStartedHeader: Locator;  
  readonly pomLink: Locator;  
  readonly tocList: Locator;  
  
  constructor(page: Page) {  
    this.page = page;  
    this.getStartedLink = page.locator('a', { hasText: 'Get started' });  
    this.gettingStartedHeader = page.locator('h1', { hasText: 'Installation' });  
    this.pomLink = page.locator('li', {  
      hasText: 'Guides',  
    }).locator('a', {  
      hasText: 'Page Object Model',  
    });  
    this.tocList = page.locator('article div.markdown ul > li > a');  
  }  
  
  async goto() {  
    await this.page.goto('https://playwright.dev');  
  }  
  
  async getStarted() {  
    await this.getStartedLink.first().click();  
    await expect(this.gettingStartedHeader).toBeVisible();  
  }  
  
  async pageObjectModel() {  
    await this.getStarted();  
    await this.pomLink.click();  
  }  
}",playwright-dev-page.ts,https://playwright.dev/docs/pom,page_object
javascript,"const { expect } = require('@playwright/test');  
  
exports.PlaywrightDevPage = class PlaywrightDevPage {  
  
  /**  
   * @param {import('@playwright/test').Page} page  
   */  
  constructor(page) {  
    this.page = page;  
    this.getStartedLink = page.locator('a', { hasText: 'Get started' });  
    this.gettingStartedHeader = page.locator('h1', { hasText: 'Installation' });  
    this.pomLink = page.locator('li', {  
      hasText: 'Guides',  
    }).locator('a', {  
      hasText: 'Page Object Model',  
    });  
    this.tocList = page.locator('article div.markdown ul > li > a');  
  }  
  
  async goto() {  
    await this.page.goto('https://playwright.dev');  
  }  
  
  async getStarted() {  
    await this.getStartedLink.first().click();  
    await expect(this.gettingStartedHeader).toBeVisible();  
  }  
  
  async pageObjectModel() {  
    await this.getStarted();  
    await this.pomLink.click();  
  }  
};",playwright-dev-page.js,https://playwright.dev/docs/pom,page_object
javascript,"class PlaywrightDevPage {  
  /**  
   * @param {import('playwright').Page} page  
   */  
  constructor(page) {  
    this.page = page;  
    this.getStartedLink = page.locator('a', { hasText: 'Get started' });  
    this.gettingStartedHeader = page.locator('h1', { hasText: 'Installation' });  
    this.pomLink = page.locator('li', {  
      hasText: 'Playwright Test',  
    }).locator('a', {  
      hasText: 'Page Object Model',  
    });  
    this.tocList = page.locator('article div.markdown ul > li > a');  
  }  
  async getStarted() {  
    await this.getStartedLink.first().click();  
    await expect(this.gettingStartedHeader).toBeVisible();  
  }  
  
  async pageObjectModel() {  
    await this.getStarted();  
    await this.pomLink.click();  
  }  
}  
module.exports = { PlaywrightDevPage };",models/PlaywrightDevPage.js,https://playwright.dev/docs/pom,page_object
javascript,"import { test, expect } from '@playwright/test';  
import { PlaywrightDevPage } from './playwright-dev-page';  
  
test('getting started should contain table of contents', async ({ page }) => {  
  const playwrightDev = new PlaywrightDevPage(page);  
  await playwrightDev.goto();  
  await playwrightDev.getStarted();  
  await expect(playwrightDev.tocList).toHaveText([  
    `How to install Playwright`,  
    `What's Installed`,  
    `How to run the example test`,  
    `How to open the HTML test report`,  
    `Write tests using web first assertions, page fixtures and locators`,  
    `Run single test, multiple tests, headed mode`,  
    `Generate tests with Codegen`,  
    `See a trace of your tests`  
  ]);  
});  
  
test('should show Page Object Model article', async ({ page }) => {  
  const playwrightDev = new PlaywrightDevPage(page);  
  await playwrightDev.goto();  
  await playwrightDev.pageObjectModel();  
  await expect(page.locator('article')).toContainText('Page Object Model is a common pattern');  
});",example.spec.ts,https://playwright.dev/docs/pom,fixture
javascript,"const { test, expect } = require('@playwright/test');  
const { PlaywrightDevPage } = require('./playwright-dev-page');  
  
test('getting started should contain table of contents', async ({ page }) => {  
  const playwrightDev = new PlaywrightDevPage(page);  
  await playwrightDev.goto();  
  await playwrightDev.getStarted();  
  await expect(playwrightDev.tocList).toHaveText([  
    `How to install Playwright`,  
    `What's Installed`,  
    `How to run the example test`,  
    `How to open the HTML test report`,  
    `Write tests using web first assertions, page fixtures and locators`,  
    `Run single test, multiple tests, headed mode`,  
    `Generate tests with Codegen`,  
    `See a trace of your tests`  
  ]);  
});  
  
test('should show Page Object Model article', async ({ page }) => {  
  const playwrightDev = new PlaywrightDevPage(page);  
  await playwrightDev.goto();  
  await playwrightDev.pageObjectModel();  
  await expect(page.locator('article')).toContainText('Page Object Model is a common pattern');  
});",example.spec.js,https://playwright.dev/docs/pom,fixture
javascript,"await page.goto('https://playwright.dev');  
await expect(page.locator('body')).toMatchAriaSnapshot(`  
  - banner:  
    - heading /Playwright enables reliable/ [level=1]  
    - link ""Get started""  
    - link ""Star microsoft/playwright on GitHub""  
  - main:  
    - img ""Browsers (Chromium, Firefox, WebKit)""  
    - heading ""Any browser â€¢ Any platform â€¢ One API""  
`);","Aria snapshotsâ€‹ | New assertion [expect(locator).toMatchAriaSnapshot()](/docs/api/class-locatorassertions#locator-assertions-to-match-aria-snapshot) verifies page structure by comparing to an expected accessibility tree, represented as YAML.",https://playwright.dev/docs/release-notes,assertion
javascript,"import { defineConfig, devices } from '@playwright/test';  
  
export default defineConfig({  
  projects: [  
    {  
      name: 'chromium',  
      use: { ...devices['Desktop Chrome'], channel: 'chromium' },  
    },  
  ],  
});","> New Headless on the other hand is the real Chrome browser, and is thus more authentic, reliable, and offers more features. This makes it more suitable for high-accuracy end-to-end web app testing or browser extension testing. | See [issue #33566](https://github.com/microsoft/playwright/issues/33566) for the list of possible breakages you could encounter and more details on Chromium headless. Please file an issue if you see any problems after opting in.",https://playwright.dev/docs/release-notes,general
javascript,"await page.routeWebSocket('/ws', ws => {  
  ws.onMessage(message => {  
    if (message === 'request')  
      ws.send('response');  
  });  
});","WebSocket routingâ€‹ | New methods [page.routeWebSocket()](/docs/api/class-page#page-route-web-socket) and [browserContext.routeWebSocket()](/docs/api/class-browsercontext#browser-context-route-web-socket) allow to intercept, modify and mock WebSocket connections initiated in the page. Below is a simple example that mocks WebSocket communication by responding to a `""request""` with a `""response""`.",https://playwright.dev/docs/release-notes,wait_strategy
javascript,"test('query params', async ({ request }) => {  
  const searchParams = new URLSearchParams();  
  searchParams.set('userId', 1);  
  const response = await request.get(  
      'https://jsonplaceholder.typicode.com/posts',  
      {  
        params: searchParams // or as a string: 'userId=1'  
      }  
  );  
  // ...  
});","[APIRequestContext](/docs/api/class-apirequestcontext ""APIRequestContext"") now accepts [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) and `string` as query parametersâ€‹ | You can now pass [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) and `string` as query parameters to [APIRequestContext](/docs/api/class-apirequestcontext ""APIRequestContext""):",https://playwright.dev/docs/release-notes,wait_strategy
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  // ...  
  use: {  
    clientCertificates: [{  
      origin: 'https://example.com',  
      certPath: './cert.pem',  
      keyPath: './key.pem',  
      passphrase: 'mysecretpassword',  
    }],  
  },  
  // ...  
});","Playwright now allows you to supply client-side certificates, so that server can verify them, as specified by TLS Client Authentication. | The following snippet sets up a client certificate for `https://example.com`:",https://playwright.dev/docs/release-notes,general
javascript,"import { handlers } from '@src/mocks/handlers';  
  
test.beforeEach(async ({ router }) => {  
  // install common handlers before each test  
  await router.use(...handlers);  
});  
  
test('example test', async ({ mount }) => {  
  // test as usual, your handlers are active  
  // ...  
});",Here is an example of reusing your existing MSW handlers in the test.,https://playwright.dev/docs/release-notes,wait_strategy
javascript,"// Initialize clock and let the page load naturally.  
await page.clock.install({ time: new Date('2024-02-02T08:00:00') });  
await page.goto('http://localhost:3333');  
  
// Pretend that the user closed the laptop lid and opened it again at 10am,  
// Pause the time once reached that point.  
await page.clock.pauseAt(new Date('2024-02-02T10:00:00'));  
  
// Assert the page state.  
await expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  
  
// Close the laptop lid again and open it at 10:30am.  
await page.clock.fastForward('30:00');  
await expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:30:00 AM');",ticking through time manually.,https://playwright.dev/docs/release-notes,assertion
javascript,"import { expect as baseExpect } from '@playwright/test';  
  
export const expect = baseExpect.extend({  
  async toHaveAmount(locator: Locator, expected: number, options?: { timeout?: number }) {  
    // When no timeout option is specified, use the config timeout.  
    const timeout = options?.timeout ?? this.timeout;  
    // ... implement the assertion ...  
  },  
});",New options [testConfig.respectGitIgnore](/docs/api/class-testconfig#test-config-respect-git-ignore) and [testProject.respectGitIgnore](/docs/api/class-testproject#test-project-respect-git-ignore) control whether files matching `.gitignore` patterns are excluded when searching for tests. | New property `timeout` is now available for custom expect matchers. This property takes into account `playwright.config.ts` and `expect.configure()`.,https://playwright.dev/docs/release-notes,assertion
javascript,"await page.getByLabel('Upload directory').setInputFiles(path.join(__dirname, 'mydir'));",Miscellaneousâ€‹ | Method [locator.setInputFiles()](/docs/api/class-locator#locator-set-input-files) now supports uploading a directory for `<input type=file webkitdirectory>` elements.,https://playwright.dev/docs/release-notes,wait_strategy
javascript,"// Press the common keyboard shortcut Control+S or Meta+S to trigger a ""Save"" operation.  
await page.keyboard.press('ControlOrMeta+S');",Multiple methods like [locator.click()](/docs/api/class-locator#locator-click) or [locator.press()](/docs/api/class-locator#locator-press) now support a `ControlOrMeta` modifier key. This key maps to `Meta` on macOS and maps to `Control` on Windows and Linux.,https://playwright.dev/docs/release-notes,wait_strategy
javascript,"const locator = page.getByRole('button');  
await expect(locator).toHaveAccessibleName('Submit');",**Accessibility assertions** | [expect(locator).toHaveAccessibleName()](/docs/api/class-locatorassertions#locator-assertions-to-have-accessible-name) checks if the element has the specified accessible name:,https://playwright.dev/docs/release-notes,assertion
javascript,"const locator = page.getByRole('button');  
await expect(locator).toHaveAccessibleDescription('Upload a photo');",[expect(locator).toHaveAccessibleDescription()](/docs/api/class-locatorassertions#locator-assertions-to-have-accessible-description) checks if the element has the specified accessible description:,https://playwright.dev/docs/release-notes,assertion
javascript,"const locator = page.getByTestId('save-button');  
await expect(locator).toHaveRole('button');",[expect(locator).toHaveRole()](/docs/api/class-locatorassertions#locator-assertions-to-have-role) checks if the element has the specified ARIA role:,https://playwright.dev/docs/release-notes,assertion
javascript,"const locator = page.getByText('This interstitial covers the button');  
await page.addLocatorHandler(locator, async overlay => {  
  await overlay.locator('#close').click();  
}, { times: 3, noWaitAfter: true });  
// Run your tests that can be interrupted by the overlay.  
// ...  
await page.removeLocatorHandler(locator);",New [page.removeLocatorHandler()](/docs/api/class-page#page-remove-locator-handler) method for removing previously added locator handlers.,https://playwright.dev/docs/release-notes,navigation
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  use: {  
    trace: 'retain-on-first-failure',  
  },  
});","New mode `retain-on-first-failure` for [testOptions.trace](/docs/api/class-testoptions#test-options-trace). In this mode, trace is recorded for the first run of each test, but not for retires. When test run fails, the trace file is retained, otherwise it is removed.",https://playwright.dev/docs/release-notes,general
javascript,"test('example', async ({ page }) => {  
  console.log(test.info().tags);  
});",New property [testInfo.tags](/docs/api/class-testinfo#test-info-tags) exposes test tags during test execution.,https://playwright.dev/docs/release-notes,general
javascript,"const locator = page.locator('iframe[name=""embedded""]');  
// ...  
const frameLocator = locator.contentFrame();  
await frameLocator.getByRole('button').click();","New method [locator.contentFrame()](/docs/api/class-locator#locator-content-frame) converts a [Locator](/docs/api/class-locator ""Locator"") object to a [FrameLocator](/docs/api/class-framelocator ""FrameLocator""). This can be useful when you have a [Locator](/docs/api/class-locator ""Locator"") object obtained somewhere, and later on would like to interact with the content inside the frame.",https://playwright.dev/docs/release-notes,navigation
javascript,"const frameLocator = page.frameLocator('iframe[name=""embedded""]');  
// ...  
const locator = frameLocator.owner();  
await expect(locator).toBeVisible();","New method [frameLocator.owner()](/docs/api/class-framelocator#frame-locator-owner) converts a [FrameLocator](/docs/api/class-framelocator ""FrameLocator"") object to a [Locator](/docs/api/class-locator ""Locator""). This can be useful when you have a [FrameLocator](/docs/api/class-framelocator ""FrameLocator"") object obtained somewhere, and later on would like to interact with the `iframe` element.",https://playwright.dev/docs/release-notes,assertion
javascript,"// Setup the handler.  
await page.addLocatorHandler(  
    page.getByRole('heading', { name: 'Hej! You are in control of your cookies.' }),  
    async () => {  
      await page.getByRole('button', { name: 'Accept all' }).click();  
    });  
// Write the test as usual.  
await page.goto('https://www.ikea.com/');  
await page.getByRole('link', { name: 'Collection of blue and white' }).click();  
await expect(page.getByRole('heading', { name: 'Light and easy' })).toBeVisible();",New method [page.addLocatorHandler()](/docs/api/class-page#page-add-locator-handler) registers a callback that will be invoked when specified element becomes visible and may block Playwright actions. The callback can get rid of the overlay. Here is an example that closes a cookie dialog when it appears:,https://playwright.dev/docs/release-notes,assertion
javascript,"electronApp.on('console', async msg => {  
  const values = [];  
  for (const arg of msg.args())  
    values.push(await arg.jsonValue());  
  console.log(...values);  
});  
await electronApp.evaluate(() => console.log('hello', 5, { foo: 'bar' }));",[electronApplication.on('console')](/docs/api/class-electronapplication#electron-application-event-console) event is emitted when Electron main process calls console API methods.,https://playwright.dev/docs/release-notes,wait_strategy
javascript,"test('test customer login', {  
  tag: ['@fast', '@login'],  
}, async ({ page }) => {  
  // ...  
});",[New syntax](/docs/test-annotations#tag-tests) for adding tags to the tests (@-tokens in the test title are still supported):,https://playwright.dev/docs/release-notes,general
javascript,"test('test full report', {  
  annotation: [  
    { type: 'issue', description: 'https://github.com/microsoft/playwright/issues/23180' },  
    { type: 'docs', description: 'https://playwright.dev/docs/test-annotations#tag-tests' },  
  ],  
}, async ({ page }) => {  
  // ...  
});",[New syntax](/docs/test-annotations#annotate-tests) for test annotations:,https://playwright.dev/docs/release-notes,form_interaction
javascript,"import { test, expect } from '@playwright/test';  
  
test('test', async ({ page }) => {  
  await page.goto('https://playwright.dev/');  
  await page.getByRole('link', { name: 'Get started' }).click();  
  await expect(page.getByLabel('Breadcrumbs').getByRole('list')).toContainText('Installation');  
  await expect(page.getByLabel('Search')).toBeVisible();  
  await page.getByLabel('Search').click();  
  await page.getByPlaceholder('Search docs').fill('locator');  
  await expect(page.getByPlaceholder('Search docs')).toHaveValue('locator');  
});",Here is an example of a generated test with assertions:,https://playwright.dev/docs/release-notes,assertion
javascript,"import { expect as baseExpect } from '@playwright/test';  
export const expect = baseExpect.extend({  
  async toHaveAmount(locator: Locator, expected: number, options?: { timeout?: number }) {  
    // ... see documentation for how to write matchers.  
  },  
});  
  
test('pass', async ({ page }) => {  
  await expect(page.getByTestId('cart')).toHaveAmount(5);  
});",You can extend Playwright assertions by providing custom matchers. These matchers will be available on the expect object. | test.spec.ts,https://playwright.dev/docs/release-notes,assertion
javascript,"import { mergeTests } from '@playwright/test';  
import { test as dbTest } from 'database-test-utils';  
import { test as a11yTest } from 'a11y-test-utils';  
  
export const test = mergeTests(dbTest, a11yTest);",You can now merge test fixtures from multiple files or modules: | fixtures.ts,https://playwright.dev/docs/release-notes,general
javascript,"import { test } from './fixtures';  
  
test('passes', async ({ database, page, a11y }) => {  
  // use database and a11y fixtures.  
});",test.spec.ts,https://playwright.dev/docs/release-notes,fixture
javascript,"import { mergeTests, mergeExpects } from '@playwright/test';  
import { test as dbTest, expect as dbExpect } from 'database-test-utils';  
import { test as a11yTest, expect as a11yExpect } from 'a11y-test-utils';  
  
export const test = mergeTests(dbTest, a11yTest);  
export const expect = mergeExpects(dbExpect, a11yExpect);",You can now merge custom expect matchers from multiple files or modules: | fixtures.ts,https://playwright.dev/docs/release-notes,assertion
javascript,"import { test, expect } from './fixtures';  
  
test('passes', async ({ page, database }) => {  
  await expect(database).toHaveDatabaseUser('admin');  
  await expect(page).toPassA11yAudit();  
});",test.spec.ts,https://playwright.dev/docs/release-notes,fixture
javascript,"async function login(page) {  
  await test.step('login', async () => {  
    // ...  
  }, { box: true });  // Note the ""box"" option here.  
}  



Error: Timed out 5000ms waiting for expect(locator).toBeVisible()  
  ... error details omitted ...  
  
  14 |   await page.goto('https://github.com/login');  
> 15 |   await login(page);  
     |         ^  
  16 | });","Hide implementation details: box test stepsâ€‹ | You can mark a [test.step()](/docs/api/class-test#test-step) as ""boxed"" so that errors inside it point to the step call site.",https://playwright.dev/docs/release-notes,assertion
javascript,"await page.goto('https://playwright.dev');  
await expect(page).toHaveScreenshot({  
  mask: [page.locator('img')],  
  maskColor: '#00FF00', // green  
});","UI mode and trace viewer mark network requests handled with [page.route()](/docs/api/class-page#page-route) and [browserContext.route()](/docs/api/class-browsercontext#browser-context-route) handlers, as well as those issued via the [API testing](/docs/api-testing): | New option `maskColor` for methods [page.screenshot()](/docs/api/class-page#page-screenshot), [locator.screenshot()](/docs/api/class-locator#locator-screenshot), [expect(page).toHaveScreenshot()](/docs/api/class-pageassertions#page-assertions-to-have-screenshot-1) and [expect(locator).toHaveScreenshot()](/docs/api/class-locatorassertions#locator-assertions-to-have-screenshot-1) to change default masking color:",https://playwright.dev/docs/release-notes,assertion
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  projects: [  
    {  
      name: 'setup',  
      testMatch: /global.setup\.ts/,  
      teardown: 'teardown',  
    },  
    {  
      name: 'teardown',  
      testMatch: /global.teardown\.ts/,  
    },  
    {  
      name: 'chromium',  
      use: devices['Desktop Chrome'],  
      dependencies: ['setup'],  
    },  
    {  
      name: 'firefox',  
      use: devices['Desktop Firefox'],  
      dependencies: ['setup'],  
    },  
    {  
      name: 'webkit',  
      use: devices['Desktop Safari'],  
      dependencies: ['setup'],  
    },  
  ],  
});",A common pattern would be a `setup` dependency with a corresponding `teardown`: | playwright.config.ts,https://playwright.dev/docs/release-notes,general
javascript,"const slowExpect = expect.configure({ timeout: 10000 });  
await slowExpect(locator).toHaveText('Submit');  
  
// Always do soft assertions.  
const softExpect = expect.configure({ soft: true });",New method [`expect.configure`](/docs/test-assertions#expectconfigure) to create pre-configured expect instance with its own defaults such as `timeout` and `soft`.,https://playwright.dev/docs/release-notes,assertion
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  // Run your local dev server before starting the tests  
  webServer: {  
    command: 'npm run start',  
    url: 'http://127.0.0.1:3000',  
    reuseExistingServer: !process.env.CI,  
    stdout: 'pipe',  
    stderr: 'pipe',  
  },  
});",New options `stderr` and `stdout` in [testConfig.webServer](/docs/api/class-testconfig#test-config-web-server) to configure output handling: | playwright.config.ts,https://playwright.dev/docs/release-notes,general
javascript,const button = page.getByRole('button').and(page.getByTitle('Subscribe'));,New [locator.and()](/docs/api/class-locator#locator-and) to create a locator that matches both locators.,https://playwright.dev/docs/release-notes,general
javascript,"import { chromium, firefox, webkit } from '@playwright/test';  
/* ... */","`npx playwright test` no longer works if you install both `playwright` and `@playwright/test`. There's no need to install both, since you can always import browser automation APIs from `@playwright/test` directly: | automation.ts",https://playwright.dev/docs/release-notes,general
javascript,"const newEmail = page.getByRole('button', { name: 'New email' });  
const dialog = page.getByText('Confirm security settings');  
await expect(newEmail.or(dialog)).toBeVisible();  
if (await dialog.isVisible())  
  await page.getByRole('button', { name: 'Dismiss' }).click();  
await newEmail.click();","Locators Updateâ€‹ | Use [locator.or()](/docs/api/class-locator#locator-or) to create a locator that matches either of the two locators. Consider a scenario where you'd like to click on a ""New email"" button, but sometimes a security settings dialog shows up instead. In this case, you can wait for either a ""New email"" button, or a dialog and act accordingly:",https://playwright.dev/docs/release-notes,assertion
javascript,"const rowLocator = page.locator('tr');  
await rowLocator  
    .filter({ hasNotText: 'text in column 1' })  
    .filter({ hasNot: page.getByRole('button', { name: 'column 2 button' }) })  
    .screenshot();",Use new options [hasNot](/docs/api/class-locator#locator-filter-option-has-not) and [hasNotText](/docs/api/class-locator#locator-filter-option-has-not-text) in [locator.filter()](/docs/api/class-locator#locator-filter) to find elements that **do not match** certain conditions.,https://playwright.dev/docs/release-notes,wait_strategy
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  projects: [  
    {  
      name: 'setup',  
      testMatch: /global.setup\.ts/,  
    },  
    {  
      name: 'chromium',  
      use: devices['Desktop Chrome'],  
      dependencies: ['setup'],  
    },  
    {  
      name: 'firefox',  
      use: devices['Desktop Firefox'],  
      dependencies: ['setup'],  
    },  
    {  
      name: 'webkit',  
      use: devices['Desktop Safari'],  
      dependencies: ['setup'],  
    },  
  ],  
});","Using dependencies allows global setup to produce traces and other artifacts, see the setup steps in the test report and more. | playwright.config.ts",https://playwright.dev/docs/release-notes,general
javascript,"const button = page.getByRole('button');  
  
// Make sure at least some part of element intersects viewport.  
await expect(button).toBeInViewport();  
  
// Make sure element is fully outside of viewport.  
await expect(button).not.toBeInViewport();  
  
// Make sure that at least half of the element intersects viewport.  
await expect(button).toBeInViewport({ ratio: 0.5 });","New assertion [expect(locator).toBeInViewport()](/docs/api/class-locatorassertions#locator-assertions-to-be-in-viewport) ensures that locator points to an element that intersects viewport, according to the [intersection observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API).",https://playwright.dev/docs/release-notes,assertion
javascript,"// Before  
  
import { type PlaywrightTestConfig, devices } from '@playwright/experimental-ct-react';  
const config: PlaywrightTestConfig = {  
  // ... config goes here ...  
};  
export default config;","Note: **component tests only** , does not affect end-to-end tests. | `playwright-ct.config` configuration file for [component testing](/docs/test-components) now requires calling `defineConfig`.",https://playwright.dev/docs/release-notes,form_interaction
javascript,"await page.route('**/api/settings', async route => {  
  // Fetch original settings.  
  const response = await route.fetch();  
  
  // Force settings theme to a predefined value.  
  const json = await response.json();  
  json.theme = 'Solorized';  
  
  // Fulfill with modified data.  
  await route.fulfill({ json });  
});",New APIsâ€‹ | New method [route.fetch()](/docs/api/class-route#route-fetch) and new option `json` for [route.fulfill()](/docs/api/class-route#route-fulfill):,https://playwright.dev/docs/release-notes,form_interaction
javascript,"// Check all checkboxes!  
const checkboxes = page.getByRole('checkbox');  
for (const checkbox of await checkboxes.all())  
  await checkbox.check();",New method [locator.all()](/docs/api/class-locator#locator-all) to iterate over all matching elements:,https://playwright.dev/docs/release-notes,wait_strategy
javascript,"await expect(async () => {  
  const response = await page.request.get('https://api.example.com');  
  await expect(response).toBeOK();  
}).toPass();",Retry blocks of code until all assertions pass:,https://playwright.dev/docs/release-notes,assertion
javascript,"import { defineConfig } from '@playwright/test';  
export default defineConfig({  
  use: {  
    screenshot: {  
      mode: 'only-on-failure',  
      fullPage: true,  
    }  
  }  
});",Automatically capture **full page screenshot** on test failure: | playwright.config.ts,https://playwright.dev/docs/release-notes,general
javascript,"// Each test in the file will be retried twice and have a timeout of 20 seconds.  
test.describe.configure({ retries: 2, timeout: 20_000 });  
test('runs first', async ({ page }) => {});  
test('runs second', async ({ page }) => {});",Test Runnerâ€‹ | Configure retries and test timeout for a file or a test with [test.describe.configure()](/docs/api/class-test#test-describe-configure).,https://playwright.dev/docs/release-notes,general
javascript,"import { defineConfig } from '@playwright/test';  
export default defineConfig({  
  testDir: './tests',  
  snapshotPathTemplate: '{testDir}/__screenshots__/{testFilePath}/{arg}{ext}',  
});",Use [testProject.snapshotPathTemplate](/docs/api/class-testproject#test-project-snapshot-path-template) and [testConfig.snapshotPathTemplate](/docs/api/class-testconfig#test-config-snapshot-path-template) to configure a template controlling location of snapshots generated by [expect(page).toHaveScreenshot()](/docs/api/class-pageassertions#page-assertions-to-have-screenshot-1) and [expect(value).toMatchSnapshot()](/docs/api/class-snapshotassertions#snapshot-assertions-to-match-snapshot-1). | playwright.config.ts,https://playwright.dev/docs/release-notes,general
javascript,"await page.getByLabel('User Name').fill('John');  
  
await page.getByLabel('Password').fill('secret-password');  
  
await page.getByRole('button', { name: 'Sign in' }).click();  
  
await expect(page.getByText('Welcome, John!')).toBeVisible();",[page.getByTitle()](/docs/api/class-page#page-get-by-title) to locate an element by its title.,https://playwright.dev/docs/release-notes,assertion
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  reporter: [['html', { host: 'localhost', port: '9223' }]],  
});",New options `host` and `port` for the html reporter.,https://playwright.dev/docs/release-notes,general
javascript,"await expect(page.getByRole('button')).toHaveAttribute('disabled', '');","Behavior Changesâ€‹ | [expect(locator).toHaveAttribute()](/docs/api/class-locatorassertions#locator-assertions-to-have-attribute) with an empty value does not match missing attribute anymore. For example, the following snippet will succeed when `button` **does not** have a `disabled` attribute.",https://playwright.dev/docs/release-notes,assertion
javascript,"await page.goto('https://playwright.dev', {  
  waitUntil: 'domcontentloaded',  
});",Behavior Changeâ€‹ | A bunch of Playwright APIs already support the `waitUntil: 'domcontentloaded'` option. For example:,https://playwright.dev/docs/release-notes,navigation
javascript,"test('should work', async ({ page }) => {  
  const pageTitle = await test.step('get title', async () => {  
    await page.goto('https://playwright.dev');  
    return await page.title();  
  });  
  console.log(pageTitle);  
});",Test Runnerâ€‹ | [test.step()](/docs/api/class-test#test-step) now returns the value of the step function:,https://playwright.dev/docs/release-notes,assertion
javascript,"import { defineConfig } from '@playwright/test';  
export default defineConfig({  
  webServer: [  
    {  
      command: 'npm run start',  
      url: 'http://127.0.0.1:3000',  
      timeout: 120 * 1000,  
      reuseExistingServer: !process.env.CI,  
    },  
    {  
      command: 'npm run backend',  
      url: 'http://127.0.0.1:3333',  
      timeout: 120 * 1000,  
      reuseExistingServer: !process.env.CI,  
    }  
  ],  
  use: {  
    baseURL: 'http://localhost:3000/',  
  },  
});","Launch multiple web servers, databases, or other processes by passing an array of configurations: | playwright.config.ts",https://playwright.dev/docs/release-notes,general
javascript,"test.describe(() => {  
  test.use({ colorScheme: 'dark' });  
  
  test('one', async ({ page }) => {  
    // ...  
  });  
  
  test('two', async ({ page }) => {  
    // ...  
  });  
});",ðŸ•µï¸ Anonymous Describeâ€‹ | It is now possible to call [test.describe()](/docs/api/class-test#test-describe) to create suites without a title. This is useful for giving a group of tests a common option with [test.use()](/docs/api/class-test#test-use).,https://playwright.dev/docs/release-notes,general
javascript,"import { test } from '@playwright/experimental-ct-vue';  
import { Component } from './mycomponent';  
  
test('should work', async ({ mount }) => {  
  const component = await mount(Component, {  
    hooksConfig: {  
      /* anything to configure your app */  
    }  
  });  
});","For example, this could be used to setup App router in Vue.js: | src/component.spec.ts",https://playwright.dev/docs/release-notes,assertion
javascript,"import { test } from '@playwright/experimental-ct-react';  
import { Component } from './mycomponent';  
  
test('should work', async ({ mount }) => {  
  const component = await mount(<Component></Component>, {  
    // Pass mock value from test into `beforeMount`.  
    hooksConfig: {  
      router: {  
        query: { page: 1, per_page: 10 },  
        asPath: '/posts'  
      }  
    }  
  });  
});",A similar configuration in Next.js would look like this: | src/component.spec.jsx,https://playwright.dev/docs/release-notes,assertion
javascript,"const context = await browser.newContext({  
  recordHar: { path: 'github.har.zip' }  
});  
// ... do stuff ...  
await context.close();","Alternatively, you can record HAR programmatically:",https://playwright.dev/docs/release-notes,wait_strategy
javascript,"// Remove a header from all requests.  
test.beforeEach(async ({ page }) => {  
  await page.route('**/*', async route => {  
    const headers = await route.request().allHeaders();  
    delete headers['if-none-match'];  
    await route.fallback({ headers });  
  });  
});  
  
test('should work', async ({ page }) => {  
  await page.route('**/*', async route => {  
    if (route.request().resourceType() === 'image')  
      await route.abort();  
    else  
      await route.fallback();  
  });  
});",You can now use [route.fallback()](/docs/api/class-route#route-fallback) to defer routing to other handlers. | Consider the following example:,https://playwright.dev/docs/release-notes,assertion
javascript,"const context = await browser.newContext({  
  recordHar: {  
    path: 'github.har.zip',  
  }  
});",Using `.zip` path for `recordHar` context option automatically zips the resulting HAR:,https://playwright.dev/docs/release-notes,wait_strategy
javascript,"const context = await browser.newContext({  
  recordHar: {  
    path: 'github.har',  
    mode: 'minimal',  
  }  
});","If you intend to edit HAR by hand, consider using the `""minimal""` HAR recording mode that only records information that is essential for replaying:",https://playwright.dev/docs/release-notes,wait_strategy
javascript,"import { test, expect } from '@playwright/experimental-ct-react';  
import App from './App';  
  
// Let's test component in a dark scheme!  
test.use({ colorScheme: 'dark' });  
  
test('should render', async ({ mount }) => {  
  const component = await mount(<App></App>);  
  
  // As with any Playwright test, assert locator text.  
  await expect(component).toContainText('React');  
  // Or do a screenshot ðŸš€  
  await expect(component).toHaveScreenshot();  
  // Or use any Playwright method  
  await component.click();  
});",Here is what a typical component test looks like: | App.spec.tsx,https://playwright.dev/docs/release-notes,assertion
javascript,"// Click a button with accessible name ""log in""  
await page.locator('role=button[name=""log in""]').click();","Read more in [our documentation](/docs/test-components). | Role selectors that allow selecting elements by their [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) and [accessible name](https://w3c.github.io/accname/#dfn-accessible-name).",https://playwright.dev/docs/release-notes,navigation
javascript,"const buttons = page.locator('role=button');  
// ...  
const submitButton = buttons.filter({ hasText: 'Submit' });  
await submitButton.click();",Read more in [our documentation](/docs/locators#locate-by-role). | New [locator.filter()](/docs/api/class-locator#locator-filter) API to filter an existing locator,https://playwright.dev/docs/release-notes,navigation
javascript,"* disables animations
* uses CSS scale option

    await page.goto('https://playwright.dev');  
await expect(page).toHaveScreenshot();","The new assertions has screenshot-specific defaults, such as:",https://playwright.dev/docs/release-notes,assertion
javascript,"// Click a button with accessible name ""log in""  
await page.locator('role=button[name=""log in""]').click();","Highlightsâ€‹ | New role selectors that allow selecting elements by their [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) and [accessible name](https://w3c.github.io/accname/#dfn-accessible-name).",https://playwright.dev/docs/release-notes,navigation
javascript,"// Poll the method until it returns an expected result.  
await expect.poll(async () => {  
  const response = await page.request.get('https://api.example.com');  
  return response.status();  
}).toBe(200);","New `caret` option in [page.screenshot()](/docs/api/class-page#page-screenshot) to control text caret. Defaults to `""hide""`. | New method `expect.poll` to wait for an arbitrary condition:",https://playwright.dev/docs/release-notes,assertion
javascript,"expect(await page.screenshot()).toMatchSnapshot({  
  maxDiffPixels: 27, // allow no more than 27 different pixels.  
});",New `maxDiffPixels` and `maxDiffPixelRatio` options for fine-grained screenshot comparison using `expect().toMatchSnapshot()`:,https://playwright.dev/docs/release-notes,assertion
javascript,"// Make a few checks that will not stop the test when failed...  
await expect.soft(page.locator('#status')).toHaveText('Success');  
await expect.soft(page.locator('#eta')).toHaveText('1 day');  
  
// ... and continue the test to check more things.  
await page.locator('#next-page').click();  
await expect.soft(page.locator('#title')).toHaveText('Make another order');","Playwright Test v1.19 now supports _soft assertions_. Failed soft assertions | **do not** terminate test execution, but mark the test as failed.",https://playwright.dev/docs/release-notes,assertion
javascript,"await expect(page.locator('text=Name'), 'should be logged in').toBeVisible();","Read more in [our documentation](/docs/test-assertions#soft-assertions) | You can now specify a **custom expect message** as a second argument to the `expect` and `expect.soft` functions, for example:",https://playwright.dev/docs/release-notes,assertion
javascript,"Error: should be logged in  
  
    Call log:  
      - expect.toBeVisible with timeout 5000ms  
      - waiting for ""getByText('Name')""  
  
  
      2 |  
      3 | test('example test', async({ page }) => {  
    > 4 |   await expect(page.locator('text=Name'), 'should be logged in').toBeVisible();  
        |                                                                  ^  
      5 | });  
      6 |",The error would look like this:,https://playwright.dev/docs/release-notes,assertion
javascript,"await page.locator('article', {  
  has: page.locator('.highlight'),  
}).click();",Other Updatesâ€‹ | Locator now supports a `has` option that makes sure it contains another locator inside:,https://playwright.dev/docs/release-notes,navigation
javascript,"await page.locator('li', { hasText: 'my item' }).locator('button').click();",[`expect(locator).toBeChecked({ checked })`](/docs/api/class-locatorassertions#locator-assertions-to-be-checked) | Each locator can now be optionally filtered by the text it contains:,https://playwright.dev/docs/release-notes,navigation
javascript,"// WRONG: THIS SNIPPET DOES NOT WORK SINCE v1.18.  
  
// fixtures.js  
const test = base.extend({  
  myParameter: 'default',  
});  
  
// playwright.config.js  
module.exports = {  
  use: {  
    myParameter: 'value',  
  },  
};","Custom config options are a convenient way to parametrize projects with different values. Learn more in [this guide](/docs/test-parameterize#parameterized-projects). | Previously, any fixture introduced through [test.extend()](/docs/api/class-test#test-extend) could be overridden in the [testProject.use](/docs/api/class-testproject#test-project-use) config section. For example,",https://playwright.dev/docs/release-notes,fixture
javascript,"// CORRECT: THIS SNIPPET WORKS SINCE v1.18.  
  
// fixtures.js  
const test = base.extend({  
  // Fixtures marked as ""option: true"" will get a value specified in the config,  
  // or fallback to the default value.  
  myParameter: ['default', { option: true }],  
});  
  
// playwright.config.js  
module.exports = {  
  use: {  
    myParameter: 'value',  
  },  
};","The proper way to make a fixture parametrized in the config file is to specify `option: true` when defining the fixture. For example,",https://playwright.dev/docs/release-notes,fixture
javascript,"const locator = page.frameLocator('#my-iframe').locator('text=Submit');  
await locator.click();","Playwright 1.17 introduces [frame locators](/docs/api/class-framelocator) \- a locator to the iframe on the page. Frame locators capture the logic sufficient to retrieve the `iframe` and then locate elements in that iframe. Frame locators are strict by default, will wait for `iframe` to appear and can be used in Web-First assertions. | Frame locators can be created with either [page.frameLocator()](/docs/api/class-page#page-frame-locator) or [locator.frameLocator()](/docs/api/class-locator#locator-frame-locator) method.",https://playwright.dev/docs/release-notes,navigation
javascript,"import { test, expect } from '@playwright/test';  
  
test('context fetch', async ({ page }) => {  
  // Do a GET request on behalf of page  
  const response = await page.request.get('http://example.com/foo.json');  
  // ...  
});","To do a request on behalf of Playwright's Page, use **new[page.request](/docs/api/class-page#page-request) API**:",https://playwright.dev/docs/release-notes,assertion
javascript,"import { test, expect } from '@playwright/test';  
  
test('context fetch', async ({ request }) => {  
  // Do a GET request on behalf of page  
  const response = await request.get('http://example.com/foo.json');  
  // ...  
});","To do a stand-alone request from node.js to an API endpoint, use **new[`request` fixture](/docs/api/class-fixtures#fixtures-request)**:",https://playwright.dev/docs/release-notes,assertion
javascript,"import { test, expect } from '@playwright/test';  
import jimp from 'jimp'; // image processing library  
  
test('response interception', async ({ page }) => {  
  await page.route('**/*.jpeg', async route => {  
    const response = await page._request.fetch(route.request());  
    const image = await jimp.read(await response.body());  
    await image.blur(5);  
    await route.fulfill({  
      response,  
      body: await image.getBufferAsync('image/jpeg'),  
    });  
  });  
  const response = await page.goto('https://playwright.dev');  
  expect(response.status()).toBe(200);  
});","It is now possible to do response interception by combining [API Testing](/docs/api-testing) with [request interception](/docs/network#modify-requests). | For example, we can blur all the images on the page:",https://playwright.dev/docs/release-notes,assertion
javascript,"import { test, expect } from '@playwright/test';  
  
test('context fetch', async ({ page }) => {  
  const completeness = page.locator('text=Success');  
  await completeness.waitFor();  
  expect(await page.screenshot()).toMatchSnapshot('screen.png');  
});",Wait for a locator to resolve to a single element with a given state. Defaults to the `state: 'visible'`. | Comes especially handy when working with lists:,https://playwright.dev/docs/release-notes,assertion
javascript,"test.describe.parallel('group', () => {  
  test('runs in parallel 1', async ({ page }) => {  
  });  
  test('runs in parallel 2', async ({ page }) => {  
  });  
});",ðŸŽ­ Playwright Testâ€‹ | ðŸ¤ `test.parallel()` run tests in the same file in parallelâ€‹,https://playwright.dev/docs/release-notes,general
javascript,"// This will throw if you have more than one button!  
await page.click('button', { strict: true });","Selector ambiguity is a common problem in automation testing. **""strict"" mode** ensures that your selector points to a single element and throws otherwise. | Pass `strict: true` into your action calls to opt in.",https://playwright.dev/docs/release-notes,navigation
javascript,"const locator = page.locator('button');  
await locator.click();","The difference between the [Locator](/docs/api/class-locator) and [ElementHandle](/docs/api/class-elementhandle) is that the latter points to a particular element, while [Locator](/docs/api/class-locator) captures the logic of how to retrieve that element. | Also, locators are **""strict"" by default**!",https://playwright.dev/docs/release-notes,navigation
javascript,"await page.locator('_react=SubmitButton[enabled=true]').click();  
await page.locator('_vue=submit-button[enabled=true]').click();",ðŸ§© Experimental [**React**](/docs/other-locators#react-locator) and [**Vue**](/docs/other-locators#vue-locator) selector enginesâ€‹ | React and Vue selectors allow selecting elements by its component name and/or property values. The syntax is very similar to [attribute selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors) and supports all attribute selector operators.,https://playwright.dev/docs/release-notes,navigation
javascript,"// select the first button among all buttons  
await button.click('button >> nth=0');  
// or if you are using locators, you can use first(), nth() and last()  
await page.locator('button').first().click();  
  
// click a visible button  
await button.click('button >> visible=true');","[`visible`](/docs/other-locators#css-matching-only-visible-elements) selector engine is equivalent to the `:visible` pseudo class, but could be combined with other selector engines.",https://playwright.dev/docs/release-notes,navigation
javascript,await expect(page.locator('.status')).toHaveText('Submitted');,`expect` now supports lots of new web-first assertions. | Consider the following example:,https://playwright.dev/docs/release-notes,assertion
javascript,"test.describe.serial('group', () => {  
  test('runs first', async ({ page }) => { /* ... */ });  
  test('runs second', async ({ page }) => { /* ... */ });  
});","â›“ Serial mode with [`describe.serial`](/docs/api/class-test#test-describe-serial)â€‹ | Declares a group of tests that should always be run serially. If one of the tests fails, all subsequent tests are skipped. All tests in a group are retried together.",https://playwright.dev/docs/release-notes,general
javascript,"import { test, expect } from '@playwright/test';  
  
test('test', async ({ page }) => {  
  await test.step('Log in', async () => {  
    // ...  
  });  
  await test.step('news feed', async () => {  
    // ...  
  });  
});",ðŸ¾ Steps API with [`test.step`](/docs/api/class-test#test-step)â€‹ | Split long tests into multiple steps using `test.step()` API:,https://playwright.dev/docs/release-notes,assertion
javascript,"import { defineConfig } from '@playwright/test';  
export default defineConfig({  
  webServer: {  
    command: 'npm run start', // command to launch  
    url: 'http://127.0.0.1:3000', // url to await for  
    timeout: 120 * 1000,  
    reuseExistingServer: !process.env.CI,  
  },  
});","To launch a server during the tests, use the [`webServer`](/docs/test-webserver) option in the configuration file. The server will wait for a given url to be available before running the tests, and the url will be passed over to Playwright as a [`baseURL`](/docs/api/class-testoptions#test-options-base-url) when creating a context. | playwright.config.ts",https://playwright.dev/docs/release-notes,wait_strategy
javascript,"import { test, expect } from '@playwright/test';  
  
test('basic test', async ({ page }) => {  
  await page.goto('https://playwright.dev/');  
  const name = await page.innerText('.navbar__title');  
  expect(name).toBe('Playwright');  
});",Simple test `tests/foo.spec.ts`:,https://playwright.dev/docs/release-notes,assertion
javascript,"const browser = await chromium.launch();  
const context = await browser.newContext();  
  
// Start tracing before creating / navigating a page.  
await context.tracing.start({ screenshots: true, snapshots: true });  
  
const page = await context.newPage();  
await page.goto('https://playwright.dev');  
  
// Stop tracing and export it into a zip archive.  
await context.tracing.stop({ path: 'trace.zip' });",Traces are recorded using the new [browserContext.tracing](/docs/api/class-browsercontext#browser-context-tracing) API:,https://playwright.dev/docs/release-notes,navigation
javascript,"* [page.waitForURL()](/docs/api/class-page#page-wait-for-url) to await navigations to URL
* [video.delete()](/docs/api/class-video#video-delete) and [video.saveAs()](/docs/api/class-video#video-save-as) to manage screen recording","support for **async predicates** across the API in methods such as [page.waitForRequest()](/docs/api/class-page#page-wait-for-request) and others | new **emulation devices** : Galaxy S8, Galaxy S9+, Galaxy Tab S4, Pixel 3, Pixel 4 | new methods:",https://playwright.dev/docs/release-notes,page_object
javascript,await page.screenshot({ path: 'screenshot.png' });,Introductionâ€‹ | Here is a quick way to capture a screenshot and save it into a file:,https://playwright.dev/docs/screenshots,wait_strategy
javascript,"await page.screenshot({ path: 'screenshot.png', fullPage: true });","Full page screenshotsâ€‹ | Full page screenshot is a screenshot of a full scrollable page, as if you had a very tall screen and the page could fit it entirely.",https://playwright.dev/docs/screenshots,wait_strategy
javascript,"const buffer = await page.screenshot();  
console.log(buffer.toString('base64'));","Capture into bufferâ€‹ | Rather than writing into a file, you can get a buffer with the image and post-process it or pass it to a third party pixel diff facility.",https://playwright.dev/docs/screenshots,wait_strategy
javascript,"test('skip this test', async ({ page, browserName }) => {  
  test.skip(browserName === 'firefox', 'Still working on it');  
});",Conditionally skip a testâ€‹ | You can skip certain test based on the condition.,https://playwright.dev/docs/test-annotations,general
javascript,"import { test, expect } from '@playwright/test';  
  
test.describe('two tests', () => {  
  test('one', async ({ page }) => {  
    // ...  
  });  
  
  test('two', async ({ page }) => {  
    // ...  
  });  
});",Group testsâ€‹ | You can group tests to give them a logical name or to scope before/after hooks to the group.,https://playwright.dev/docs/test-annotations,assertion
javascript,"import { test, expect } from '@playwright/test';  
  
test('test login page', {  
  tag: '@fast',  
}, async ({ page }) => {  
  // ...  
});  
  
test('test full report @slow', async ({ page }) => {  
  // ...  
});","Sometimes you want to tag your tests as `@fast` or `@slow`, and then filter by tag in the test report. Or you might want to only run tests that have a certain tag. | To tag a test, either provide an additional details object when declaring a test, or add `@`-token to the test title. Note that tags must start with `@` symbol.",https://playwright.dev/docs/test-annotations,assertion
javascript,"import { test, expect } from '@playwright/test';  
  
test.describe('group', {  
  tag: '@report',  
}, () => {  
  test('test report header', async ({ page }) => {  
    // ...  
  });  
  
  test('test full report', {  
    tag: ['@slow', '@vrt'],  
  }, async ({ page }) => {  
    // ...  
  });  
});",You can also tag all tests in a group or provide multiple tags:,https://playwright.dev/docs/test-annotations,assertion
javascript,"import { test, expect } from '@playwright/test';  
  
test('test login page', {  
  annotation: {  
    type: 'issue',  
    description: 'https://github.com/microsoft/playwright/issues/23180',  
  },  
}, async ({ page }) => {  
  // ...  
});","If you would like to annotate your tests with something more substantial than a tag, you can do that when declaring a test. Annotations have a `type` and a `description` for more context and available in reporter API. Playwright's built-in HTML reporter shows all annotations, except those where `type` starts with `_` symbol. | For example, to annotate a test with an issue url:",https://playwright.dev/docs/test-annotations,assertion
javascript,"import { test, expect } from '@playwright/test';  
  
test.describe('report tests', {  
  annotation: { type: 'category', description: 'report' },  
}, () => {  
  test('test report header', async ({ page }) => {  
    // ...  
  });  
  
  test('test full report', {  
    annotation: [  
      { type: 'issue', description: 'https://github.com/microsoft/playwright/issues/23180' },  
      { type: 'performance', description: 'very slow test!' },  
    ],  
  }, async ({ page }) => {  
    // ...  
  });  
});",You can also annotate all tests in a group or provide multiple annotations:,https://playwright.dev/docs/test-annotations,assertion
javascript,"test.describe('chromium only', () => {  
  test.skip(({ browserName }) => browserName !== 'chromium', 'Chromium only!');  
  
  test.beforeAll(async () => {  
    // This hook is only run in Chromium.  
  });  
  
  test('test 1', async ({ page }) => {  
    // This test is only run in Chromium.  
  });  
  
  test('test 2', async ({ page }) => {  
    // This test is only run in Chromium.  
  });  
});","For example, you can run a group of tests just in Chromium by passing a callback. | example.spec.ts",https://playwright.dev/docs/test-annotations,fixture
javascript,"test.beforeEach(async ({ page, isMobile }) => {  
  test.fixme(isMobile, 'Settings page does not work in mobile yet');  
  
  await page.goto('http://localhost:3000/settings');  
});  
  
test('user profile', async ({ page }) => {  
  await page.getByText('My Profile').click();  
  // ...  
});","To avoid running `beforeEach` hooks, you can put annotations in the hook itself. | example.spec.ts",https://playwright.dev/docs/test-annotations,navigation
javascript,await expect(page.getByTestId('status')).toHaveText('Submitted');,Playwright also includes web-specific [async matchers](/docs/api/class-locatorassertions) that will wait until the expected condition is met. Consider the following example:,https://playwright.dev/docs/test-assertions,assertion
javascript,"expect(value).not.toEqual(0);  
await expect(locator).not.toContainText('some text');","Negating matchersâ€‹ | In general, we can expect the opposite to be true by adding a `.not` to the front of the matchers:",https://playwright.dev/docs/test-assertions,assertion
javascript,"// Make a few checks that will not stop the test when failed...  
await expect.soft(page.getByTestId('status')).toHaveText('Success');  
await expect.soft(page.getByTestId('eta')).toHaveText('1 day');  
  
// ... and continue the test to check more things.  
await page.getByRole('link', { name: 'next page' }).click();  
await expect.soft(page.getByRole('heading', { name: 'Make another order' })).toBeVisible();","Soft assertionsâ€‹ | By default, failed assertion will terminate test execution. Playwright also supports _soft assertions_ : failed soft assertions **do not** terminate test execution, but mark the test as failed.",https://playwright.dev/docs/test-assertions,assertion
javascript,"// Make a few checks that will not stop the test when failed...  
await expect.soft(page.getByTestId('status')).toHaveText('Success');  
await expect.soft(page.getByTestId('eta')).toHaveText('1 day');  
  
// Avoid running further if there were soft assertion failures.  
expect(test.info().errors).toHaveLength(0);","At any point during test execution, you can check whether there were any soft assertion failures:",https://playwright.dev/docs/test-assertions,assertion
javascript,"await expect(page.getByText('Name'), 'should be logged in').toBeVisible();","Custom expect messageâ€‹ | You can specify a custom expect message as a second argument to the `expect` function, for example:",https://playwright.dev/docs/test-assertions,assertion
javascript,"Error: should be logged in  
  
    Call log:  
      - expect.toBeVisible with timeout 5000ms  
      - waiting for ""getByText('Name')""  
  
  
      2 |  
      3 | test('example test', async({ page }) => {  
    > 4 |   await expect(page.getByText('Name'), 'should be logged in').toBeVisible();  
        |                                                                  ^  
      5 | });  
      6 |","When expect fails, the error would look like this:",https://playwright.dev/docs/test-assertions,assertion
javascript,"const slowExpect = expect.configure({ timeout: 10000 });  
await slowExpect(locator).toHaveText('Submit');  
  
// Always do soft assertions.  
const softExpect = expect.configure({ soft: true });  
await softExpect(locator).toHaveText('Submit');",expect.configureâ€‹ | You can create your own pre-configured `expect` instance to have its own defaults such as `timeout` and `soft`.,https://playwright.dev/docs/test-assertions,assertion
javascript,"await expect.poll(async () => {  
  const response = await page.request.get('https://api.example.com');  
  return response.status();  
}, {  
  // Custom expect message for reporting, optional.  
  message: 'make sure API eventually succeeds',  
  // Poll for 10 seconds; defaults to 5 seconds. Pass 0 to disable timeout.  
  timeout: 10000,  
}).toBe(200);",You can convert any synchronous `expect` to an asynchronous polling one using `expect.poll`. | The following method will poll given function until it returns HTTP status 200:,https://playwright.dev/docs/test-assertions,assertion
javascript,"await expect.poll(async () => {  
  const response = await page.request.get('https://api.example.com');  
  return response.status();  
}, {  
  // Probe, wait 1s, probe, wait 2s, probe, wait 10s, probe, wait 10s, probe  
  // ... Defaults to [100, 250, 500, 1000].  
  intervals: [1_000, 2_000, 10_000],  
  timeout: 60_000  
}).toBe(200);",You can also specify custom polling intervals:,https://playwright.dev/docs/test-assertions,assertion
javascript,"await expect(async () => {  
  const response = await page.request.get('https://api.example.com');  
  expect(response.status()).toBe(200);  
}).toPass();",expect.toPassâ€‹ | You can retry blocks of code until they are passing successfully.,https://playwright.dev/docs/test-assertions,assertion
javascript,"await expect(async () => {  
  const response = await page.request.get('https://api.example.com');  
  expect(response.status()).toBe(200);  
}).toPass({  
  // Probe, wait 1s, probe, wait 2s, probe, wait 10s, probe, wait 10s, probe  
  // ... Defaults to [100, 250, 500, 1000].  
  intervals: [1_000, 2_000, 10_000],  
  timeout: 60_000  
});",You can also specify custom timeout and retry intervals:,https://playwright.dev/docs/test-assertions,assertion
javascript,"import { expect as baseExpect } from '@playwright/test';  
import type { Page, Locator } from '@playwright/test';  
  
export { test } from '@playwright/test';  
  
export const expect = baseExpect.extend({  
  async toHaveAmount(locator: Locator, expected: number, options?: { timeout?: number }) {  
    const assertionName = 'toHaveAmount';  
    let pass: boolean;  
    let matcherResult: any;  
    try {  
      await baseExpect(locator).toHaveAttribute('data-amount', String(expected), options);  
      pass = true;  
    } catch (e: any) {  
      matcherResult = e.matcherResult;  
      pass = false;  
    }  
  
    const message = pass  
      ? () => this.utils.matcherHint(assertionName, undefined, undefined, { isNot: this.isNot }) +  
          '\n\n' +  
          `Locator: ${locator}\n` +  
          `Expected: not ${this.utils.printExpected(expected)}\n` +  
          (matcherResult ? `Received: ${this.utils.printReceived(matcherResult.actual)}` : '')  
      : () =>  this.utils.matcherHint(assertionName, undefined, undefined, { isNot: this.isNot }) +  
          '\n\n' +  
          `Locator: ${locator}\n` +  
          `Expected: ${this.utils.printExpected(expected)}\n` +  
          (matcherResult ? `Received: ${this.utils.printReceived(matcherResult.actual)}` : '');  
  
    return {  
      message,  
      pass,  
      name: assertionName,  
      expected,  
      actual: matcherResult?.actual,  
    };  
  },  
});","In this example we add a custom `toHaveAmount` function. Custom matcher should return a `pass` flag indicating whether the assertion passed, and a `message` callback that's used when the assertion fails. | fixtures.ts",https://playwright.dev/docs/test-assertions,assertion
javascript,"import { test, expect } from './fixtures';  
  
test('amount', async () => {  
  await expect(page.locator('.cart')).toHaveAmount(4);  
});",Now we can use `toHaveAmount` in the test. | example.spec.ts,https://playwright.dev/docs/test-assertions,fixture
javascript,"import { mergeTests, mergeExpects } from '@playwright/test';  
import { test as dbTest, expect as dbExpect } from 'database-test-utils';  
import { test as a11yTest, expect as a11yExpect } from 'a11y-test-utils';  
  
export const expect = mergeExpects(dbExpect, a11yExpect);  
export const test = mergeTests(dbTest, a11yTest);",You can combine custom matchers from multiple files or modules. | fixtures.ts,https://playwright.dev/docs/test-assertions,assertion
javascript,"test('event should work', async ({ mount }) => {  
  let clicked = false;  
  
  // Mount a component. Returns locator pointing to the component.  
  const component = await mount(  
    <Button title=""Submit"" onClick={() => { clicked = true }}></Button>  
  );  
  
  // As with any Playwright test, assert locator text.  
  await expect(component).toContainText('Submit');  
  
  // Perform locator click. This will trigger the event.  
  await component.click();  
  
  // Assert that respective events have been fired.  
  expect(clicked).toBeTruthy();  
});",Exampleâ€‹ | Here is what a typical component test looks like:,https://playwright.dev/docs/test-components,assertion
javascript,"import { test, expect } from '@playwright/experimental-ct-react';  
import App from './App';  
  
test('should work', async ({ mount }) => {  
  const component = await mount(<App />);  
  await expect(component).toContainText('Learn React');  
});",app.spec.tsx,https://playwright.dev/docs/test-components,assertion
javascript,"import { test, expect } from '@playwright/experimental-ct-vue';  
import App from './App.vue';  
  
test('should work', async ({ mount }) => {  
  const component = await mount(App);  
  await expect(component).toContainText('Learn Vue');  
});",app.spec.ts,https://playwright.dev/docs/test-components,assertion
javascript,"import { test, expect } from '@playwright/experimental-ct-vue';  
import App from './App.vue';  
  
test('should work', async ({ mount }) => {  
  const component = await mount(<App />);  
  await expect(component).toContainText('Learn Vue');  
});",app.spec.tsx,https://playwright.dev/docs/test-components,assertion
javascript,"import { test, expect } from '@playwright/experimental-ct-svelte';  
import App from './App.svelte';  
  
test('should work', async ({ mount }) => {  
  const component = await mount(App);  
  await expect(component).toContainText('Learn Svelte');  
});",app.spec.ts,https://playwright.dev/docs/test-components,assertion
javascript,"test('this will work', async ({ mount }) => {  
  const component = await mount(<ProcessViewer process={{ name: 'playwright' }}/>);  
});  
  
test('this will not work', async ({ mount }) => {  
  // `process` is a Node object, we can't pass it to the browser and expect it to work.  
  const component = await mount(<ProcessViewer process={process}/>);  
});","You can't pass complex live objects to your component. Only plain JavaScript objects and built-in types like strings, numbers, dates etc. can be passed.",https://playwright.dev/docs/test-components,assertion
javascript,"test('this will not work', async ({ mount }) => {  
  // () => 'red' callback lives in Node. If `ColorPicker` component in the browser calls the parameter function  
  // `colorGetter` it won't get result synchronously. It'll be able to get it via await, but that is not how  
  // components are typically built.  
  const component = await mount(<ColorPicker colorGetter={() => 'red'}/>);  
});",You can't pass data to your component synchronously in a callback:,https://playwright.dev/docs/test-components,wait_strategy
javascript,"import React from 'react';  
import InputMedia from './import-media';  
  
type InputMediaForTestProps = {  
  onMediaChange(mediaName: string): void;  
};  
  
export function InputMediaForTest(props: InputMediaForTestProps) {  
  // Instead of sending a complex `media` object to the test, send the media name.  
  return <InputMedia onChange={media => props.onMediaChange(media.name)} />;  
}  
// Export more stories here.",Create a story file for your component: | input-media.story.tsx,https://playwright.dev/docs/test-components,form_interaction
javascript,"import { test, expect } from '@playwright/experimental-ct-react';  
import { InputMediaForTest } from './input-media.story.tsx';  
  
test('changes the image', async ({ mount }) => {  
  let mediaSelected: string | null = null;  
  
  const component = await mount(  
    <InputMediaForTest  
      onMediaChange={mediaName => {  
        mediaSelected = mediaName;  
      }}  
    />  
  );  
  await component  
    .getByTestId('imageInput')  
    .setInputFiles('src/assets/logo.png');  
  
  await expect(component.getByAltText(/selected image/i)).toBeVisible();  
  await expect.poll(() => mediaSelected).toBe('logo.png');  
});",Then test the component via testing the story: | input-media.spec.tsx,https://playwright.dev/docs/test-components,assertion
javascript,"import { test } from '@playwright/experimental-ct-react';  
  
test('props', async ({ mount }) => {  
  const component = await mount(<Component msg=""greetings"" />);  
});",component.spec.tsx,https://playwright.dev/docs/test-components,wait_strategy
javascript,"import { test } from '@playwright/experimental-ct-svelte';  
  
test('props', async ({ mount }) => {  
  const component = await mount(Component, { props: { msg: 'greetings' } });  
});",component.spec.ts,https://playwright.dev/docs/test-components,wait_strategy
javascript,"import { test } from '@playwright/experimental-ct-vue';  
  
test('props', async ({ mount }) => {  
  const component = await mount(Component, { props: { msg: 'greetings' } });  
});",component.spec.ts,https://playwright.dev/docs/test-components,wait_strategy
javascript,"// Or alternatively, using the `jsx` style  
import { test } from '@playwright/experimental-ct-vue';  
  
test('props', async ({ mount }) => {  
  const component = await mount(<Component msg=""greetings"" />);  
});",component.spec.tsx,https://playwright.dev/docs/test-components,wait_strategy
javascript,"import { test } from '@playwright/experimental-ct-react';  
  
test('callback', async ({ mount }) => {  
  const component = await mount(<Component onClick={() => {}} />);  
});",component.spec.tsx,https://playwright.dev/docs/test-components,navigation
javascript,"import { test } from '@playwright/experimental-ct-svelte';  
  
test('event', async ({ mount }) => {  
  const component = await mount(Component, { on: { click() {} } });  
});",component.spec.ts,https://playwright.dev/docs/test-components,navigation
javascript,"import { test } from '@playwright/experimental-ct-vue';  
  
test('event', async ({ mount }) => {  
  const component = await mount(Component, { on: { click() {} } });  
});",component.spec.ts,https://playwright.dev/docs/test-components,navigation
javascript,"// Or alternatively, using the `jsx` style  
import { test } from '@playwright/experimental-ct-vue';  
  
test('event', async ({ mount }) => {  
  const component = await mount(<Component v-on:click={() => {}} />);  
});",component.spec.tsx,https://playwright.dev/docs/test-components,navigation
javascript,"import { test } from '@playwright/experimental-ct-react';  
  
test('children', async ({ mount }) => {  
  const component = await mount(<Component>Child</Component>);  
});",component.spec.tsx,https://playwright.dev/docs/test-components,wait_strategy
javascript,"import { test } from '@playwright/experimental-ct-svelte';  
  
test('slot', async ({ mount }) => {  
  const component = await mount(Component, { slots: { default: 'Slot' } });  
});",component.spec.ts,https://playwright.dev/docs/test-components,wait_strategy
javascript,"import { test } from '@playwright/experimental-ct-vue';  
  
test('slot', async ({ mount }) => {  
  const component = await mount(Component, { slots: { default: 'Slot' } });  
});",component.spec.ts,https://playwright.dev/docs/test-components,wait_strategy
javascript,"// Or alternatively, using the `jsx` style  
import { test } from '@playwright/experimental-ct-vue';  
  
test('children', async ({ mount }) => {  
  const component = await mount(<Component>Child</Component>);  
});",component.spec.tsx,https://playwright.dev/docs/test-components,wait_strategy
javascript,"import { test, expect } from '@playwright/experimental-ct-react';  
import type { HooksConfig } from '../playwright';  
import { ProductsPage } from './pages/ProductsPage';  
  
test('configure routing through hooks config', async ({ page, mount }) => {  
  const component = await mount<HooksConfig>(<ProductsPage />, {  
    hooksConfig: { enableRouting: true },  
  });  
  await expect(component.getByRole('link')).toHaveAttribute('href', '/products/42');  
});",src/pages/ProductsPage.spec.tsx,https://playwright.dev/docs/test-components,assertion
javascript,"import { test, expect } from '@playwright/experimental-ct-vue';  
import type { HooksConfig } from '../playwright';  
import ProductsPage from './pages/ProductsPage.vue';  
  
test('configure routing through hooks config', async ({ page, mount }) => {  
  const component = await mount<HooksConfig>(ProductsPage, {  
    hooksConfig: { enableRouting: true },  
  });  
  await expect(component.getByRole('link')).toHaveAttribute('href', '/products/42');  
});",src/pages/ProductsPage.spec.ts,https://playwright.dev/docs/test-components,assertion
javascript,"import { test } from '@playwright/experimental-ct-react';  
  
test('unmount', async ({ mount }) => {  
  const component = await mount(<Component/>);  
  await component.unmount();  
});",component.spec.tsx,https://playwright.dev/docs/test-components,wait_strategy
javascript,"import { test } from '@playwright/experimental-ct-svelte';  
  
test('unmount', async ({ mount }) => {  
  const component = await mount(Component);  
  await component.unmount();  
});",component.spec.ts,https://playwright.dev/docs/test-components,wait_strategy
javascript,"import { test } from '@playwright/experimental-ct-vue';  
  
test('unmount', async ({ mount }) => {  
  const component = await mount(Component);  
  await component.unmount();  
});",component.spec.ts,https://playwright.dev/docs/test-components,wait_strategy
javascript,"// Or alternatively, using the `jsx` style  
import { test } from '@playwright/experimental-ct-vue';  
  
test('unmount', async ({ mount }) => {  
  const component = await mount(<Component/>);  
  await component.unmount();  
});",component.spec.tsx,https://playwright.dev/docs/test-components,wait_strategy
javascript,"import { test } from '@playwright/experimental-ct-react';  
  
test('update', async ({ mount }) => {  
  const component = await mount(<Component/>);  
  await component.update(  
      <Component msg=""greetings"" onClick={() => {}}>Child</Component>  
  );  
});",component.spec.tsx,https://playwright.dev/docs/test-components,navigation
javascript,"import { test } from '@playwright/experimental-ct-svelte';  
  
test('update', async ({ mount }) => {  
  const component = await mount(Component);  
  await component.update({  
    props: { msg: 'greetings' },  
    on: { click() {} },  
    slots: { default: 'Child' }  
  });  
});",component.spec.ts,https://playwright.dev/docs/test-components,navigation
javascript,"import { test } from '@playwright/experimental-ct-vue';  
  
test('update', async ({ mount }) => {  
  const component = await mount(Component);  
  await component.update({  
    props: { msg: 'greetings' },  
    on: { click() {} },  
    slots: { default: 'Child' }  
  });  
});",component.spec.ts,https://playwright.dev/docs/test-components,navigation
javascript,"// Or alternatively, using the `jsx` style  
import { test } from '@playwright/experimental-ct-vue';  
  
test('update', async ({ mount }) => {  
  const component = await mount(<Component/>);  
  await component.update(  
      <Component msg=""greetings"" v-on:click={() => {}}>Child</Component>  
  );  
});",component.spec.tsx,https://playwright.dev/docs/test-components,navigation
javascript,"import { handlers } from '@src/mocks/handlers';  
  
test.beforeEach(async ({ router }) => {  
  // install common handlers before each test  
  await router.use(...handlers);  
});  
  
test('example test', async ({ mount }) => {  
  // test as usual, your handlers are active  
  // ...  
});",Here is an example of reusing your existing MSW handlers in the test.,https://playwright.dev/docs/test-components,wait_strategy
javascript,"import { http, HttpResponse } from 'msw';  
  
test('example test', async ({ mount, router }) => {  
  await router.use(http.get('/data', async ({ request }) => {  
    return HttpResponse.json({ value: 'mocked' });  
  }));  
  
  // test as usual, your handler is active  
  // ...  
});",You can also introduce a one-off handler for a specific test.,https://playwright.dev/docs/test-components,wait_strategy
javascript,"test('â€¦', async ({ mount, page, context }) => {  
  // â€¦  
});","Frequently asked questionsâ€‹ | What's the difference between `@playwright/test` and `@playwright/experimental-ct-{react,svelte,vue}`?â€‹",https://playwright.dev/docs/test-components,general
javascript,"import { test, expect } from '@playwright/experimental-ct-react';  
import HelloWorld from './HelloWorld';  
  
test.use({ viewport: { width: 500, height: 500 } });  
  
test('should work', async ({ mount }) => {  
  const component = await mount(<HelloWorld msg=""greetings"" />);  
  await expect(component).toContainText('Greetings');  
});  



import { test, expect } from '@playwright/experimental-ct-vue';  
import HelloWorld from './HelloWorld.vue';  
  
test.use({ viewport: { width: 500, height: 500 } });  
  
test('should work', async ({ mount }) => {  
  const component = await mount(HelloWorld, {  
    props: {  
      msg: 'Greetings',  
    },  
  });  
  await expect(component).toContainText('Greetings');  
});  



import { test, expect } from '@playwright/experimental-ct-svelte';  
import HelloWorld from './HelloWorld.svelte';  
  
test.use({ viewport: { width: 500, height: 500 } });  
  
test('should work', async ({ mount }) => {  
  const component = await mount(HelloWorld, {  
    props: {  
      msg: 'Greetings',  
    },  
  });  
  await expect(component).toContainText('Greetings');  
});",Vue,https://playwright.dev/docs/test-components,assertion
javascript,"import { defineConfig, devices } from '@playwright/experimental-ct-vue';  
  
import { resolve } from 'path';  
import vue from '@vitejs/plugin-vue';  
import AutoImport from 'unplugin-auto-import/vite';  
import Components from 'unplugin-vue-components/vite';  
  
export default defineConfig({  
  testDir: './tests/component',  
  use: {  
    trace: 'on-first-retry',  
    ctViteConfig: {  
      plugins: [  
        vue(),  
        AutoImport({  
          imports: [  
            'vue',  
            'vue-router',  
            '@vueuse/head',  
            'pinia',  
            {  
              '@/store': ['useStore'],  
            },  
          ],  
          dts: 'src/auto-imports.d.ts',  
          eslintrc: {  
            enabled: true,  
          },  
        }),  
        Components({  
          dirs: ['src/components'],  
          extensions: ['vue'],  
        }),  
      ],  
      resolve: {  
        alias: {  
          '@': resolve(__dirname, './src'),  
        },  
      },  
    },  
  },  
});","You can specify plugins via Vite config for testing settings. Note that once you start specifying plugins, you are responsible for specifying the framework plugin as well, `vue()` in this case:",https://playwright.dev/docs/test-components,general
javascript,"import { test, expect } from '@playwright/experimental-ct-vue';  
import type { HooksConfig } from '../playwright';  
import Store from './Store.vue';  
  
test('override initialState ', async ({ mount }) => {  
  const component = await mount<HooksConfig>(Store, {  
    hooksConfig: {  
      store: { name: 'override initialState' }  
    }  
  });  
  await expect(component).toContainText('override initialState');  
});",src/pinia.spec.ts,https://playwright.dev/docs/test-components,assertion
javascript,"import { defineConfig, devices } from '@playwright/test';  
  
export default defineConfig({  
  // Look for test files in the ""tests"" directory, relative to this configuration file.  
  testDir: 'tests',  
  
  // Run all tests in parallel.  
  fullyParallel: true,  
  
  // Fail the build on CI if you accidentally left test.only in the source code.  
  forbidOnly: !!process.env.CI,  
  
  // Retry on CI only.  
  retries: process.env.CI ? 2 : 0,  
  
  // Opt out of parallel tests on CI.  
  workers: process.env.CI ? 1 : undefined,  
  
  // Reporter to use  
  reporter: 'html',  
  
  use: {  
    // Base URL to use in actions like `await page.goto('/')`.  
    baseURL: 'http://127.0.0.1:3000',  
  
    // Collect trace when retrying the failed test.  
    trace: 'on-first-retry',  
  },  
  // Configure projects for major browsers.  
  projects: [  
    {  
      name: 'chromium',  
      use: { ...devices['Desktop Chrome'] },  
    },  
  ],  
  // Run your local dev server before starting the tests.  
  webServer: {  
    command: 'npm run start',  
    url: 'http://127.0.0.1:3000',  
    reuseExistingServer: !process.env.CI,  
  },  
});",Basic Configurationâ€‹ | Here are some of the most common configuration options.,https://playwright.dev/docs/test-configuration,navigation
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  // Glob patterns or regular expressions to ignore test files.  
  testIgnore: '*test-assets',  
  
  // Glob patterns or regular expressions that match test files.  
  testMatch: '*todo-tests/*.spec.ts',  
});",Filter tests by glob patterns or regular expressions. | playwright.config.ts,https://playwright.dev/docs/test-configuration,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  // Folder for test artifacts such as screenshots, videos, traces, etc.  
  outputDir: 'test-results',  
  
  // path to the global setup files.  
  globalSetup: require.resolve('./global-setup'),  
  
  // path to the global teardown files.  
  globalTeardown: require.resolve('./global-teardown'),  
  
  // Each test is given 30 seconds.  
  timeout: 30000,  
  
});",Advanced Configurationâ€‹ | playwright.config.ts,https://playwright.dev/docs/test-configuration,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  expect: {  
    // Maximum time expect() should wait for the condition to be met.  
    timeout: 5000,  
  
    toHaveScreenshot: {  
      // An acceptable amount of pixels that could be different, unset by default.  
      maxDiffPixels: 10,  
    },  
  
    toMatchSnapshot: {  
      // An acceptable ratio of pixels that are different to the  
      // total amount of pixels, between 0 and 1.  
      maxDiffPixelRatio: 0.1,  
    },  
  },  
  
});",Configuration for the expect assertion library. | playwright.config.ts,https://playwright.dev/docs/test-configuration,assertion
javascript,"import { test, expect } from '@playwright/test';  
  
test('basic test', async ({ page }) => {  
  await page.goto('https://playwright.dev/');  
  
  await expect(page).toHaveTitle(/Playwright/);  
});",Built-in fixturesâ€‹ | You have already used test fixtures in your first test.,https://playwright.dev/docs/test-fixtures,assertion
javascript,"import type { Page, Locator } from '@playwright/test';  
  
export class TodoPage {  
  private readonly inputBox: Locator;  
  private readonly todoItems: Locator;  
  
  constructor(public readonly page: Page) {  
    this.inputBox = this.page.locator('input.new-todo');  
    this.todoItems = this.page.getByTestId('todo-item');  
  }  
  
  async goto() {  
    await this.page.goto('https://demo.playwright.dev/todomvc/');  
  }  
  
  async addToDo(text: string) {  
    await this.inputBox.fill(text);  
    await this.inputBox.press('Enter');  
  }  
  
  async remove(text: string) {  
    const todo = this.todoItems.filter({ hasText: text });  
    await todo.hover();  
    await todo.getByLabel('Delete').click();  
  }  
  
  async removeAll() {  
    while ((await this.todoItems.count()) > 0) {  
      await this.todoItems.first().hover();  
      await this.todoItems.getByLabel('Delete').first().click();  
    }  
  }  
}",Click to expand the code for the `TodoPage` | todo-page.ts,https://playwright.dev/docs/test-fixtures,page_object
javascript,"const { test } = require('@playwright/test');  
const { TodoPage } = require('./todo-page');  
  
test.describe('todo tests', () => {  
  let todoPage;  
  
  test.beforeEach(async ({ page }) => {  
    todoPage = new TodoPage(page);  
    await todoPage.goto();  
    await todoPage.addToDo('item1');  
    await todoPage.addToDo('item2');  
  });  
  
  test.afterEach(async () => {  
    await todoPage.removeAll();  
  });  
  
  test('should add an item', async () => {  
    await todoPage.addToDo('my item');  
    // ...  
  });  
  
  test('should remove an item', async () => {  
    await todoPage.remove('item1');  
    // ...  
  });  
});",todo.spec.ts,https://playwright.dev/docs/test-fixtures,assertion
javascript,"import type { Page, Locator } from '@playwright/test';  
  
export class TodoPage {  
  private readonly inputBox: Locator;  
  private readonly todoItems: Locator;  
  
  constructor(public readonly page: Page) {  
    this.inputBox = this.page.locator('input.new-todo');  
    this.todoItems = this.page.getByTestId('todo-item');  
  }  
  
  async goto() {  
    await this.page.goto('https://demo.playwright.dev/todomvc/');  
  }  
  
  async addToDo(text: string) {  
    await this.inputBox.fill(text);  
    await this.inputBox.press('Enter');  
  }  
  
  async remove(text: string) {  
    const todo = this.todoItems.filter({ hasText: text });  
    await todo.hover();  
    await todo.getByLabel('Delete').click();  
  }  
  
  async removeAll() {  
    while ((await this.todoItems.count()) > 0) {  
      await this.todoItems.first().hover();  
      await this.todoItems.getByLabel('Delete').first().click();  
    }  
  }  
}",Click to expand the code for the `TodoPage` | todo-page.ts,https://playwright.dev/docs/test-fixtures,page_object
javascript,"import { test as base } from '@playwright/test';  
import { TodoPage } from './todo-page';  
  
// Extend basic test by providing a ""todoPage"" fixture.  
const test = base.extend<{ todoPage: TodoPage }>({  
  todoPage: async ({ page }, use) => {  
    const todoPage = new TodoPage(page);  
    await todoPage.goto();  
    await todoPage.addToDo('item1');  
    await todoPage.addToDo('item2');  
    await use(todoPage);  
    await todoPage.removeAll();  
  },  
});  
  
test('should add an item', async ({ todoPage }) => {  
  await todoPage.addToDo('my item');  
  // ...  
});  
  
test('should remove an item', async ({ todoPage }) => {  
  await todoPage.remove('item1');  
  // ...  
});",example.spec.ts,https://playwright.dev/docs/test-fixtures,fixture
javascript,"import type { Page, Locator } from '@playwright/test';  
  
export class TodoPage {  
  private readonly inputBox: Locator;  
  private readonly todoItems: Locator;  
  
  constructor(public readonly page: Page) {  
    this.inputBox = this.page.locator('input.new-todo');  
    this.todoItems = this.page.getByTestId('todo-item');  
  }  
  
  async goto() {  
    await this.page.goto('https://demo.playwright.dev/todomvc/');  
  }  
  
  async addToDo(text: string) {  
    await this.inputBox.fill(text);  
    await this.inputBox.press('Enter');  
  }  
  
  async remove(text: string) {  
    const todo = this.todoItems.filter({ hasText: text });  
    await todo.hover();  
    await todo.getByLabel('Delete').click();  
  }  
  
  async removeAll() {  
    while ((await this.todoItems.count()) > 0) {  
      await this.todoItems.first().hover();  
      await this.todoItems.getByLabel('Delete').first().click();  
    }  
  }  
}",Click to expand the code for the `TodoPage` and `SettingsPage` | todo-page.ts,https://playwright.dev/docs/test-fixtures,page_object
javascript,"import type { Page } from '@playwright/test';  
  
export class SettingsPage {  
  constructor(public readonly page: Page) {  
  }  
  
  async switchToDarkMode() {  
    // ...  
  }  
}",SettingsPage is similar: | settings-page.ts,https://playwright.dev/docs/test-fixtures,page_object
javascript,"import { test as base } from '@playwright/test';  
import { TodoPage } from './todo-page';  
import { SettingsPage } from './settings-page';  
  
// Declare the types of your fixtures.  
type MyFixtures = {  
  todoPage: TodoPage;  
  settingsPage: SettingsPage;  
};  
  
// Extend base test by providing ""todoPage"" and ""settingsPage"".  
// This new ""test"" can be used in multiple test files, and each of them will get the fixtures.  
export const test = base.extend<MyFixtures>({  
  todoPage: async ({ page }, use) => {  
    // Set up the fixture.  
    const todoPage = new TodoPage(page);  
    await todoPage.goto();  
    await todoPage.addToDo('item1');  
    await todoPage.addToDo('item2');  
  
    // Use the fixture value in the test.  
    await use(todoPage);  
  
    // Clean up the fixture.  
    await todoPage.removeAll();  
  },  
  
  settingsPage: async ({ page }, use) => {  
    await use(new SettingsPage(page));  
  },  
});  
export { expect } from '@playwright/test';",my-test.ts,https://playwright.dev/docs/test-fixtures,fixture
javascript,"import { test, expect } from './my-test';  
  
test.beforeEach(async ({ settingsPage }) => {  
  await settingsPage.switchToDarkMode();  
});  
  
test('basic test', async ({ todoPage, page }) => {  
  await todoPage.addToDo('something nice');  
  await expect(page.getByTestId('todo-title')).toContainText(['something nice']);  
});","Just mention fixture in your test function argument, and test runner will take care of it. Fixtures are also available in hooks and other fixtures. If you use TypeScript, fixtures will have the right type. | Below we use the `todoPage` and `settingsPage` fixtures defined above.",https://playwright.dev/docs/test-fixtures,assertion
javascript,"import { test as base } from '@playwright/test';  
  
export const test = base.extend({  
  page: async ({ baseURL, page }, use) => {  
    await page.goto(baseURL);  
    await use(page);  
  },  
});","Overriding fixturesâ€‹ | In addition to creating your own fixtures, you can also override existing fixtures to fit your needs. Consider the following example which overrides the `page` fixture by automatically navigating to some `baseURL`:",https://playwright.dev/docs/test-fixtures,navigation
javascript,"import { test as base } from '@playwright/test';  
  
export const test = base.extend({  
  storageState: async ({}, use) => {  
    const cookie = await getAuthCookie();  
    await use({ cookies: [cookie] });  
  },  
});","Fixtures can also be overridden where the base fixture is completely replaced with something different. For example, we could override the [testOptions.storageState](/docs/api/class-testoptions#test-options-storage-state) fixture to provide our own data.",https://playwright.dev/docs/test-fixtures,wait_strategy
javascript,"import { test as base } from '@playwright/test';  
  
type Account = {  
  username: string;  
  password: string;  
};  
  
// Note that we pass worker fixture types as a second template parameter.  
export const test = base.extend<{}, { account: Account }>({  
  account: [async ({ browser }, use, workerInfo) => {  
    // Unique username.  
    const username = 'user' + workerInfo.workerIndex;  
    const password = 'verysecure';  
  
    // Create the account with Playwright.  
    const page = await browser.newPage();  
    await page.goto('/signup');  
    await page.getByLabel('User Name').fill(username);  
    await page.getByLabel('Password').fill(password);  
    await page.getByText('Sign up').click();  
    // Make sure everything is ok.  
    await expect(page.getByTestId('result')).toHaveText('Success');  
    // Do not forget to cleanup.  
    await page.close();  
  
    // Use the account value.  
    await use({ username, password });  
  }, { scope: 'worker' }],  
  
  page: async ({ page, account }, use) => {  
    // Sign in with our account.  
    const { username, password } = account;  
    await page.goto('/signin');  
    await page.getByLabel('User Name').fill(username);  
    await page.getByLabel('Password').fill(password);  
    await page.getByText('Sign in').click();  
    await expect(page.getByTestId('userinfo')).toHaveText(username);  
  
    // Use signed-in page in the test.  
    await use(page);  
  },  
});  
export { expect } from '@playwright/test';","Below we'll create an `account` fixture that will be shared by all tests in the same worker, and override the `page` fixture to login into this account for each test. To generate unique accounts, we'll use the [workerInfo.workerIndex](/docs/api/class-workerinfo#worker-info-worker-index) that is available to any test or fixture. Note the tuple-like syntax for the worker fixture - we have to pass `{scope: 'worker'}` so that test runner sets up this fixture once per worker. | my-test.ts",https://playwright.dev/docs/test-fixtures,fixture
javascript,"import * as debug from 'debug';  
import * as fs from 'fs';  
import { test as base } from '@playwright/test';  
  
export const test = base.extend<{ saveLogs: void }>({  
  saveLogs: [async ({}, use, testInfo) => {  
    // Collecting logs during the test.  
    const logs = [];  
    debug.log = (...args) => logs.push(args.map(String).join(''));  
    debug.enable('myserver');  
  
    await use();  
  
    // After the test we can check whether the test passed or failed.  
    if (testInfo.status !== testInfo.expectedStatus) {  
      // outputPath() API guarantees a unique file name.  
      const logFile = testInfo.outputPath('logs.txt');  
      await fs.promises.writeFile(logFile, logs.join('\n'), 'utf8');  
      testInfo.attachments.push({ name: 'logs', contentType: 'text/plain', path: logFile });  
    }  
  }, { auto: true }],  
});  
export { expect } from '@playwright/test';","Here is an example fixture that automatically attaches debug logs when the test fails, so we can later review the logs in the reporter. Note how it uses [TestInfo](/docs/api/class-testinfo ""TestInfo"") object that is available in each test/fixture to retrieve metadata about the test being run. | my-test.ts",https://playwright.dev/docs/test-fixtures,assertion
javascript,"import { test as base, expect } from '@playwright/test';  
  
const test = base.extend<{ slowFixture: string }>({  
  slowFixture: [async ({}, use) => {  
    // ... perform a slow operation ...  
    await use('hello');  
  }, { timeout: 60000 }]  
});  
  
test('example test', async ({ slowFixture }) => {  
  // ...  
});","Fixture timeoutâ€‹ | By default, fixture shares timeout with the test. However, for slow fixtures, especially worker-scoped ones, it is convenient to have a separate timeout. This way you can keep the overall test timeout small, and give the slow fixture more time.",https://playwright.dev/docs/test-fixtures,fixture
javascript,"import type { Page, Locator } from '@playwright/test';  
  
export class TodoPage {  
  private readonly inputBox: Locator;  
  private readonly todoItems: Locator;  
  
  constructor(public readonly page: Page) {  
    this.inputBox = this.page.locator('input.new-todo');  
    this.todoItems = this.page.getByTestId('todo-item');  
  }  
  
  async goto() {  
    await this.page.goto('https://demo.playwright.dev/todomvc/');  
  }  
  
  async addToDo(text: string) {  
    await this.inputBox.fill(text);  
    await this.inputBox.press('Enter');  
  }  
  
  async remove(text: string) {  
    const todo = this.todoItems.filter({ hasText: text });  
    await todo.hover();  
    await todo.getByLabel('Delete').click();  
  }  
  
  async removeAll() {  
    while ((await this.todoItems.count()) > 0) {  
      await this.todoItems.first().hover();  
      await this.todoItems.getByLabel('Delete').first().click();  
    }  
  }  
}",Click to expand the code for the `TodoPage` | todo-page.ts,https://playwright.dev/docs/test-fixtures,page_object
javascript,"import { test as base } from '@playwright/test';  
import { TodoPage } from './todo-page';  
  
// Declare your options to type-check your configuration.  
export type MyOptions = {  
  defaultItem: string;  
};  
type MyFixtures = {  
  todoPage: TodoPage;  
};  
  
// Specify both option and fixture types.  
export const test = base.extend<MyOptions & MyFixtures>({  
  // Define an option and provide a default value.  
  // We can later override it in the config.  
  defaultItem: ['Something nice', { option: true }],  
  
  // Our ""todoPage"" fixture depends on the option.  
  todoPage: async ({ page, defaultItem }, use) => {  
    const todoPage = new TodoPage(page);  
    await todoPage.goto();  
    await todoPage.addToDo(defaultItem);  
    await use(todoPage);  
    await todoPage.removeAll();  
  },  
});  
export { expect } from '@playwright/test';",my-test.ts,https://playwright.dev/docs/test-fixtures,fixture
javascript,"import { defineConfig } from '@playwright/test';  
import type { MyOptions } from './my-test';  
  
export default defineConfig<MyOptions>({  
  projects: [  
    {  
      name: 'shopping',  
      use: { defaultItem: 'Buy milk' },  
    },  
    {  
      name: 'wellbeing',  
      use: { defaultItem: 'Exercise!' },  
    },  
  ]  
});","We can now use `todoPage` fixture as usual, and set the `defaultItem` option in the config file. | playwright.config.ts",https://playwright.dev/docs/test-fixtures,form_interaction
javascript,"type Person = { name: string };  
const test = base.extend<{ persons: Person[] }>({  
  // Declare the option, default value is an empty array.  
  persons: [[], { option: true }],  
});  
  
// Option value is an array of persons.  
const actualPersons = [{ name: 'Alice' }, { name: 'Bob' }];  
test.use({  
  // CORRECT: Wrap the value into an array and pass the scope.  
  persons: [actualPersons, { scope: 'test' }],  
});  
  
test.use({  
  // WRONG: passing an array value directly will not work.  
  persons: actualPersons,  
});","**Array as an option value** | If the value of your option is an array, for example `[{ name: 'Alice' }, { name: 'Bob' }]`, you'll need to wrap it into an extra array when providing the value. This is best illustrated with an example.",https://playwright.dev/docs/test-fixtures,form_interaction
javascript,"import { test as base } from '@playwright/test';  
  
const test = base.extend<{  
  testFixture: string,  
  autoTestFixture: string,  
  unusedFixture: string,  
}, {  
  workerFixture: string,  
  autoWorkerFixture: string,  
}>({  
  workerFixture: [async ({ browser }) => {  
    // workerFixture setup...  
    await use('workerFixture');  
    // workerFixture teardown...  
  }, { scope: 'worker' }],  
  
  autoWorkerFixture: [async ({ browser }) => {  
    // autoWorkerFixture setup...  
    await use('autoWorkerFixture');  
    // autoWorkerFixture teardown...  
  }, { scope: 'worker', auto: true }],  
  
  testFixture: [async ({ page, workerFixture }) => {  
    // testFixture setup...  
    await use('testFixture');  
    // testFixture teardown...  
  }, { scope: 'test' }],  
  
  autoTestFixture: [async () => {  
    // autoTestFixture setup...  
    await use('autoTestFixture');  
    // autoTestFixture teardown...  
  }, { scope: 'test', auto: true }],  
  
  unusedFixture: [async ({ page }) => {  
    // unusedFixture setup...  
    await use('unusedFixture');  
    // unusedFixture teardown...  
  }, { scope: 'test' }],  
});  
  
test.beforeAll(async () => { /* ... */ });  
test.beforeEach(async ({ page }) => { /* ... */ });  
test('first test', async ({ page }) => { /* ... */ });  
test('second test', async ({ testFixture }) => { /* ... */ });  
test.afterEach(async () => { /* ... */ });  
test.afterAll(async () => { /* ... */ });",Consider the following example:,https://playwright.dev/docs/test-fixtures,fixture
javascript,"import { mergeTests } from '@playwright/test';  
import { test as dbTest } from 'database-test-utils';  
import { test as a11yTest } from 'a11y-test-utils';  
  
export const test = mergeTests(dbTest, a11yTest);",You can merge test fixtures from multiple files or modules: | fixtures.ts,https://playwright.dev/docs/test-fixtures,general
javascript,"import { test } from './fixtures';  
  
test('passes', async ({ database, page, a11y }) => {  
  // use database and a11y fixtures.  
});",test.spec.ts,https://playwright.dev/docs/test-fixtures,fixture
javascript,"import { test as base } from '@playwright/test';  
  
export const test = base.extend({  
  helperFixture: [async ({}, use, testInfo) => {  
    // ...  
  }, { box: true }],  
});","Box fixturesâ€‹ | Usually, custom fixtures are reported as separate steps in in the UI mode, Trace Viewer and various test reports. They also appear in error messages from the test runner. For frequently-used fixtures, this can mean lots of noise. You can stop the fixtures steps from being shown in the UI by ""boxing"" it.",https://playwright.dev/docs/test-fixtures,fixture
javascript,"import { test as base } from '@playwright/test';  
  
export const test = base.extend({  
  innerFixture: [async ({}, use, testInfo) => {  
    // ...  
  }, { title: 'my fixture' }],  
});","Custom fixture titleâ€‹ | Instead of the usual fixture name, you can give fixtures a custom title that will be shown in test reports and error messages.",https://playwright.dev/docs/test-fixtures,fixture
javascript,"import { test as base } from '@playwright/test';  
  
export const test = base.extend<{ forEachTest: void }>({  
  forEachTest: [async ({ page }, use) => {  
    // This code runs before every test.  
    await page.goto('http://localhost:8000');  
    await use();  
    // This code runs after every test.  
    console.log('Last URL:', page.url());  
  }, { auto: true }],  // automatically starts for every test.  
});","[test.beforeEach()](/docs/api/class-test#test-before-each) and [test.afterEach()](/docs/api/class-test#test-after-each) hooks run before/after each test declared in the same file and same [test.describe()](/docs/api/class-test#test-describe) block (if any). If you want to declare hooks that run before/after each test globally, you can declare them as auto fixtures like this: | fixtures.ts",https://playwright.dev/docs/test-fixtures,navigation
javascript,"import { test } from './fixtures';  
import { expect } from '@playwright/test';  
  
test('basic', async ({ page }) => {  
  expect(page).toHaveURL('http://localhost:8000');  
  await page.goto('https://playwright.dev');  
});",And then import the fixtures in all your tests: | mytest.spec.ts,https://playwright.dev/docs/test-fixtures,fixture
javascript,"import { test as base } from '@playwright/test';  
  
export const test = base.extend<{}, { forEachWorker: void }>({  
  forEachWorker: [async ({}, use) => {  
    // This code runs before all the tests in the worker process.  
    console.log(`Starting test worker ${test.info().workerIndex}`);  
    await use();  
    // This code runs after all the tests in the worker process.  
    console.log(`Stopping test worker ${test.info().workerIndex}`);  
  }, { scope: 'worker', auto: true }],  // automatically starts for every worker.  
});","[test.beforeAll()](/docs/api/class-test#test-before-all) and [test.afterAll()](/docs/api/class-test#test-after-all) hooks run before/after all tests declared in the same file and same [test.describe()](/docs/api/class-test#test-describe) block (if any), once per worker process. If you want to declare hooks that run before/after all tests in every file, you can declare them as auto fixtures with `scope: 'worker'` as follows: | fixtures.ts",https://playwright.dev/docs/test-fixtures,wait_strategy
javascript,"import { test } from './fixtures';  
import { expect } from '@playwright/test';  
  
test('basic', async ({ }) => {  
  // ...  
});",And then import the fixtures in all your tests: | mytest.spec.ts,https://playwright.dev/docs/test-fixtures,fixture
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  testDir: './tests',  
  // ...  
  projects: [  
    {  
      name: 'setup db',  
      testMatch: /global\.setup\.ts/,  
    },  
    // {  
    //   other project  
    // }  
  ]  
});",First we add a new project with the name 'setup db'. We then give it a [testProject.testMatch](/docs/api/class-testproject#test-project-test-match) property in order to match the file called `global.setup.ts`: | playwright.config.ts,https://playwright.dev/docs/test-global-setup-teardown,general
javascript,"import { defineConfig, devices } from '@playwright/test';  
  
export default defineConfig({  
  testDir: './tests',  
  // ...  
  projects: [  
    {  
      name: 'setup db',  
      testMatch: /global\.setup\.ts/,  
    },  
    {  
      name: 'chromium with db',  
      use: { ...devices['Desktop Chrome'] },  
      dependencies: ['setup db'],  
    },  
  ]  
});","Then we add the [testProject.dependencies](/docs/api/class-testproject#test-project-dependencies) property to our projects that depend on the setup project and pass into the array the name of our dependency project, which we defined in the previous step: | playwright.config.ts",https://playwright.dev/docs/test-global-setup-teardown,general
javascript,"import { test as setup } from '@playwright/test';  
  
setup('create new database', async ({ }) => {  
  console.log('creating new database...');  
  // Initialize the database  
});","In this example the 'chromium with db' project depends on the 'setup db' project. We then create a setup test, stored at root level of your project (note that setup and teardown code must be defined as regular tests by calling [test()](/docs/api/class-test#test-call) function): | tests/global.setup.ts",https://playwright.dev/docs/test-global-setup-teardown,general
javascript,"import { test, expect } from '@playwright/test';  
  
test('menu', async ({ page }) => {  
  // Your test that depends on the database  
});",tests/menu.spec.ts,https://playwright.dev/docs/test-global-setup-teardown,assertion
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  testDir: './tests',  
  // ...  
  projects: [  
    {  
      name: 'setup db',  
      testMatch: /global\.setup\.ts/,  
      teardown: 'cleanup db',  
    },  
    {  
      name: 'cleanup db',  
      testMatch: /global\.teardown\.ts/,  
    },  
    {  
      name: 'chromium',  
      use: { ...devices['Desktop Chrome'] },  
      dependencies: ['setup db'],  
    },  
  ]  
});",First we add the [testProject.teardown](/docs/api/class-testproject#test-project-teardown) property to our setup project with the name 'cleanup db' which is the name we gave to our teardown project in the previous step: | playwright.config.ts,https://playwright.dev/docs/test-global-setup-teardown,general
javascript,"import { test as teardown } from '@playwright/test';  
  
teardown('delete database', async ({ }) => {  
  console.log('deleting test database...');  
  // Delete the database  
});",Then we create a `global.teardown.ts` file in the tests directory of your project. This will be used to delete the data from the database after all tests have run. | tests/global.teardown.ts,https://playwright.dev/docs/test-global-setup-teardown,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  globalSetup: require.resolve('./global-setup'),  
  globalTeardown: require.resolve('./global-teardown'),  
});","Using `globalSetup` and `globalTeardown` will not produce traces or artifacts, and options like `headless` or `testIdAttribute` specified in the config file are not applied. If you want to produce traces and artifacts and respect config options, use project dependencies. | playwright.config.ts",https://playwright.dev/docs/test-global-setup-teardown,general
javascript,"import { chromium, type FullConfig } from '@playwright/test';  
  
async function globalSetup(config: FullConfig) {  
  const { baseURL, storageState } = config.projects[0].use;  
  const browser = await chromium.launch();  
  const page = await browser.newPage();  
  await page.goto(baseURL!);  
  await page.getByLabel('User Name').fill('user');  
  await page.getByLabel('Password').fill('password');  
  await page.getByText('Sign in').click();  
  await page.context().storageState({ path: storageState as string });  
  await browser.close();  
}  
  
export default globalSetup;",Here is a global setup example that authenticates once and reuses authentication state in tests. It uses the `baseURL` and `storageState` options from the configuration file. | global-setup.ts,https://playwright.dev/docs/test-global-setup-teardown,navigation
javascript,"import { defineConfig } from '@playwright/test';  
export default defineConfig({  
  globalSetup: require.resolve('./global-setup'),  
  use: {  
    baseURL: 'http://localhost:3000/',  
    storageState: 'state.json',  
  },  
});","Specify `globalSetup`, `baseURL` and `storageState` in the configuration file. | playwright.config.ts",https://playwright.dev/docs/test-global-setup-teardown,general
javascript,"import { test } from '@playwright/test';  
  
test('test', async ({ page }) => {  
  await page.goto('/');  
  // You are signed in!  
});",Tests start already authenticated because we specify `storageState` that was populated by global setup.,https://playwright.dev/docs/test-global-setup-teardown,navigation
javascript,"import type { FullConfig } from '@playwright/test';  
  
async function globalSetup(config: FullConfig) {  
  process.env.FOO = 'some data';  
  // Or a more complicated data structure as JSON:  
  process.env.BAR = JSON.stringify({ some: 'data' });  
}  
  
export default globalSetup;",You can make arbitrary data available in your tests from your global setup file by setting them as environment variables via `process.env`. | global-setup.ts,https://playwright.dev/docs/test-global-setup-teardown,form_interaction
javascript,"import { test } from '@playwright/test';  
  
test('test', async ({ page }) => {  
  // environment variables which are set in globalSetup are only available inside test().  
  const { FOO, BAR } = process.env;  
  
  // FOO and BAR properties are populated.  
  expect(FOO).toEqual('some data');  
  
  const complexData = JSON.parse(BAR);  
  expect(BAR).toEqual({ some: 'data' });  
});",Tests have access to the `process.env` properties set in the global setup.,https://playwright.dev/docs/test-global-setup-teardown,assertion
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  // Limit the number of workers on CI, use default locally  
  workers: process.env.CI ? 2 : undefined,  
});",In the configuration file: | playwright.config.ts,https://playwright.dev/docs/test-parallel,general
javascript,"import { test } from '@playwright/test';  
  
test.describe.configure({ mode: 'parallel' });  
  
test('runs in parallel 1', async ({ page }) => { /* ... */ });  
test('runs in parallel 2', async ({ page }) => { /* ... */ });","By default, tests in a single file are run in order. If you have many independent tests in a single file, you might want to run them in parallel with [test.describe.configure()](/docs/api/class-test#test-describe-configure). | Note that parallel tests are executed in separate worker processes and cannot share any state or global variables. Each test executes all relevant hooks just for itself, including `beforeAll` and `afterAll`.",https://playwright.dev/docs/test-parallel,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  fullyParallel: true,  
});","Alternatively, you can opt-in all tests into this fully-parallel mode in the configuration file: | playwright.config.ts",https://playwright.dev/docs/test-parallel,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  // runs all tests in all files of a specific project in parallel  
  projects: [  
    {  
      name: 'chromium',  
      use: { ...devices['Desktop Chrome'] },  
      fullyParallel: true,  
    },  
  ]  
});",You can also opt in for fully-parallel mode for just a few projects: | playwright.config.ts,https://playwright.dev/docs/test-parallel,general
javascript,"import { test, type Page } from '@playwright/test';  
  
// Annotate entire file as serial.  
test.describe.configure({ mode: 'serial' });  
  
let page: Page;  
  
test.beforeAll(async ({ browser }) => {  
  page = await browser.newPage();  
});  
  
test.afterAll(async () => {  
  await page.close();  
});  
  
test('runs first', async () => {  
  await page.goto('https://playwright.dev/');  
});  
  
test('runs second', async () => {  
  await page.getByText('Get Started').click();  
});","note | Using serial is not recommended. It is usually better to make your tests isolated, so they can be run independently.",https://playwright.dev/docs/test-parallel,fixture
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  // Limit the number of failures on CI to save resources  
  maxFailures: process.env.CI ? 10 : undefined,  
});",Setting in the configuration file: | playwright.config.ts,https://playwright.dev/docs/test-parallel,general
javascript,"import { test as baseTest, expect } from '@playwright/test';  
// Import project utils for managing users in the test database.  
import { createUserInTestDatabase, deleteUserFromTestDatabase } from './my-db-utils';  
  
export * from '@playwright/test';  
export const test = baseTest.extend<{}, { dbUserName: string }>({  
  // Returns db user name unique for the worker.  
  dbUserName: [async ({ }, use) => {  
    // Use workerIndex as a unique identifier for each worker.  
    const userName = `user-${test.info().workerIndex}`;  
    // Initialize user in the database.  
    await createUserInTestDatabase(userName);  
    await use(userName);  
    // Clean up after the tests are done.  
    await deleteUserFromTestDatabase(userName);  
  }, { scope: 'worker' }],  
});",Create `playwright/fixtures.ts` file that will [create `dbUserName` fixture](/docs/test-fixtures#creating-a-fixture) and initialize a new user in the test database. Use [testInfo.workerIndex](/docs/api/class-testinfo#test-info-worker-index) to differentiate between workers. | playwright/fixtures.ts,https://playwright.dev/docs/test-parallel,assertion
javascript,"// Important: import our fixtures.  
import { test, expect } from '../playwright/fixtures';  
  
test('test', async ({ dbUserName }) => {  
  // Use the user name in the test.  
});","Now, each test file should import `test` from our fixtures file instead of `@playwright/test`. | tests/example.spec.ts",https://playwright.dev/docs/test-parallel,fixture
javascript,"import { test, expect } from '@playwright/test';  
  
export default function createTests() {  
  test('feature-a example test', async ({ page }) => {  
    // ... test goes here  
  });  
}","You can put your tests in helper functions in multiple files. Consider the following example where tests are not defined directly in the file, but rather in a wrapper function. | feature-a.spec.ts",https://playwright.dev/docs/test-parallel,assertion
javascript,"import { test, expect } from '@playwright/test';  
  
export default function createTests() {  
  test.use({ viewport: { width: 500, height: 500 } });  
  
  test('feature-b example test', async ({ page }) => {  
    // ... test goes here  
  });  
}",feature-b.spec.ts,https://playwright.dev/docs/test-parallel,assertion
javascript,"import { test } from '@playwright/test';  
import featureBTests from './feature-b.spec.ts';  
import featureATests from './feature-a.spec.ts';  
  
test.describe(featureBTests);  
test.describe(featureATests);","You can create a test list file that will control the order of tests - first run `feature-b` tests, then `feature-a` tests. Note how each test file is wrapped in a `test.describe()` block that calls the function where tests are defined. This way `test.use()` calls only affect tests from a single file. | test.list.ts",https://playwright.dev/docs/test-parallel,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  workers: 1,  
  testMatch: 'test.list.ts',  
});","Now **disable parallel execution** by setting workers to one, and specify your test list file. | playwright.config.ts",https://playwright.dev/docs/test-parallel,general
javascript,"[  
  { name: 'Alice', expected: 'Hello, Alice!' },  
  { name: 'Bob', expected: 'Hello, Bob!' },  
  { name: 'Charlie', expected: 'Hello, Charlie!' },  
].forEach(({ name, expected }) => {  
  // You can also do it with test.describe() or with multiple tests as long the test name is unique.  
  test(`testing with ${name}`, async ({ page }) => {  
    await page.goto(`https://example.com/greet?name=${name}`);  
    await expect(page.getByRole('heading')).toHaveText(expected);  
  });  
});",Parameterized Testsâ€‹ | example.spec.ts,https://playwright.dev/docs/test-parameterize,assertion
javascript,"test.beforeEach(async ({ page }) => {  
  // ...  
});  
  
test.afterEach(async ({ page }) => {  
  // ...  
});  
  
[  
  { name: 'Alice', expected: 'Hello, Alice!' },  
  { name: 'Bob', expected: 'Hello, Bob!' },  
  { name: 'Charlie', expected: 'Hello, Charlie!' },  
].forEach(({ name, expected }) => {  
  test(`testing with ${name}`, async ({ page }) => {  
    await page.goto(`https://example.com/greet?name=${name}`);  
    await expect(page.getByRole('heading')).toHaveText(expected);  
  });  
});","Most of the time you should put `beforeEach`, `beforeAll`, `afterEach` and `afterAll` hooks outside of `forEach`, so that hooks are executed just once: | example.spec.ts",https://playwright.dev/docs/test-parameterize,assertion
javascript,"[  
  { name: 'Alice', expected: 'Hello, Alice!' },  
  { name: 'Bob', expected: 'Hello, Bob!' },  
  { name: 'Charlie', expected: 'Hello, Charlie!' },  
].forEach(({ name, expected }) => {  
  test.describe(() => {  
    test.beforeEach(async ({ page }) => {  
      await page.goto(`https://example.com/greet?name=${name}`);  
    });  
    test(`testing with ${expected}`, async ({ page }) => {  
      await expect(page.getByRole('heading')).toHaveText(expected);  
    });  
  });  
});","If you want to have hooks for each test, you can put them inside a `describe()` \- so they are executed for each iteration / each individual test: | example.spec.ts",https://playwright.dev/docs/test-parameterize,assertion
javascript,"import { test as base } from '@playwright/test';  
  
export type TestOptions = {  
  person: string;  
};  
  
export const test = base.extend<TestOptions>({  
  // Define an option and provide a default value.  
  // We can later override it in the config.  
  person: ['John', { option: true }],  
});",my-test.ts,https://playwright.dev/docs/test-parameterize,form_interaction
javascript,"const base = require('@playwright/test');  
  
exports.test = base.test.extend({  
  // Define an option and provide a default value.  
  // We can later override it in the config.  
  person: ['John', { option: true }],  
});",my-test.js,https://playwright.dev/docs/test-parameterize,general
javascript,"import { test } from './my-test';  
  
test('test 1', async ({ page, person }) => {  
  await page.goto(`/index.html`);  
  await expect(page.locator('#node')).toContainText(person);  
  // ...  
});","We can use this option in the test, similarly to [fixtures](/docs/test-fixtures). | example.spec.ts",https://playwright.dev/docs/test-parameterize,assertion
javascript,"import { defineConfig } from '@playwright/test';  
import type { TestOptions } from './my-test';  
  
export default defineConfig<TestOptions>({  
  projects: [  
    {  
      name: 'alice',  
      use: { person: 'Alice' },  
    },  
    {  
      name: 'bob',  
      use: { person: 'Bob' },  
    },  
  ]  
});",playwright.config.ts,https://playwright.dev/docs/test-parameterize,form_interaction
javascript,"import { test as base } from '@playwright/test';  
  
export type TestOptions = {  
  person: string;  
};  
  
export const test = base.extend<TestOptions>({  
  // Define an option and provide a default value.  
  // We can later override it in the config.  
  person: ['John', { option: true }],  
  
  // Override default ""page"" fixture.  
  page: async ({ page, person }, use) => {  
    await page.goto('/chat');  
    // We use ""person"" parameter as a ""name"" for the chat room.  
    await page.getByLabel('User Name').fill(person);  
    await page.getByText('Enter chat room').click();  
    // Each test will get a ""page"" that already has the person name.  
    await use(page);  
  },  
});",my-test.ts,https://playwright.dev/docs/test-parameterize,fixture
javascript,"const base = require('@playwright/test');  
  
exports.test = base.test.extend({  
  // Define an option and provide a default value.  
  // We can later override it in the config.  
  person: ['John', { option: true }],  
  
  // Override default ""page"" fixture.  
  page: async ({ page, person }, use) => {  
    await page.goto('/chat');  
    // We use ""person"" parameter as a ""name"" for the chat room.  
    await page.getByLabel('User Name').fill(person);  
    await page.getByText('Enter chat room').click();  
    // Each test will get a ""page"" that already has the person name.  
    await use(page);  
  },  
});",my-test.js,https://playwright.dev/docs/test-parameterize,fixture
javascript,"test(`example test`, async ({ page }) => {  
  // ...  
  await page.getByLabel('User Name').fill(process.env.USER_NAME);  
  await page.getByLabel('Password').fill(process.env.PASSWORD);  
});","For example, consider the following test file that needs a username and a password. It is usually a good idea not to store your secrets in the source code, so we'll need a way to pass secrets from outside. | example.spec.ts",https://playwright.dev/docs/test-parameterize,form_interaction
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  use: {  
    baseURL: process.env.STAGING === '1' ? 'http://staging.example.test/' : 'http://example.test/',  
  }  
});","Similarly, configuration file can also read environment variables passed through the command line. | playwright.config.ts",https://playwright.dev/docs/test-parameterize,general
javascript,"import { defineConfig } from '@playwright/test';  
import dotenv from 'dotenv';  
import path from 'path';  
  
// Read from "".env"" file.  
dotenv.config({ path: path.resolve(__dirname, '.env') });  
  
// Alternatively, read from ""../my.env"" file.  
dotenv.config({ path: path.resolve(__dirname, '..', 'my.env') });  
  
export default defineConfig({  
  use: {  
    baseURL: process.env.STAGING === '1' ? 'http://staging.example.test/' : 'http://example.test/',  
  }  
});","To make environment variables easier to manage, consider something like `.env` files. Here is an example that uses [`dotenv`](https://www.npmjs.com/package/dotenv) package to read environment variables directly in the configuration file. | playwright.config.ts",https://playwright.dev/docs/test-parameterize,general
javascript,"import { defineConfig, devices } from '@playwright/test';  
  
export default defineConfig({  
  projects: [  
    {  
      name: 'chromium',  
      use: { ...devices['Desktop Chrome'] },  
    },  
  
    {  
      name: 'firefox',  
      use: { ...devices['Desktop Firefox'] },  
    },  
  
    {  
      name: 'webkit',  
      use: { ...devices['Desktop Safari'] },  
    },  
  
    /* Test against mobile viewports. */  
    {  
      name: 'Mobile Chrome',  
      use: { ...devices['Pixel 5'] },  
    },  
    {  
      name: 'Mobile Safari',  
      use: { ...devices['iPhone 12'] },  
    },  
  
    /* Test against branded browsers. */  
    {  
      name: 'Microsoft Edge',  
      use: {  
        ...devices['Desktop Edge'],  
        channel: 'msedge'  
      },  
    },  
    {  
      name: 'Google Chrome',  
      use: {  
        ...devices['Desktop Chrome'],  
        channel: 'chrome'  
      },  
    },  
  ],  
});","Configure projects for multiple browsersâ€‹ | By using **projects** you can run your tests in multiple browsers such as chromium, webkit and firefox as well as branded browsers such as Google Chrome and Microsoft Edge. Playwright can also run on emulated tablet and mobile devices. See the [registry of device parameters](https://github.com/microsoft/playwright/blob/main/packages/playwright-core/src/server/deviceDescriptorsSource.json) for a complete list of selected desktop, tablet and mobile devices.",https://playwright.dev/docs/test-projects,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  timeout: 60000, // Timeout is shared between all tests.  
  projects: [  
    {  
      name: 'staging',  
      use: {  
        baseURL: 'staging.example.com',  
      },  
      retries: 2,  
    },  
    {  
      name: 'production',  
      use: {  
        baseURL: 'production.example.com',  
      },  
      retries: 0,  
    },  
  ],  
});",By setting up projects we can also run a group of tests with different timeouts or retries or run a group of tests against different environments. For example we can run our tests against a staging environment with 2 retries as well as against a production environment with 0 retries. | playwright.config.ts,https://playwright.dev/docs/test-projects,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  timeout: 60000, // Timeout is shared between all tests.  
  projects: [  
    {  
      name: 'Smoke',  
      testMatch: /.*smoke.spec.ts/,  
      retries: 0,  
    },  
    {  
      name: 'Default',  
      testIgnore: /.*smoke.spec.ts/,  
      retries: 2,  
    },  
  ],  
});","Here is an example that defines a common timeout and two projects. The ""Smoke"" project runs a small subset of tests without retries, and ""Default"" project runs all other tests with retries. | playwright.config.ts",https://playwright.dev/docs/test-projects,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  projects: [  
    {  
      name: 'setup',  
      testMatch: '**/*.setup.ts',  
    },  
    {  
      name: 'chromium',  
      use: { ...devices['Desktop Chrome'] },  
      dependencies: ['setup'],  
    },  
    {  
      name: 'firefox',  
      use: { ...devices['Desktop Firefox'] },  
      dependencies: ['setup'],  
    },  
    {  
      name: 'webkit',  
      use: { ...devices['Desktop Safari'] },  
      dependencies: ['setup'],  
    },  
  ],  
});","In this example the chromium, firefox and webkit projects depend on the setup project. | playwright.config.ts",https://playwright.dev/docs/test-projects,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  reporter: 'line',  
});","For more control, you can specify reporters programmatically in the [configuration file](/docs/test-configuration). | playwright.config.ts",https://playwright.dev/docs/test-reporters,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  reporter: [  
    ['list'],  
    ['json', {  outputFile: 'test-results.json' }]  
  ],  
});",You can use multiple reporters at the same time. For example you can use `'list'` for nice terminal output and `'json'` to get a comprehensive json file with the test results. | playwright.config.ts,https://playwright.dev/docs/test-reporters,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  // Concise 'dot' for CI, default 'list' when running locally  
  reporter: process.env.CI ? 'dot' : 'list',  
});","You can use different reporters locally and on CI. For example, using concise `'dot'` reporter avoids too much output. This is the default on CI. | playwright.config.ts",https://playwright.dev/docs/test-reporters,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  reporter: 'list',  
});",playwright.config.ts,https://playwright.dev/docs/test-reporters,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  reporter: [['list', { printSteps: true }]],  
});",You can opt into the step rendering via passing the following config option: | playwright.config.ts,https://playwright.dev/docs/test-reporters,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  reporter: 'line',  
});",playwright.config.ts,https://playwright.dev/docs/test-reporters,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  reporter: 'dot',  
});",playwright.config.ts,https://playwright.dev/docs/test-reporters,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  reporter: [['html', { open: 'never' }]],  
});",You can also configure `host` and `port` that are used to serve the HTML report. | playwright.config.ts,https://playwright.dev/docs/test-reporters,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  reporter: [['html', { outputFolder: 'my-report' }]],  
});","In configuration file, pass options directly: | playwright.config.ts",https://playwright.dev/docs/test-reporters,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  reporter: [['html', { attachmentsBaseURL: 'https://external-storage.com/' }]],  
});","If you are uploading attachments from data folder to other location, you can use `attachmentsBaseURL` option to let html report where to look for them. | playwright.config.ts",https://playwright.dev/docs/test-reporters,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  reporter: [['blob', { outputFile: `./blob-report/report-${os.platform()}.zip` }]],  
});","By default, the report is written into the `blob-report` directory in the package.json directory or current working directory (if no package.json is found). The report file name looks like `report-<hash>.zip` or `report-<hash>-<shard_number>.zip` when [sharding](/docs/test-sharding) is used. The hash is an optional value computed from `--grep`, `--grepInverted`, `--project` and file filters passed as command line arguments. The hash guarantees that running Playwright with different command line options will produce different but stable between runs report names. The output file name can be overridden in the configuration file or pass as `'PLAYWRIGHT_BLOB_OUTPUT_FILE'` environment variable. | playwright.config.ts",https://playwright.dev/docs/test-reporters,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  reporter: [['json', { outputFile: 'results.json' }]],  
});","In configuration file, pass options directly: | playwright.config.ts",https://playwright.dev/docs/test-reporters,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  reporter: [['junit', { outputFile: 'results.xml' }]],  
});","In configuration file, pass options directly: | playwright.config.ts",https://playwright.dev/docs/test-reporters,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  // 'github' for GitHub Actions CI to generate annotations, plus a concise 'dot'  
  // default 'list' when running locally  
  reporter: process.env.CI ? 'github' : 'list',  
});","Note that all other reporters work on GitHub Actions as well, but do not provide annotations. Also, it is not recommended to use this annotation type if running your tests with a matrix strategy as the stack trace failures will multiply and obscure the GitHub file view. | playwright.config.ts",https://playwright.dev/docs/test-reporters,general
javascript,"import type {  
  FullConfig, FullResult, Reporter, Suite, TestCase, TestResult  
} from '@playwright/test/reporter';  
  
class MyReporter implements Reporter {  
  onBegin(config: FullConfig, suite: Suite) {  
    console.log(`Starting the run with ${suite.allTests().length} tests`);  
  }  
  
  onTestBegin(test: TestCase, result: TestResult) {  
    console.log(`Starting test ${test.title}`);  
  }  
  
  onTestEnd(test: TestCase, result: TestResult) {  
    console.log(`Finished test ${test.title}: ${result.status}`);  
  }  
  
  onEnd(result: FullResult) {  
    console.log(`Finished the run: ${result.status}`);  
  }  
}  
  
export default MyReporter;","You can create a custom reporter by implementing a class with some of the reporter methods. Learn more about the [Reporter](/docs/api/class-reporter ""Reporter"") API. | my-awesome-reporter.ts",https://playwright.dev/docs/test-reporters,form_interaction
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  reporter: './my-awesome-reporter.ts',  
});",Now use this reporter with [testConfig.reporter](/docs/api/class-testconfig#test-config-reporter). | playwright.config.ts,https://playwright.dev/docs/test-reporters,general
javascript,"import { test } from '@playwright/test';  
  
test.describe('suite', () => {  
  test.beforeAll(async () => { /* ... */ });  
  test('first good', async ({ page }) => { /* ... */ });  
  test('second flaky', async ({ page }) => { /* ... */ });  
  test('third good', async ({ page }) => { /* ... */ });  
  test.afterAll(async () => { /* ... */ });  
});","Playwright Test runs tests in worker processes. These processes are OS processes, running independently, orchestrated by the test runner. All workers have identical environments and each starts its own browser. | Consider the following snippet:",https://playwright.dev/docs/test-retries,fixture
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  // Give failing tests 3 retry attempts  
  retries: 3,  
});",You can configure retries in the configuration file: | playwright.config.ts,https://playwright.dev/docs/test-retries,general
javascript,"import { test, expect } from '@playwright/test';  
  
test('my test', async ({ page }, testInfo) => {  
  if (testInfo.retry)  
    await cleanSomeCachesOnTheServer();  
  // ...  
});","You can detect retries at runtime with [testInfo.retry](/docs/api/class-testinfo#test-info-retry), which is accessible to any test, hook or fixture. Here is an example that clears some server-side state before a retry.",https://playwright.dev/docs/test-retries,assertion
javascript,"import { test, expect } from '@playwright/test';  
  
test.describe(() => {  
  // All tests in this describe group will get 2 retry attempts.  
  test.describe.configure({ retries: 2 });  
  
  test('test 1', async ({ page }) => {  
    // ...  
  });  
  
  test('test 2', async ({ page }) => {  
    // ...  
  });  
});",You can specify retries for a specific group of tests or a single file with [test.describe.configure()](/docs/api/class-test#test-describe-configure).,https://playwright.dev/docs/test-retries,assertion
javascript,"import { test } from '@playwright/test';  
  
test.describe.configure({ mode: 'serial' });  
  
test.beforeAll(async () => { /* ... */ });  
test('first good', async ({ page }) => { /* ... */ });  
test('second flaky', async ({ page }) => { /* ... */ });  
test('third good', async ({ page }) => { /* ... */ });","Use [test.describe.serial()](/docs/api/class-test#test-describe-serial) to group dependent tests to ensure they will always run together and in order. If one of the tests fails, all subsequent tests are skipped. All tests in the group are retried together. | Consider the following snippet that uses `test.describe.serial`:",https://playwright.dev/docs/test-retries,fixture
javascript,"import { test, type Page } from '@playwright/test';  
  
test.describe.configure({ mode: 'serial' });  
  
let page: Page;  
  
test.beforeAll(async ({ browser }) => {  
  page = await browser.newPage();  
});  
  
test.afterAll(async () => {  
  await page.close();  
});  
  
test('runs first', async () => {  
  await page.goto('https://playwright.dev/');  
});  
  
test('runs second', async () => {  
  await page.getByText('Get Started').click();  
});",example.spec.ts,https://playwright.dev/docs/test-retries,fixture
javascript,"import { test, expect } from '@playwright/test';  
  
test('example test', async ({ page }) => {  
  await page.goto('https://playwright.dev');  
  await expect(page).toHaveScreenshot();  
});","Playwright Test includes the ability to produce and visually compare screenshots using `await expect(page).toHaveScreenshot()`. On first execution, Playwright test will generate reference screenshots. Subsequent runs will compare against the reference. | example.spec.ts",https://playwright.dev/docs/test-snapshots,assertion
javascript,await expect(page).toHaveScreenshot('landing.png');,The snapshot name `example-test-1-chromium-darwin.png` consists of a few parts: | `example-test-1.png` \- an auto-generated name of the snapshot. Alternatively you can specify snapshot name as the first argument of the `toHaveScreenshot()` method:,https://playwright.dev/docs/test-snapshots,assertion
javascript,"import { test, expect } from '@playwright/test';  
  
test('example test', async ({ page }) => {  
  await page.goto('https://playwright.dev');  
  await expect(page).toHaveScreenshot({ maxDiffPixels: 100 });  
});",Playwright Test uses the [pixelmatch](https://github.com/mapbox/pixelmatch) library. You can [pass various options](/docs/api/class-pageassertions#page-assertions-to-have-screenshot-1) to modify its behavior: | example.spec.ts,https://playwright.dev/docs/test-snapshots,assertion
javascript,"import { defineConfig } from '@playwright/test';  
export default defineConfig({  
  expect: {  
    toHaveScreenshot: { maxDiffPixels: 100 },  
  },  
});","If you'd like to share the default value among all the tests in the project, you can specify it in the playwright config, either globally or per project: | playwright.config.ts",https://playwright.dev/docs/test-snapshots,assertion
javascript,"import { test, expect } from '@playwright/test';  
  
test('example test', async ({ page }) => {  
  await page.goto('https://playwright.dev');  
  await expect(page).toHaveScreenshot({ stylePath: path.join(__dirname, 'screenshot.css') });  
});",example.spec.ts,https://playwright.dev/docs/test-snapshots,assertion
javascript,"import { defineConfig } from '@playwright/test';  
export default defineConfig({  
  expect: {  
    toHaveScreenshot: {  
      stylePath: './screenshot.css'  
    },  
  },  
});","If you'd like to share the default value among all the tests in the project, you can specify it in the playwright config, either globally or per project: | playwright.config.ts",https://playwright.dev/docs/test-snapshots,assertion
javascript,"import { test, expect } from '@playwright/test';  
  
test('example test', async ({ page }) => {  
  await page.goto('https://playwright.dev');  
  expect(await page.textContent('.hero__title')).toMatchSnapshot('hero.txt');  
});",Here we compare text content against the reference. | example.spec.ts,https://playwright.dev/docs/test-snapshots,assertion
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  timeout: 120_000,  
});",Set test timeout in the configâ€‹ | playwright.config.ts,https://playwright.dev/docs/test-timeouts,general
javascript,"import { test, expect } from '@playwright/test';  
  
test('slow test', async ({ page }) => {  
  test.slow(); // Easy way to triple the default timeout  
  // ...  
});  
  
test('very slow test', async ({ page }) => {  
  test.setTimeout(120_000);  
  // ...  
});",Set timeout for a single testâ€‹ | example.spec.ts,https://playwright.dev/docs/test-timeouts,assertion
javascript,"import { test, expect } from '@playwright/test';  
  
test.beforeEach(async ({ page }, testInfo) => {  
  // Extend timeout for all tests running this hook by 30 seconds.  
  testInfo.setTimeout(testInfo.timeout + 30_000);  
});",Change timeout from a `beforeEach` hookâ€‹ | example.spec.ts,https://playwright.dev/docs/test-timeouts,assertion
javascript,"import { test, expect } from '@playwright/test';  
  
test.beforeAll(async () => {  
  // Set timeout for this hook.  
  test.setTimeout(60000);  
});","`beforeAll` and `afterAll` hooks have a separate timeout, by default equal to test timeout. You can change it separately for each hook by calling [testInfo.setTimeout()](/docs/api/class-testinfo#test-info-set-timeout) inside the hook. | example.spec.ts",https://playwright.dev/docs/test-timeouts,fixture
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  expect: {  
    timeout: 10_000,  
  },  
});",Set expect timeout in the configâ€‹ | playwright.config.ts,https://playwright.dev/docs/test-timeouts,assertion
javascript,"import { test, expect } from '@playwright/test';  
  
test('example', async ({ page }) => {  
  await expect(locator).toHaveText('hello', { timeout: 10_000 });  
});",Specify expect timeout for a single assertionâ€‹ | example.spec.ts,https://playwright.dev/docs/test-timeouts,assertion
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  globalTimeout: 3_600_000,  
});",You can set global timeout in the config. | playwright.config.ts,https://playwright.dev/docs/test-timeouts,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  use: {  
    actionTimeout: 10 * 1000,  
    navigationTimeout: 30 * 1000,  
  },  
});",Set action and navigation timeouts in the configâ€‹ | playwright.config.ts,https://playwright.dev/docs/test-timeouts,general
javascript,"import { test, expect } from '@playwright/test';  
  
test('basic test', async ({ page }) => {  
  await page.goto('https://playwright.dev', { timeout: 30000 });  
  await page.getByText('Get Started').click({ timeout: 10000 });  
});",Set timeout for a single actionâ€‹ | example.spec.ts,https://playwright.dev/docs/test-timeouts,assertion
javascript,"import { test as base, expect } from '@playwright/test';  
  
const test = base.extend<{ slowFixture: string }>({  
  slowFixture: [async ({}, use) => {  
    // ... perform a slow operation ...  
    await use('hello');  
  }, { timeout: 60_000 }]  
});  
  
test('example test', async ({ slowFixture }) => {  
  // ...  
});","By default, [fixture](/docs/test-fixtures) shares timeout with the test. However, for slow fixtures, especially [worker-scoped](/docs/test-fixtures#worker-scoped-fixtures) ones, it is convenient to have a separate timeout. This way you can keep the overall test timeout small, and give the slow fixture more time. | example.spec.ts",https://playwright.dev/docs/test-timeouts,fixture
javascript,"import { test, expect } from '@playwright/test';  
import { username, password } from '@myhelper/credentials';  
  
test('example', async ({ page }) => {  
  await page.getByLabel('User Name').fill(username);  
  await page.getByLabel('Password').fill(password);  
});",You can now import using the mapped paths: | example.spec.ts,https://playwright.dev/docs/test-typescript,assertion
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  tsconfig: './tsconfig.test.json',  
});","You can specify a single tsconfig file in the config file, that will be used for loading test files, reporters, etc. However, it will not be used while loading the playwright config itself or any files imported from it. | playwright.config.ts",https://playwright.dev/docs/test-typescript,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  use: {  
    // Base URL to use in actions like `await page.goto('/')`.  
    baseURL: 'http://127.0.0.1:3000',  
  
    // Populates context with given storage state.  
    storageState: 'state.json',  
  },  
});",Set the base URL and storage state for all tests: | playwright.config.ts,https://playwright.dev/docs/test-use-options,navigation
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  use: {  
    // Emulates `'prefers-colors-scheme'` media feature.  
    colorScheme: 'dark',  
  
    // Context geolocation.  
    geolocation: { longitude: 12.492507, latitude: 41.889938 },  
  
    // Emulates the user locale.  
    locale: 'en-GB',  
  
    // Grants specified permissions to the browser context.  
    permissions: ['geolocation'],  
  
    // Emulates the user timezone.  
    timezoneId: 'Europe/Paris',  
  
    // Viewport used for all pages in the context.  
    viewport: { width: 1280, height: 720 },  
  },  
});","With Playwright you can emulate a real device such as a mobile phone or tablet. See our [guide on projects](/docs/test-projects) for more info on emulating devices. You can also emulate the `""geolocation""`, `""locale""` and `""timezone""` for all tests or for a specific test as well as set the `""permissions""` to show notifications or change the `""colorScheme""`. See our [Emulation](/docs/emulation) guide to learn more. | playwright.config.ts",https://playwright.dev/docs/test-use-options,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  use: {  
    // Whether to automatically download all the attachments.  
    acceptDownloads: false,  
  
    // An object containing additional HTTP headers to be sent with every request.  
    extraHTTPHeaders: {  
      'X-My-Header': 'value',  
    },  
  
    // Credentials for HTTP authentication.  
    httpCredentials: {  
      username: 'user',  
      password: 'pass',  
    },  
  
    // Whether to ignore HTTPS errors during navigation.  
    ignoreHTTPSErrors: true,  
  
    // Whether to emulate network being offline.  
    offline: true,  
  
    // Proxy settings used for all pages in the test.  
    proxy: {  
      server: 'http://myproxy.com:3128',  
      bypass: 'localhost',  
    },  
  },  
});",Available options to configure networking: | playwright.config.ts,https://playwright.dev/docs/test-use-options,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  use: {  
    // Capture screenshot after each test failure.  
    screenshot: 'only-on-failure',  
  
    // Record trace only when retrying a test for the first time.  
    trace: 'on-first-retry',  
  
    // Record video only when retrying a test for the first time.  
    video: 'on-first-retry'  
  },  
});","Trace files, screenshots and videos will appear in the test output directory, typically `test-results`. | playwright.config.ts",https://playwright.dev/docs/test-use-options,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  use: {  
    // Maximum time each action such as `click()` can take. Defaults to 0 (no limit).  
    actionTimeout: 0,  
  
    // Name of the browser that runs tests. For example `chromium`, `firefox`, `webkit`.  
    browserName: 'chromium',  
  
    // Toggles bypassing Content-Security-Policy.  
    bypassCSP: true,  
  
    // Channel to use, for example ""chrome"", ""chrome-beta"", ""msedge"", ""msedge-beta"".  
    channel: 'chrome',  
  
    // Run browser in headless mode.  
    headless: false,  
  
    // Change the default data-testid attribute.  
    testIdAttribute: 'pw-test-id',  
  },  
});",Other Optionsâ€‹ | playwright.config.ts,https://playwright.dev/docs/test-use-options,navigation
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  use: {  
    launchOptions: {  
      slowMo: 50,  
    },  
  },  
});",Any options accepted by [browserType.launch()](/docs/api/class-browsertype#browser-type-launch) or [browser.newContext()](/docs/api/class-browser#browser-new-context) can be put into `launchOptions` or `contextOptions` respectively in the `use` section. | playwright.config.ts,https://playwright.dev/docs/test-use-options,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  use: {  
    userAgent: 'some custom ua',  
    viewport: { width: 100, height: 100 },  
  },  
});","If using the built-in `browser` fixture, calling [browser.newContext()](/docs/api/class-browser#browser-new-context) will create a context with options inherited from the config: | playwright.config.ts",https://playwright.dev/docs/test-use-options,general
javascript,"test('should inherit use options on context when using built-in browser fixture', async ({  
  browser,  
}) => {  
  const context = await browser.newContext();  
  const page = await context.newPage();  
  expect(await page.evaluate(() => navigator.userAgent)).toBe('some custom ua');  
  expect(await page.evaluate(() => window.innerWidth)).toBe(100);  
  await context.close();  
});",An example test illustrating the initial context options are set:,https://playwright.dev/docs/test-use-options,fixture
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  use: {  
    locale: 'en-GB'  
  },  
});","You can configure Playwright globally, per project, or per test. For example, you can set the locale to be used globally by adding `locale` to the `use` option of the Playwright config, and then override it for a specific project using the `project` option in the config. You can also override it for a specific test by adding `test.use({})` in the test file and passing in the options. | playwright.config.ts",https://playwright.dev/docs/test-use-options,general
javascript,"import { defineConfig, devices } from '@playwright/test';  
  
export default defineConfig({  
  projects: [  
    {  
      name: 'chromium',  
      use: {  
        ...devices['Desktop Chrome'],  
        locale: 'de-DE',  
      },  
    },  
  ],  
});",You can override options for a specific project using the `project` option in the Playwright config.,https://playwright.dev/docs/test-use-options,general
javascript,"import { test, expect } from '@playwright/test';  
  
test.use({ locale: 'fr-FR' });  
  
test('example', async ({ page }) => {  
  // ...  
});",You can override options for a specific test file by using the `test.use()` method and passing in the options. For example to run tests with the French locale for a specific test:,https://playwright.dev/docs/test-use-options,assertion
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  // Run your local dev server before starting the tests  
  webServer: {  
    command: 'npm run start',  
    url: 'http://127.0.0.1:3000',  
    reuseExistingServer: !process.env.CI,  
    stdout: 'ignore',  
    stderr: 'pipe',  
  },  
});",Use the `webserver` property in your Playwright config to launch a development web server during the tests. | playwright.config.ts,https://playwright.dev/docs/test-webserver,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  // Rest of your config...  
  
  // Run your local dev server before starting the tests  
  webServer: {  
    command: 'npm run start',  
    url: 'http://127.0.0.1:3000',  
    reuseExistingServer: !process.env.CI,  
    timeout: 120 * 1000,  
  },  
});","Webservers can sometimes take longer to boot up. In this case, you can increase the timeout to wait for the server to start. | playwright.config.ts",https://playwright.dev/docs/test-webserver,general
javascript,"import { defineConfig } from '@playwright/test';  
  
export default defineConfig({  
  // Rest of your config...  
  
  // Run your local dev server before starting the tests  
  webServer: {  
    command: 'npm run start',  
    url: 'http://127.0.0.1:3000',  
    reuseExistingServer: !process.env.CI,  
  },  
  use: {  
    baseURL: 'http://127.0.0.1:3000',  
  },  
});","When using [page.goto()](/docs/api/class-page#page-goto), [page.route()](/docs/api/class-page#page-route), [page.waitForURL()](/docs/api/class-page#page-wait-for-url), [page.waitForRequest()](/docs/api/class-page#page-wait-for-request), or [page.waitForResponse()](/docs/api/class-page#page-wait-for-response) it takes the base URL in consideration by using the [`URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL) constructor for building the corresponding URL. For Example, by setting the baseURL to `http://127.0.0.1:3000` and navigating to `/login` in your tests, Playwright will run the test using `http://127.0.0.1:3000/login`. | playwright.config.ts",https://playwright.dev/docs/test-webserver,general
javascript,"import { test } from '@playwright/test';  
  
test('test', async ({ page }) => {  
  // This will navigate to http://127.0.0.1:3000/login  
  await page.goto('./login');  
});",Now you can use a relative path when navigating the page: | test.spec.ts,https://playwright.dev/docs/test-webserver,navigation
javascript,"import { defineConfig } from '@playwright/test';  
export default defineConfig({  
  retries: process.env.CI ? 2 : 0, // set to 2 when running on CI  
  // ...  
  use: {  
    trace: 'on-first-retry', // record traces on first retry of each test  
  },  
});",By default the [playwright.config](/docs/trace-viewer#recording-a-trace-on-ci) file will contain the configuration needed to create a `trace.zip` file for each test. Traces are setup to run `on-first-retry` meaning they will be run on the first retry of a failed test. Also `retries` are set to 2 when running on CI and 0 locally. This means the traces will be recorded on the first retry of a failed test but not on the first run and not on the second retry. | playwright.config.ts,https://playwright.dev/docs/trace-viewer-intro,general
javascript,"import { defineConfig } from '@playwright/test';  
export default defineConfig({  
  retries: 1,  
  use: {  
    trace: 'on-first-retry',  
  },  
});  



const browser = await chromium.launch();  
const context = await browser.newContext();  
  
// Start tracing before creating / navigating a page.  
await context.tracing.start({ screenshots: true, snapshots: true });  
  
const page = await context.newPage();  
await page.goto('https://playwright.dev');  
  
// Stop tracing and export it into a zip archive.  
await context.tracing.stop({ path: 'trace.zip' });",playwright.config.ts,https://playwright.dev/docs/trace-viewer,navigation
javascript,"import { defineConfig } from '@playwright/test';  
export default defineConfig({  
  use: {  
    video: 'on-first-retry',  
  },  
});  



const context = await browser.newContext({ recordVideo: { dir: 'videos/' } });  
// Make sure to await close, so that videos are saved.  
await context.close();",playwright.config.ts,https://playwright.dev/docs/videos,wait_strategy
javascript,"import { defineConfig } from '@playwright/test';  
export default defineConfig({  
  use: {  
    video: {  
      mode: 'on-first-retry',  
      size: { width: 640, height: 480 }  
    }  
  },  
});  



const context = await browser.newContext({  
  recordVideo: {  
    dir: 'videos/',  
    size: { width: 640, height: 480 },  
  }  
});",playwright.config.ts,https://playwright.dev/docs/videos,wait_strategy
javascript,const path = await page.video().path();,"For multi-page scenarios, you can access the video file associated with the page via the [page.video()](/docs/api/class-page#page-video).",https://playwright.dev/docs/videos,wait_strategy
javascript,"await this.webView.EnsureCoreWebView2Async(await CoreWebView2Environment.CreateAsync(null, null, new CoreWebView2EnvironmentOptions()  
{  
  AdditionalBrowserArguments = ""--remote-debugging-port=9222"",  
})).ConfigureAwait(false);","Overviewâ€‹ | A WebView2 control can be instructed to listen to incoming CDP connections by setting either the `WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS` environment variable with `--remote-debugging-port=9222` or calling [EnsureCoreWebView2Async](https://docs.microsoft.com/en-us/dotnet/api/microsoft.web.webview2.wpf.webview2.ensurecorewebview2async?view=webview2-dotnet-1.0.1343.22) with the `--remote-debugging-port=9222` argument. This will start the WebView2 process with the Chrome DevTools Protocol enabled which allows the automation by Playwright. 9222 is an example port in this case, but any other unused port can be used as well.",https://playwright.dev/docs/webview2,wait_strategy
javascript,"import { test as base } from '@playwright/test';  
import fs from 'fs';  
import os from 'os';  
import path from 'path';  
import childProcess from 'child_process';  
  
const EXECUTABLE_PATH = path.join(  
    __dirname,  
    '../../webview2-app/bin/Debug/net8.0-windows/webview2.exe',  
);  
  
export const test = base.extend({  
  browser: async ({ playwright }, use, testInfo) => {  
    const cdpPort = 10000 + testInfo.workerIndex;  
    // Make sure that the executable exists and is executable  
    fs.accessSync(EXECUTABLE_PATH, fs.constants.X_OK);  
    const userDataDir = path.join(  
        fs.realpathSync.native(os.tmpdir()),  
        `playwright-webview2-tests/user-data-dir-${testInfo.workerIndex}`,  
    );  
    const webView2Process = childProcess.spawn(EXECUTABLE_PATH, [], {  
      shell: true,  
      env: {  
        ...process.env,  
        WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS: `--remote-debugging-port=${cdpPort}`,  
        WEBVIEW2_USER_DATA_FOLDER: userDataDir,  
      }  
    });  
    await new Promise<void>(resolve => webView2Process.stdout.on('data', data => {  
      if (data.toString().includes('WebView2 initialized'))  
        resolve();  
    }));  
    const browser = await playwright.chromium.connectOverCDP(`http://127.0.0.1:${cdpPort}`);  
    await use(browser);  
    await browser.close();  
    childProcess.execSync(`taskkill /pid ${webView2Process.pid} /T /F`);  
    fs.rmdirSync(userDataDir, { recursive: true });  
  },  
  context: async ({ browser }, use) => {  
    const context = browser.contexts()[0];  
    await use(context);  
  },  
  page: async ({ context }, use) => {  
    const page = context.pages()[0];  
    await use(page);  
  },  
});  
  
export { expect } from '@playwright/test';","Using the following, Playwright will run your WebView2 application as a sub-process, assign a unique user data directory to it and provide the [Page](/docs/api/class-page ""Page"") instance to your test: | webView2Test.ts",https://playwright.dev/docs/webview2,assertion
javascript,"import { test, expect } from './webView2Test';  
  
test('test WebView2', async ({ page }) => {  
  await page.goto('https://playwright.dev');  
  const getStarted = page.getByText('Get Started');  
  await expect(getStarted).toBeVisible();  
});",example.spec.ts,https://playwright.dev/docs/webview2,assertion
javascript,"import { test, expect } from '@playwright/test';  
  
test('has title', async ({ page }) => {  
  await page.goto('https://playwright.dev/');  
  
  // Expect a title ""to contain"" a substring.  
  await expect(page).toHaveTitle(/Playwright/);  
});  
  
test('get started link', async ({ page }) => {  
  await page.goto('https://playwright.dev/');  
  
  // Click the get started link.  
  await page.getByRole('link', { name: 'Get started' }).click();  
  
  // Expects page to have a heading with the name of Installation.  
  await expect(page.getByRole('heading', { name: 'Installation' })).toBeVisible();  
});",Take a look at the following example to see how to write a test. | tests/example.spec.ts,https://playwright.dev/docs/writing-tests,assertion
javascript,await page.goto('https://playwright.dev/');,"Navigationâ€‹ | Most of the tests will start with navigating page to the URL. After that, test will be able to interact with the page elements.",https://playwright.dev/docs/writing-tests,navigation
javascript,"// Create a locator.  
const getStarted = page.getByRole('link', { name: 'Get started' });  
  
// Click it.  
await getStarted.click();","Interactionsâ€‹ | Performing actions starts with locating the elements. Playwright uses [Locators API](/docs/locators) for that. Locators represent a way to find element(s) on the page at any moment, learn more about the [different types](/docs/locators) of locators available. Playwright will wait for the element to be [actionable](/docs/actionability) prior to performing the action, so there is no need to wait for it to become available.",https://playwright.dev/docs/writing-tests,navigation
javascript,"await page.getByRole('link', { name: 'Get started' }).click();","In most cases, it'll be written in one line:",https://playwright.dev/docs/writing-tests,navigation
javascript,await expect(page).toHaveTitle(/Playwright/);,"Playwright also includes async matchers that will wait until the expected condition is met. Using these matchers allows making the tests non-flaky and resilient. For example, this code will wait until the page gets the title containing ""Playwright"":",https://playwright.dev/docs/writing-tests,assertion
javascript,"import { test } from '@playwright/test';  
  
test('example test', async ({ page }) => {  
  // ""page"" belongs to an isolated BrowserContext, created for this specific test.  
});  
  
test('another test', async ({ page }) => {  
  // ""page"" in this second test is completely isolated from the first test.  
});","Playwright Test is based on the concept of [test fixtures](/docs/test-fixtures) such as the [built in page fixture](/docs/test-fixtures#built-in-fixtures), which is passed into your test. Pages are [isolated between tests due to the Browser Context](/docs/browser-contexts), which is equivalent to a brand new browser profile, where every test gets a fresh environment, even when multiple tests run in a single Browser. | tests/example.spec.ts",https://playwright.dev/docs/writing-tests,general
javascript,"import { test, expect } from '@playwright/test';  
  
test.describe('navigation', () => {  
  test.beforeEach(async ({ page }) => {  
    // Go to the starting url before each test.  
    await page.goto('https://playwright.dev/');  
  });  
  
  test('main navigation', async ({ page }) => {  
    // Assertions use the expect API.  
    await expect(page).toHaveURL('https://playwright.dev/');  
  });  
});",You can use various [test hooks](/docs/api/class-test) such as `test.describe` to declare a group of tests and `test.beforeEach` and `test.afterEach` which are executed before/after each test. Other hooks include the `test.beforeAll` and `test.afterAll` which are executed once per worker before/after all tests. | tests/example.spec.ts,https://playwright.dev/docs/writing-tests,assertion
