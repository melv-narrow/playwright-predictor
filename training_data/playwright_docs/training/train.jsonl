{"instruction": "Generate a Playwright test for the following scenario: Emulate the users `\"colorScheme\"`. Supported values are 'light' and 'dark'. You can also emulate the media type with [page.emulateMedia()](/docs/api/class-page#page-emulate-media). | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    colorScheme: 'dark',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Generate a Playwright test for the following scenario: Playwright makes it easy to test your site across all [browsers](/docs/test-projects#configure-projects-for-multiple-browsers) no matter what platform you are on. Testing across all browsers ensures your app works for all users. In your config file you can set up projects adding the name and which browser or device to use. | playwright.config.ts", "input": "", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n    },  \n    {  \n      name: 'firefox',  \n      use: { ...devices['Desktop Firefox'] },  \n    },  \n    {  \n      name: 'webkit',  \n      use: { ...devices['Desktop Safari'] },  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/best-practices"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(<Component/>);  \n  await component.update(  \n      <Component msg=\"greetings\" onClick={() => {}}>Child</Component>  \n  );  \n});", "output": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(<Component/>);  \n  await component.update(  \n      <Component msg=\"greetings\" onClick={() => {}}>Child</Component>  \n  );  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Custom fixture title\u200b | Instead of the usual fixture name, you can give fixtures a custom title that will be shown in test reports and error messages.", "input": "", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  innerFixture: [async ({}, use, testInfo) => {  \n    // ...  \n  }, { title: 'my fixture' }],  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.getByTestId('directions').click();", "output": "await page.getByTestId('directions').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const child = page.getByText('Hello');  \nconst parent = page.getByRole('listitem').filter({ has: child });", "output": "const child = page.getByText('Hello');  \nconst parent = page.getByRole('listitem').filter({ has: child });", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "You can configure Playwright globally, per project, or per test. For example, you can set the locale to be used globally by adding `locale` to the `use` option of the Playwright config, and then override it for a specific project using the `project` option in the config. You can also override it for a specific test by adding `test.use({})` in the test file and passing in the options. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    locale: 'en-GB'  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/test';  \n  \ntest.describe.configure({ mode: 'serial' });  \n  \ntest.beforeAll(async () => { /* ... */ });  \ntest('first good', async ({ page }) => { /* ... */ });  \ntest('second flaky', async ({ page }) => { /* ... */ });  \ntest('third good', async ({ page }) => { /* ... */ });", "output": "import { test } from '@playwright/test';  \n  \ntest.describe.configure({ mode: 'serial' });  \n  \ntest.beforeAll(async () => { /* ... */ });  \ntest('first good', async ({ page }) => { /* ... */ });  \ntest('second flaky', async ({ page }) => { /* ... */ });  \ntest('third good', async ({ page }) => { /* ... */ });", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-retries", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "example.spec.ts", "output": "import { test, expect } from './webView2Test';  \n  \ntest('test WebView2', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  const getStarted = page.getByText('Get Started');  \n  await expect(getStarted).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/webview2"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "Error: should be logged in  \n  \n    Call log:  \n      - expect.toBeVisible with timeout 5000ms  \n      - waiting for \"getByText('Name')\"  \n  \n  \n      2 |  \n      3 | test('example test', async({ page }) => {  \n    > 4 |   await expect(page.getByText('Name'), 'should be logged in').toBeVisible();  \n        |                                                                  ^  \n      5 | });  \n      6 |", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: component.spec.tsx", "input": "", "output": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(<Component/>);  \n  await component.update(  \n      <Component msg=\"greetings\" onClick={() => {}}>Child</Component>  \n  );  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "page.on('dialog', dialog => dialog.accept());  \nawait page.getByRole('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/dialogs", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Scroll the footer into view, forcing an \"infinite list\" to load more content  \nawait page.getByText('Footer text').scrollIntoViewIfNeeded();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: To include _all_ of the scan results as part of your test results for debugging purposes, you can add the scan results as a test attachment with [`testInfo.attach()`](/docs/api/class-testinfo#test-info-attach). [Reporters](/docs/test-reporters) can then embed or link the full results as part of your test output. | The following example demonstrates attaching scan results to a test:", "input": "", "output": "test('example with attachment', async ({ page }, testInfo) => {  \n  await page.goto('https://your-site.com/');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page }).analyze();  \n  \n  await testInfo.attach('accessibility-scan-results', {  \n    body: JSON.stringify(accessibilityScanResults, null, 2),  \n    contentType: 'application/json'  \n  });  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect(locator).toMatchAriaSnapshot('');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/aria-snapshots", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  testDir: './tests',  \n  // ...  \n  projects: [  \n    {  \n      name: 'setup db',  \n      testMatch: /global\\.setup\\.ts/,  \n    },  \n    // {  \n    //   other project  \n    // }  \n  ]  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  testDir: './tests',  \n  // ...  \n  projects: [  \n    {  \n      name: 'setup db',  \n      testMatch: /global\\.setup\\.ts/,  \n    },  \n    // {  \n    //   other project  \n    // }  \n  ]  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: You can also configure `host` and `port` that are used to serve the HTML report. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['html', { open: 'never' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/experimental-ct-svelte';  \nimport App from './App.svelte';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(App);  \n  await expect(component).toContainText('Learn Svelte');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test('gets the json from api and adds a new fruit', async ({ page }) => {  \n  // Get the response and add to it  \n  await page.route('*/**/api/v1/fruits', async route => {  \n    const response = await route.fetch();  \n    const json = await response.json();  \n    json.push({ name: 'Loquat', id: 100 });  \n    // Fulfill using the original response, while patching the response body  \n    // with the given JSON object.  \n    await route.fulfill({ response, json });  \n  });  \n  \n  // Go to the page  \n  await page.goto('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the new fruit is visible  \n  await expect(page.getByText('Loquat', { exact: true })).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "The error would look like this:", "output": "Error: should be logged in  \n  \n    Call log:  \n      - expect.toBeVisible with timeout 5000ms  \n      - waiting for \"getByText('Name')\"  \n  \n  \n      2 |  \n      3 | test('example test', async({ page }) => {  \n    > 4 |   await expect(page.locator('text=Name'), 'should be logged in').toBeVisible();  \n        |                                                                  ^  \n      5 | });  \n      6 |", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Playwright 1.17 introduces [frame locators](/docs/api/class-framelocator) \\- a locator to the iframe on the page. Frame locators capture the logic sufficient to retrieve the `iframe` and then locate elements in that iframe. Frame locators are strict by default, will wait for `iframe` to appear and can be used in Web-First assertions. | Frame locators can be created with either [page.frameLocator()](/docs/api/class-page#page-frame-locator) or [locator.frameLocator()](/docs/api/class-locator#locator-frame-locator) method.", "output": "const locator = page.frameLocator('#my-iframe').locator('text=Submit');  \nawait locator.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "navigation"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('has title', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  \n  // Expect a title \"to contain\" a substring.  \n  await expect(page).toHaveTitle(/Playwright/);  \n});  \n  \ntest('get started link', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  \n  // Click the get started link.  \n  await page.getByRole('link', { name: 'Get started' }).click();  \n  \n  // Expects page to have a heading with the name of Installation.  \n  await expect(page.getByRole('heading', { name: 'Installation' })).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/writing-tests", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Wrong, will match many elements including <body>  \nawait page.locator(':has-text(\"Playwright\")').click();  \n// Correct, only matches the <article> element  \nawait page.locator('article:has-text(\"Playwright\")').click();", "output": "// Wrong, will match many elements including <body>  \nawait page.locator(':has-text(\"Playwright\")').click();  \n// Correct, only matches the <article> element  \nawait page.locator('article:has-text(\"Playwright\")').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Check all checkboxes!  \nconst checkboxes = page.getByRole('checkbox');  \nfor (const checkbox of await checkboxes.all())  \n  await checkbox.check();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: In this example the chromium, firefox and webkit projects depend on the setup project. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'setup',  \n      testMatch: '**/*.setup.ts',  \n    },  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'firefox',  \n      use: { ...devices['Desktop Firefox'] },  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'webkit',  \n      use: { ...devices['Desktop Safari'] },  \n      dependencies: ['setup'],  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-projects"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Simple version produces a single character. This character is case-sensitive, so `\"a\"` and `\"A\"` will produce different results.", "output": "// <input id=name>  \nawait page.locator('#name').press('Shift+A');  \n  \n// <input id=name>  \nawait page.locator('#name').press('Shift+ArrowLeft');", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "[  \n  { name: 'Alice', expected: 'Hello, Alice!' },  \n  { name: 'Bob', expected: 'Hello, Bob!' },  \n  { name: 'Charlie', expected: 'Hello, Charlie!' },  \n].forEach(({ name, expected }) => {  \n  test.describe(() => {  \n    test.beforeEach(async ({ page }) => {  \n      await page.goto(`https://example.com/greet?name=${name}`);  \n    });  \n    test(`testing with ${expected}`, async ({ page }) => {  \n      await expect(page.getByRole('heading')).toHaveText(expected);  \n    });  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parameterize", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Make a few checks that will not stop the test when failed...  \nawait assert.soft(page.locator('#status')).toHaveText('Success');  \nawait assert.soft(page.locator('#eta')).toHaveText('1 day');  \n  \n// ... and continue the test to check more things.  \nawait page.locator('#next-page').click();  \nawait assert.soft(page.locator('#title')).toHaveText('Make another order');", "output": "// Make a few checks that will not stop the test when failed...  \nawait expect.soft(page.locator('#status')).toHaveText('Success');  \nawait expect.soft(page.locator('#eta')).toHaveText('1 day');  \n  \n// ... and continue the test to check more things.  \nawait page.locator('#next-page').click();  \nawait expect.soft(page.locator('#title')).toHaveText('Make another order');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as base } from '@playwright/test';  \n  \nexport type TestOptions = {  \n  person: string;  \n};  \n  \nexport const test = base.extend<TestOptions>({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  person: ['John', { option: true }],  \n});", "output": "import { test as base } from '@playwright/test';  \n  \nexport type TestOptions = {  \n  person: string;  \n};  \n  \nexport const test = base.extend<TestOptions>({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  person: ['John', { option: true }],  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-parameterize", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from './fixtures';  \n  \ntest('amount', async () => {  \n  await assert(page.locator('.cart')).toHaveAmount(4);  \n});", "output": "import { test, expect } from './fixtures';  \n  \ntest('amount', async () => {  \n  await expect(page.locator('.cart')).toHaveAmount(4);  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-assertions", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: [New syntax](/docs/test-annotations#tag-tests) for adding tags to the tests (@-tokens in the test title are still supported):", "input": "", "output": "test('test customer login', {  \n  tag: ['@fast', '@login'],  \n}, async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Use a glob URL pattern. Note no await.  \nconst responsePromise = page.waitForResponse('**/api/fetch_data');  \nawait page.getByText('Update').click();  \nconst response = await responsePromise;", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: component.spec.tsx", "input": "", "output": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('props', async ({ mount }) => {  \n  const component = await mount(<Component msg=\"greetings\" />);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example', async ({ page }) => {  \n  await expect(locator).toHaveText('hello', { timeout: 10_000 });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Get all new pages (including popups) in the context  \ncontext.on('page', async page => {  \n  await page.waitForLoadState();  \n  console.log(await page.title());  \n});", "output": "// Get all new pages (including popups) in the context  \ncontext.on('page', async page => {  \n  await page.waitForLoadState();  \n  console.log(await page.title());  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/pages", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// This is less fragile than snapshotting the entire violations array.  \nassert(violationFingerprints(accessibilityScanResults)).toMatchSnapshot();  \n  \n// my-test-utils.js  \nfunction violationFingerprints(accessibilityScanResults) {  \n  const violationFingerprints = accessibilityScanResults.violations.map(violation => ({  \n    rule: violation.id,  \n    // These are CSS selectors which uniquely identify each element with  \n    // a violation of the rule in question.  \n    targets: violation.nodes.map(node => node.target),  \n  }));  \n  \n  return JSON.stringify(violationFingerprints, null, 2);  \n}", "output": "// This is less fragile than snapshotting the entire violations array.  \nexpect(violationFingerprints(accessibilityScanResults)).toMatchSnapshot();  \n  \n// my-test-utils.js  \nfunction violationFingerprints(accessibilityScanResults) {  \n  const violationFingerprints = accessibilityScanResults.violations.map(violation => ({  \n    rule: violation.id,  \n    // These are CSS selectors which uniquely identify each element with  \n    // a violation of the rule in question.  \n    targets: violation.nodes.map(node => node.target),  \n  }));  \n  \n  return JSON.stringify(violationFingerprints, null, 2);  \n}", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "After that, specify `storageState` for each test file or test group, **instead of** setting it in the config. | tests/example.spec.ts", "output": "import { test } from '@playwright/test';  \n  \ntest.use({ storageState: 'playwright/.auth/admin.json' });  \n  \ntest('admin test', async ({ page }) => {  \n  // page is authenticated as admin  \n});  \n  \ntest.describe(() => {  \n  test.use({ storageState: 'playwright/.auth/user.json' });  \n  \n  test('user test', async ({ page }) => {  \n    // page is authenticated as a user  \n  });  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect(page.getByText(/welcome, [A-Za-z]+$/i)).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: New options `stderr` and `stdout` in [testConfig.webServer](/docs/api/class-testconfig#test-config-web-server) to configure output handling: | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Run your local dev server before starting the tests  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n    stdout: 'pipe',  \n    stderr: 'pipe',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test(`example test`, async ({ page }) => {  \n  // ...  \n  await page.getByLabel('User Name').fill(process.env.USER_NAME);  \n  await page.getByLabel('Password').fill(process.env.PASSWORD);  \n});", "output": "test(`example test`, async ({ page }) => {  \n  // ...  \n  await page.getByLabel('User Name').fill(process.env.USER_NAME);  \n  await page.getByLabel('Password').fill(process.env.PASSWORD);  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-parameterize", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.locator('li', { hasText: 'my item' }).locator('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Introduction\u200b | Here is a quick way to capture a screenshot and save it into a file:", "input": "", "output": "await page.screenshot({ path: 'screenshot.png' });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/screenshots"}}
{"instruction": "Generate a Playwright test for the following scenario: Consistent time and timers\u200b | Sometimes your timers depend on `Date.now` and are confused when the `Date.now` value does not change over time. In this case, you can install the clock and fast forward to the time of interest when testing.", "input": "", "output": "<div id=\"current-time\" data-testid=\"current-time\"></div>  \n<script>  \n  const renderTime = () => {  \n    document.getElementById('current-time').textContent =  \n        new Date().toLocaleString();  \n  };  \n  setInterval(renderTime, 1000);  \n</script>  \n\n\n\n// Initialize clock with some time before the test time and let the page load  \n// naturally. `Date.now` will progress as the timers fire.  \nawait page.clock.install({ time: new Date('2024-02-02T08:00:00') });  \nawait page.goto('http://localhost:3333');  \n  \n// Pretend that the user closed the laptop lid and opened it again at 10am,  \n// Pause the time once reached that point.  \nawait page.clock.pauseAt(new Date('2024-02-02T10:00:00'));  \n  \n// Assert the page state.  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \n// Close the laptop lid again and open it at 10:30am.  \nawait page.clock.fastForward('30:00');  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:30:00 AM');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/clock"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "* disables animations\n* uses CSS scale option\n\n    await page.navigate('https://playwright.dev');  \nawait assert(page).toHaveScreenshot();", "output": "* disables animations\n* uses CSS scale option\n\n    await page.goto('https://playwright.dev');  \nawait expect(page).toHaveScreenshot();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "First, add fixtures that will load the extension: | fixtures.ts", "output": "import { test as base, chromium, type BrowserContext } from '@playwright/test';  \nimport path from 'path';  \n  \nexport const test = base.extend<{  \n  context: BrowserContext;  \n  extensionId: string;  \n}>({  \n  context: async ({ }, use) => {  \n    const pathToExtension = path.join(__dirname, 'my-extension');  \n    const context = await chromium.launchPersistentContext('', {  \n      headless: false,  \n      args: [  \n        `--disable-extensions-except=${pathToExtension}`,  \n        `--load-extension=${pathToExtension}`,  \n      ],  \n    });  \n    await use(context);  \n    await context.close();  \n  },  \n  extensionId: async ({ context }, use) => {  \n    /*  \n    // for manifest v2:  \n    let [background] = context.backgroundPages()  \n    if (!background)  \n      background = await context.waitForEvent('backgroundpage')  \n    */  \n  \n    // for manifest v3:  \n    let [background] = context.serviceWorkers();  \n    if (!background)  \n      background = await context.waitForEvent('serviceworker');  \n  \n    const extensionId = background.url().split('/')[2];  \n    await use(extensionId);  \n  },  \n});  \nexport const expect = test.expect;", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/chrome-extensions"}}
{"instruction": "Generate a Playwright test for the following scenario: Hide implementation details: box test steps\u200b | You can mark a [test.step()](/docs/api/class-test#test-step) as \"boxed\" so that errors inside it point to the step call site.", "input": "", "output": "async function login(page) {  \n  await test.step('login', async () => {  \n    // ...  \n  }, { box: true });  // Note the \"box\" option here.  \n}  \n\n\n\nError: Timed out 5000ms waiting for expect(locator).toBeVisible()  \n  ... error details omitted ...  \n  \n  14 |   await page.goto('https://github.com/login');  \n> 15 |   await login(page);  \n     |         ^  \n  16 | });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Wait for a locator to resolve to a single element with a given state. Defaults to the `state: 'visible'`. | Comes especially handy when working with lists:", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('context fetch', async ({ page }) => {  \n  const completeness = page.locator('text=Success');  \n  await completeness.waitFor();  \n  expect(await page.screenshot()).toMatchSnapshot('screen.png');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Click a button with accessible name \"log in\"  \nawait page.locator('role=button[name=\"log in\"]').click();", "output": "// Click a button with accessible name \"log in\"  \nawait page.locator('role=button[name=\"log in\"]').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "`:nth-match()` is also useful to wait until a specified number of elements appear, using [locator.waitFor()](/docs/api/class-locator#locator-wait-for).", "output": "// Wait until all three buttons are visible  \nawait page.locator(':nth-match(:text(\"Buy\"), 3)').waitFor();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from './my-test';  \n  \ntest.beforeEach(async ({ settingsPage }) => {  \n  await settingsPage.switchToDarkMode();  \n});  \n  \ntest('basic test', async ({ todoPage, page }) => {  \n  await todoPage.addToDo('something nice');  \n  await expect(page.getByTestId('todo-title')).toContainText(['something nice']);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: You can now import using the mapped paths: | example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \nimport { username, password } from '@myhelper/credentials';  \n  \ntest('example', async ({ page }) => {  \n  await page.getByLabel('User Name').fill(username);  \n  await page.getByLabel('Password').fill(password);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-typescript"}}
{"instruction": "Generate a Playwright test for the following scenario: playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    proxy: {  \n      server: 'http://myproxy.com:3128',  \n      username: 'usr',  \n      password: 'pwd'  \n    }  \n  }  \n});  \n\n\n\nconst browser = await chromium.launch({  \n  proxy: {  \n    server: 'http://myproxy.com:3128',  \n    username: 'usr',  \n    password: 'pwd'  \n  }  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Create a Playwright test that demonstrates the form_interaction pattern.", "input": "For example, consider the following test file that needs a username and a password. It is usually a good idea not to store your secrets in the source code, so we'll need a way to pass secrets from outside. | example.spec.ts", "output": "test(`example test`, async ({ page }) => {  \n  // ...  \n  await page.getByLabel('User Name').fill(process.env.USER_NAME);  \n  await page.getByLabel('Password').fill(process.env.PASSWORD);  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Most of the time, scripts will need to wait for a particular event to happen. Below are some of the typical event awaiting patterns. | Wait for a request with the specified url using [page.waitForRequest()](/docs/api/class-page#page-wait-for-request):", "output": "// Start waiting for request before goto. Note no await.  \nconst requestPromise = page.waitForRequest('**/*logo*.png');  \nawait page.goto('https://wikipedia.org');  \nconst request = await requestPromise;  \nconsole.log(request.url());", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/events"}}
{"instruction": "Generate a Playwright test for the following scenario: If you don't have input element in hand (it is created dynamically), you can handle the [page.on('filechooser')](/docs/api/class-page#page-event-file-chooser) event or use a corresponding waiting method upon your action:", "input": "", "output": "// Start waiting for file chooser before clicking. Note no await.  \nconst fileChooserPromise = page.waitForEvent('filechooser');  \nawait page.getByLabel('Upload file').click();  \nconst fileChooser = await fileChooserPromise;  \nawait fileChooser.setFiles(path.join(__dirname, 'myfile.pdf'));", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Note that all methods that create a locator, such as [page.getByLabel()](/docs/api/class-page#page-get-by-label), are also available on the [Locator](/docs/api/class-locator \"Locator\") and [FrameLocator](/docs/api/class-framelocator \"FrameLocator\") classes, so you can chain them and iteratively narrow down your locator.", "output": "const locator = page  \n    .frameLocator('#my-frame')  \n    .getByRole('button', { name: 'Sign in' });  \n  \nawait locator.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Folder for test artifacts such as screenshots, videos, traces, etc.  \n  outputDir: 'test-results',  \n  \n  // path to the global setup files.  \n  globalSetup: require.resolve('./global-setup'),  \n  \n  // path to the global teardown files.  \n  globalTeardown: require.resolve('./global-teardown'),  \n  \n  // Each test is given 30 seconds.  \n  timeout: 30000,  \n  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Folder for test artifacts such as screenshots, videos, traces, etc.  \n  outputDir: 'test-results',  \n  \n  // path to the global setup files.  \n  globalSetup: require.resolve('./global-setup'),  \n  \n  // path to the global teardown files.  \n  globalTeardown: require.resolve('./global-teardown'),  \n  \n  // Each test is given 30 seconds.  \n  timeout: 30000,  \n  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-configuration", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: New method [`expect.configure`](/docs/test-assertions#expectconfigure) to create pre-configured expect instance with its own defaults such as `timeout` and `soft`.", "input": "", "output": "const slowExpect = expect.configure({ timeout: 10000 });  \nawait slowExpect(locator).toHaveText('Submit');  \n  \n// Always do soft assertions.  \nconst softExpect = expect.configure({ soft: true });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "You can locate in the same way as if the shadow root was not present at all. | To click `<div>Details</div>`:", "output": "await page.getByText('Details').click();  \n\n\n\n<x-details role=button aria-expanded=true aria-controls=inner-details>  \n  <div>Title</div>  \n  #shadow-root  \n    <div id=inner-details>Details</div>  \n</x-details>", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test('test full report', {  \n  annotation: [  \n    { type: 'issue', description: 'https://github.com/microsoft/playwright/issues/23180' },  \n    { type: 'docs', description: 'https://playwright.dev/docs/test-annotations#tag-tests' },  \n  ],  \n}, async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Set the base URL and storage state for all tests: | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Base URL to use in actions like `await page.goto('/')`.  \n    baseURL: 'http://127.0.0.1:3000',  \n  \n    // Populates context with given storage state.  \n    storageState: 'state.json',  \n  },  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-use-options"}}
{"instruction": "Generate a Playwright test for the following scenario: Use [test.describe.serial()](/docs/api/class-test#test-describe-serial) to group dependent tests to ensure they will always run together and in order. If one of the tests fails, all subsequent tests are skipped. All tests in the group are retried together. | Consider the following snippet that uses `test.describe.serial`:", "input": "", "output": "import { test } from '@playwright/test';  \n  \ntest.describe.configure({ mode: 'serial' });  \n  \ntest.beforeAll(async () => { /* ... */ });  \ntest('first good', async ({ page }) => { /* ... */ });  \ntest('second flaky', async ({ page }) => { /* ... */ });  \ntest('third good', async ({ page }) => { /* ... */ });", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-retries"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "In this case, `:nth-match(:text(\"Buy\"), 3)` will select the third button from the snippet above. Note that index is one-based.", "output": "// Click the third \"Buy\" button  \nawait page.locator(':nth-match(:text(\"Buy\"), 3)').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/test';  \n  \ntest('example test', async ({ page, context }) => {  \n  // \"context\" is an isolated BrowserContext, created for this specific test.  \n  // \"page\" belongs to this context.  \n});  \n  \ntest('another test', async ({ page, context }) => {  \n  // \"context\" and \"page\" in this second test are completely  \n  // isolated from the first test.  \n});  \n\n\n\nconst browser = await chromium.launch();  \nconst context = await browser.newContext();  \nconst page = await context.newPage();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/browser-contexts", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Here is an example of reusing your existing MSW handlers in the test.", "output": "import { handlers } from '@src/mocks/handlers';  \n  \ntest.beforeEach(async ({ router }) => {  \n  // install common handlers before each test  \n  await router.use(...handlers);  \n});  \n  \ntest('example test', async ({ mount }) => {  \n  // test as usual, your handlers are active  \n  // ...  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "tests/example.spec.ts", "output": "// Import test with our new fixtures.  \nimport { test, expect } from '../playwright/fixtures';  \n  \n// Use adminPage and userPage fixtures in the test.  \ntest('admin and user', async ({ adminPage, userPage }) => {  \n  // ... interact with both adminPage and userPage ...  \n  await expect(adminPage.greeting).toHaveText('Welcome, Admin');  \n  await expect(userPage.greeting).toHaveText('Welcome, User');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Generate a Playwright test for the following scenario: By default, the report is written into the `blob-report` directory in the package.json directory or current working directory (if no package.json is found). The report file name looks like `report-<hash>.zip` or `report-<hash>-<shard_number>.zip` when [sharding](/docs/test-sharding) is used. The hash is an optional value computed from `--grep`, `--grepInverted`, `--project` and file filters passed as command line arguments. The hash guarantees that running Playwright with different command line options will produce different but stable between runs report names. The output file name can be overridden in the configuration file or pass as `'PLAYWRIGHT_BLOB_OUTPUT_FILE'` environment variable. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['blob', { outputFile: `./blob-report/report-${os.platform()}.zip` }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Start waiting for popup before clicking. Note no await.  \nconst popupPromise = page.waitForEvent('popup');  \nawait page.getByText('open the popup').click();  \nconst popup = await popupPromise;  \nawait popup.goto('https://wikipedia.org');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/events", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect(page.getByRole('button')).toHaveAttribute('disabled', '');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Set timeout for a single action\u200b | example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('basic test', async ({ page }) => {  \n  await page.goto('https://playwright.dev', { timeout: 30000 });  \n  await page.getByText('Get Started').click({ timeout: 10000 });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "electronApp.on('console', async msg => {  \n  const values = [];  \n  for (const arg of msg.args())  \n    values.push(await arg.jsonValue());  \n  console.log(...values);  \n});  \nawait electronApp.evaluate(() => console.log('hello', 5, { foo: 'bar' }));", "output": "electronApp.on('console', async msg => {  \n  const values = [];  \n  for (const arg of msg.args())  \n    values.push(await arg.jsonValue());  \n  console.log(...values);  \n});  \nawait electronApp.evaluate(() => console.log('hello', 5, { foo: 'bar' }));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "The difference between the [Locator](/docs/api/class-locator) and [ElementHandle](/docs/api/class-elementhandle) is that the latter points to a particular element, while [Locator](/docs/api/class-locator) captures the logic of how to retrieve that element. | Also, locators are **\"strict\" by default**!", "output": "const locator = page.locator('button');  \nawait locator.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "navigation"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "// Poll the method until it returns an expected result.  \nawait expect.poll(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  return response.status();  \n}).toBe(200);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "In configuration file, pass options directly: | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['html', { outputFolder: 'my-report' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: 'line',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Once this is done you can navigate the page and check its UI state:", "output": "// Configure mock API before each test.  \ntest.beforeEach(async ({ page }) => {  \n  await page.addInitScript(() => {  \n    const mockBattery = {  \n      level: 0.90,  \n      charging: true,  \n      chargingTime: 1800, // seconds  \n      dischargingTime: Infinity,  \n      addEventListener: () => { }  \n    };  \n    // Override the method to always return mock battery info.  \n    window.navigator.getBattery = async () => mockBattery;  \n  });  \n});  \n  \ntest('show battery status', async ({ page }) => {  \n  await page.goto('/');  \n  await expect(page.locator('.battery-percentage')).toHaveText('90%');  \n  await expect(page.locator('.battery-status')).toHaveText('Adapter');  \n  await expect(page.locator('.battery-fully')).toHaveText('00:30');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock-browser-apis"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "component.spec.ts", "output": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('slot', async ({ mount }) => {  \n  const component = await mount(Component, { slots: { default: 'Slot' } });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Start waiting for file chooser before clicking. Note no await.  \nconst fileChooserPromise = page.waitForEvent('filechooser');  \nawait page.getByLabel('Upload file').click();  \nconst fileChooser = await fileChooserPromise;  \nawait fileChooser.setFiles(path.join(__dirname, 'myfile.pdf'));", "output": "// Start waiting for file chooser before clicking. Note no await.  \nconst fileChooserPromise = page.waitForEvent('filechooser');  \nawait page.getByLabel('Upload file').click();  \nconst fileChooser = await fileChooserPromise;  \nawait fileChooser.setFiles(path.join(__dirname, 'myfile.pdf'));", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \nimport { username, password } from '@myhelper/credentials';  \n  \ntest('example', async ({ page }) => {  \n  await page.getByLabel('User Name').fill(username);  \n  await page.getByLabel('Password').fill(password);  \n});", "output": "import { test, expect } from '@playwright/test';  \nimport { username, password } from '@myhelper/credentials';  \n  \ntest('example', async ({ page }) => {  \n  await page.getByLabel('User Name').fill(username);  \n  await page.getByLabel('Password').fill(password);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-typescript", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test('should work', async ({ page }) => {  \n  const pageTitle = await test.step('get title', async () => {  \n    await page.goto('https://playwright.dev');  \n    return await page.title();  \n  });  \n  console.log(pageTitle);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig, devices } from '@playwright/experimental-ct-vue';  \n  \nimport { resolve } from 'path';  \nimport vue from '@vitejs/plugin-vue';  \nimport AutoImport from 'unplugin-auto-import/vite';  \nimport Components from 'unplugin-vue-components/vite';  \n  \nexport default defineConfig({  \n  testDir: './tests/component',  \n  use: {  \n    trace: 'on-first-retry',  \n    ctViteConfig: {  \n      plugins: [  \n        vue(),  \n        AutoImport({  \n          imports: [  \n            'vue',  \n            'vue-router',  \n            '@vueuse/head',  \n            'pinia',  \n            {  \n              '@/store': ['useStore'],  \n            },  \n          ],  \n          dts: 'src/auto-imports.d.ts',  \n          eslintrc: {  \n            enabled: true,  \n          },  \n        }),  \n        Components({  \n          dirs: ['src/components'],  \n          extensions: ['vue'],  \n        }),  \n      ],  \n      resolve: {  \n        alias: {  \n          '@': resolve(__dirname, './src'),  \n        },  \n      },  \n    },  \n  },  \n});", "output": "import { defineConfig, devices } from '@playwright/experimental-ct-vue';  \n  \nimport { resolve } from 'path';  \nimport vue from '@vitejs/plugin-vue';  \nimport AutoImport from 'unplugin-auto-import/vite';  \nimport Components from 'unplugin-vue-components/vite';  \n  \nexport default defineConfig({  \n  testDir: './tests/component',  \n  use: {  \n    trace: 'on-first-retry',  \n    ctViteConfig: {  \n      plugins: [  \n        vue(),  \n        AutoImport({  \n          imports: [  \n            'vue',  \n            'vue-router',  \n            '@vueuse/head',  \n            'pinia',  \n            {  \n              '@/store': ['useStore'],  \n            },  \n          ],  \n          dts: 'src/auto-imports.d.ts',  \n          eslintrc: {  \n            enabled: true,  \n          },  \n        }),  \n        Components({  \n          dirs: ['src/components'],  \n          extensions: ['vue'],  \n        }),  \n      ],  \n      resolve: {  \n        alias: {  \n          '@': resolve(__dirname, './src'),  \n        },  \n      },  \n    },  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Dragging manually\u200b | If you want precise control over the drag operation, use lower-level methods like [locator.hover()](/docs/api/class-locator#locator-hover), [mouse.down()](/docs/api/class-mouse#mouse-down), [mouse.move()](/docs/api/class-mouse#mouse-move) and [mouse.up()](/docs/api/class-mouse#mouse-up).", "input": "", "output": "await page.locator('#item-to-be-dragged').hover();  \nawait page.mouse.down();  \nawait page.locator('#item-to-drop-at').hover();  \nawait page.mouse.up();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Using dependencies allows global setup to produce traces and other artifacts, see the setup steps in the test report and more. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'setup',  \n      testMatch: /global.setup\\.ts/,  \n    },  \n    {  \n      name: 'chromium',  \n      use: devices['Desktop Chrome'],  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'firefox',  \n      use: devices['Desktop Firefox'],  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'webkit',  \n      use: devices['Desktop Safari'],  \n      dependencies: ['setup'],  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: Focus element\u200b | For the dynamic pages that handle focus events, you can focus the given element with [locator.focus()](/docs/api/class-locator#locator-focus).", "input": "", "output": "await page.getByLabel('Password').focus();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Generate a Playwright test for the following scenario: The snapshot name `example-test-1-chromium-darwin.png` consists of a few parts: | `example-test-1.png` \\- an auto-generated name of the snapshot. Alternatively you can specify snapshot name as the first argument of the `toHaveScreenshot()` method:", "input": "", "output": "await expect(page).toHaveScreenshot('landing.png');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots"}}
{"instruction": "Generate a Playwright test for the following scenario: This will only find a second button, because it is visible, and then click it.", "input": "", "output": "await page.locator('button').locator('visible=true').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Full page screenshots\u200b | Full page screenshot is a screenshot of a full scrollable page, as if you had a very tall screen and the page could fit it entirely.", "output": "await page.screenshot({ path: 'screenshot.png', fullPage: true });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/screenshots"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Rest of your config...  \n  \n  // Run your local dev server before starting the tests  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n  },  \n  use: {  \n    baseURL: 'http://127.0.0.1:3000',  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Rest of your config...  \n  \n  // Run your local dev server before starting the tests  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n  },  \n  use: {  \n    baseURL: 'http://127.0.0.1:3000',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-webserver", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/experimental-ct-vue';  \nimport { Component } from './mycomponent';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(Component, {  \n    hooksConfig: {  \n      /* anything to configure your app */  \n    }  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const rowLocator = page.getByRole('listitem');  \n  \nawait rowLocator  \n    .filter({ hasText: 'Mary' })  \n    .filter({ has: page.getByRole('button', { name: 'Say goodbye' }) })  \n    .screenshot({ path: 'screenshot.png' });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['list', { printSteps: true }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "New assertion [expect(locator).toBeInViewport()](/docs/api/class-locatorassertions#locator-assertions-to-be-in-viewport) ensures that locator points to an element that intersects viewport, according to the [intersection observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API).", "output": "const button = page.getByRole('button');  \n  \n// Make sure at least some part of element intersects viewport.  \nawait expect(button).toBeInViewport();  \n  \n// Make sure element is fully outside of viewport.  \nawait expect(button).not.toBeInViewport();  \n  \n// Make sure that at least half of the element intersects viewport.  \nawait expect(button).toBeInViewport({ ratio: 0.5 });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('loads page without images', async ({ page }) => {  \n  // Block png and jpeg images.  \n  await page.route(/(png|jpeg)$/, route => route.abort());  \n  \n  await page.goto('https://playwright.dev');  \n  // ... test goes here  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/network", "type": "completion"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await page.getByLabel('User Name').fill('John');  \n  \nawait page.getByLabel('Password').fill('secret-password');  \n  \nawait page.getByRole('button', { name: 'Sign in' }).click();  \n  \nawait expect(page.getByText('Welcome, John!')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "completion"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "test.spec.ts", "output": "import { test } from './fixtures';  \n  \ntest('passes', async ({ database, page, a11y }) => {  \n  // use database and a11y fixtures.  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/release-notes", "type": "fixture"}}
{"instruction": "Generate a Playwright test for the following scenario: A [Page](/docs/api/class-page \"Page\") can have one or more [Frame](/docs/api/class-frame \"Frame\") objects attached to it. Each page has a main frame and page-level interactions (like `click`) are assumed to operate in the main frame. | A page can have additional frames attached with the `iframe` HTML tag. These frames can be accessed for interactions inside the frame.", "input": "", "output": "// Locate element inside frame  \nconst username = await page.frameLocator('.frame-class').getByLabel('User Name');  \nawait username.fill('John');", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/frames"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    userAgent: 'some custom ua',  \n    viewport: { width: 100, height: 100 },  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Note that all other reporters work on GitHub Actions as well, but do not provide annotations. Also, it is not recommended to use this annotation type if running your tests with a matrix strategy as the stack trace failures will multiply and obscure the GitHub file view. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // 'github' for GitHub Actions CI to generate annotations, plus a concise 'dot'  \n  // default 'list' when running locally  \n  reporter: process.env.CI ? 'github' : 'list',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Generate a Playwright test for the following scenario: Box fixtures\u200b | Usually, custom fixtures are reported as separate steps in in the UI mode, Trace Viewer and various test reports. They also appear in error messages from the test runner. For frequently-used fixtures, this can mean lots of noise. You can stop the fixtures steps from being shown in the UI by \"boxing\" it.", "input": "", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  helperFixture: [async ({}, use, testInfo) => {  \n    // ...  \n  }, { box: true }],  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test for the following scenario: Create a new `setup` project in the config and declare it as a [dependency](/docs/test-projects#dependencies) for all your testing projects. This project will always run and authenticate before all the tests. All testing projects should use the authenticated state as `storageState`. | playwright.config.ts", "input": "", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    // Setup project  \n    { name: 'setup', testMatch: /.*\\.setup\\.ts/ },  \n  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        // Use prepared auth state.  \n        storageState: 'playwright/.auth/user.json',  \n      },  \n      dependencies: ['setup'],  \n    },  \n  \n    {  \n      name: 'firefox',  \n      use: {  \n        ...devices['Desktop Firefox'],  \n        // Use prepared auth state.  \n        storageState: 'playwright/.auth/user.json',  \n      },  \n      dependencies: ['setup'],  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect(page  \n    .getByRole('listitem')  \n    .filter({ hasNot: page.getByText('Product 2') }))  \n    .toHaveCount(1);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import type { Page, Locator } from '@playwright/test';  \n  \nexport class TodoPage {  \n  private readonly inputBox: Locator;  \n  private readonly todoItems: Locator;  \n  \n  constructor(public readonly page: Page) {  \n    this.inputBox = this.page.locator('input.new-todo');  \n    this.todoItems = this.page.getByTestId('todo-item');  \n  }  \n  \n  async goto() {  \n    await this.page.navigate('https://demo.playwright.dev/todomvc/');  \n  }  \n  \n  async addToDo(text: string) {  \n    await this.inputBox.fill(text);  \n    await this.inputBox.press('Enter');  \n  }  \n  \n  async remove(text: string) {  \n    const todo = this.todoItems.filter({ hasText: text });  \n    await todo.hover();  \n    await todo.getByLabel('Delete').click();  \n  }  \n  \n  async removeAll() {  \n    while ((await this.todoItems.count()) > 0) {  \n      await this.todoItems.first().hover();  \n      await this.todoItems.getByLabel('Delete').first().click();  \n    }  \n  }  \n}", "output": "import type { Page, Locator } from '@playwright/test';  \n  \nexport class TodoPage {  \n  private readonly inputBox: Locator;  \n  private readonly todoItems: Locator;  \n  \n  constructor(public readonly page: Page) {  \n    this.inputBox = this.page.locator('input.new-todo');  \n    this.todoItems = this.page.getByTestId('todo-item');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://demo.playwright.dev/todomvc/');  \n  }  \n  \n  async addToDo(text: string) {  \n    await this.inputBox.fill(text);  \n    await this.inputBox.press('Enter');  \n  }  \n  \n  async remove(text: string) {  \n    const todo = this.todoItems.filter({ hasText: text });  \n    await todo.hover();  \n    await todo.getByLabel('Delete').click();  \n  }  \n  \n  async removeAll() {  \n    while ((await this.todoItems.count()) > 0) {  \n      await this.todoItems.first().hover();  \n      await this.todoItems.getByLabel('Delete').first().click();  \n    }  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { chromium, firefox, webkit } from '@playwright/test';  \n/* ... */", "output": "import { chromium, firefox, webkit } from '@playwright/test';  \n/* ... */", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "<div id=\"current-time\" data-testid=\"current-time\"></div>  \n<script>  \n  const renderTime = () => {  \n    document.getElementById('current-time').textContent =  \n        new Date().toLocaleString();  \n  };  \n  setInterval(renderTime, 1000);  \n</script>  \n\n\n\n// Initialize clock with a specific time, let the page load naturally.  \nawait page.clock.install({ time: new Date('2024-02-02T08:00:00') });  \nawait page.goto('http://localhost:3333');  \n  \n// Pause the time flow, stop the timers, you now have manual control  \n// over the page time.  \nawait page.clock.pauseAt(new Date('2024-02-02T10:00:00'));  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \n// Tick through time manually, firing all timers in the process.  \n// In this case, time will be updated in the screen 2 times.  \nawait page.clock.runFor(2000);  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:02 AM');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/clock", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You can specify retries for a specific group of tests or a single file with [test.describe.configure()](/docs/api/class-test#test-describe-configure).", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe(() => {  \n  // All tests in this describe group will get 2 retry attempts.  \n  test.describe.configure({ retries: 2 });  \n  \n  test('test 1', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('test 2', async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-retries"}}
{"instruction": "Generate a Playwright test for the following scenario: To do a stand-alone request from node.js to an API endpoint, use **new[`request` fixture](/docs/api/class-fixtures#fixtures-request)**:", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('context fetch', async ({ request }) => {  \n  // Do a GET request on behalf of page  \n  const response = await request.get('http://example.com/foo.json');  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: You can constrain an accessibility scan to only run those rules which are \"tagged\" as corresponding to specific WCAG success criteria by using [`AxeBuilder.withTags()`](https://github.com/dequelabs/axe-core-npm/blob/develop/packages/playwright/README.md#axebuilderwithtagstags-stringarray). For example, [Accessibility Insights for Web's Automated Checks](https://accessibilityinsights.io/docs/web/getstarted/fastpass/?referrer=playwright-accessibility-testing-js) only include axe rules that test for violations of WCAG A and AA success criteria; to match that behavior, you would use the tags `wcag2a`, `wcag2aa`, `wcag21a`, and `wcag21aa`. | Note that automated testing cannot detect all types of WCAG violations.", "input": "", "output": "test('should not have any automatically detectable WCAG A or AA violations', async ({ page }) => {  \n  await page.goto('https://your-site.com/');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])  \n      .analyze();  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { handlers } from '@src/mocks/handlers';  \n  \ntest.beforeEach(async ({ router }) => {  \n  // install common handlers before each test  \n  await router.use(...handlers);  \n});  \n  \ntest('example test', async ({ mount }) => {  \n  // test as usual, your handlers are active  \n  // ...  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Added before v1.9 playwright.devices | Returns a dictionary of devices to be used with [browser.newContext()](/docs/api/class-browser#browser-new-context) or [browser.newPage()](/docs/api/class-browser#browser-new-page).", "input": "", "output": "const { webkit, devices } = require('playwright');  \nconst iPhone = devices['iPhone 6'];  \n  \n(async () => {  \n  const browser = await webkit.launch();  \n  const context = await browser.newContext({  \n    ...iPhone  \n  });  \n  const page = await context.newPage();  \n  await page.goto('http://example.com');  \n  // other actions...  \n  await browser.close();  \n})();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/api/class-playwright"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "component.spec.tsx", "output": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('props', async ({ mount }) => {  \n  const component = await mount(<Component msg=\"greetings\" />);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test for the following scenario: Then we create a `global.teardown.ts` file in the tests directory of your project. This will be used to delete the data from the database after all tests have run. | tests/global.teardown.ts", "input": "", "output": "import { test as teardown } from '@playwright/test';  \n  \nteardown('delete database', async ({ }) => {  \n  console.log('deleting test database...');  \n  // Delete the database  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Locate the element by its role of `button` with name \"Sign in\".", "output": "await page.getByRole('button', { name: 'Sign in' }).click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test for the following scenario: Web apps use cookie-based or token-based authentication, where authenticated state is stored as [cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies). Playwright provides [apiRequestContext.storageState()](/docs/api/class-apirequestcontext#api-request-context-storage-state) method that can be used to retrieve storage state from an authenticated context and then create new contexts with that state. | Storage state is interchangeable between [BrowserContext](/docs/api/class-browsercontext \"BrowserContext\") and [APIRequestContext](/docs/api/class-apirequestcontext \"APIRequestContext\"). You can use it to log in via API calls and then create a new context with cookies already there. The following code snippet retrieves state from an authenticated [APIRequestContext](/docs/api/class-apirequestcontext \"APIRequestContext\") and creates a new [BrowserContext](/docs/api/class-browsercontext \"BrowserContext\") with that state.", "input": "", "output": "const requestContext = await request.newContext({  \n  httpCredentials: {  \n    username: 'user',  \n    password: 'passwd'  \n  }  \n});  \nawait requestContext.get(`https://api.example.com/login`);  \n// Save storage state into the file.  \nawait requestContext.storageState({ path: 'state.json' });  \n  \n// Create a new context with the saved storage state.  \nconst context = await browser.newContext({ storageState: 'state.json' });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/api-testing"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('event', async ({ mount }) => {  \n  const component = await mount(Component, { on: { click() {} } });  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \nimport { PlaywrightDevPage } from './playwright-dev-page';  \n  \ntest('getting started should contain table of contents', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.getStarted();  \n  await expect(playwrightDev.tocList).toHaveText([  \n    `How to install Playwright`,  \n    `What's Installed`,  \n    `How to run the example test`,  \n    `How to open the HTML test report`,  \n    `Write tests using web first assertions, page fixtures and locators`,  \n    `Run single test, multiple tests, headed mode`,  \n    `Generate tests with Codegen`,  \n    `See a trace of your tests`  \n  ]);  \n});  \n  \ntest('should show Page Object Model article', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.pageObjectModel();  \n  await expect(page.locator('article')).toContainText('Page Object Model is a common pattern');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/pom"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "You can also configure `host` and `port` that are used to serve the HTML report. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['html', { open: 'never' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('unmount', async ({ mount }) => {  \n  const component = await mount(Component);  \n  await component.unmount();  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.locator('button').locator('visible=true').click();", "output": "await page.locator('button').locator('visible=true').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You can now import using the mapped paths: | example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \nimport { username, password } from '@myhelper/credentials';  \n  \ntest('example', async ({ page }) => {  \n  await page.getByLabel('User Name').fill(username);  \n  await page.getByLabel('Password').fill(password);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-typescript"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  globalSetup: require.resolve('./global-setup'),  \n  globalTeardown: require.resolve('./global-teardown'),  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  globalSetup: require.resolve('./global-setup'),  \n  globalTeardown: require.resolve('./global-teardown'),  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "component.spec.tsx", "output": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('children', async ({ mount }) => {  \n  const component = await mount(<Component>Child</Component>);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Each test should be completely isolated from another test and should run independently with its own local storage, session storage, data, cookies etc. [Test isolation](/docs/browser-contexts) improves reproducibility, makes debugging easier and prevents cascading test failures. | In order to avoid repetition for a particular part of your test you can use [before and after hooks](/docs/api/class-test). Within your test file add a before hook to run a part of your test before each test such as going to a particular URL or logging in to a part of your app. This keeps your tests isolated as no test relies on another. However it is also ok to have a little duplication when tests are simple enough especially if it keeps your tests clearer and easier to read and maintain.", "output": "import { test } from '@playwright/test';  \n  \ntest.beforeEach(async ({ page }) => {  \n  // Runs before each test and signs in each page.  \n  await page.goto('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('username');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n});  \n  \ntest('first', async ({ page }) => {  \n  // page is signed in.  \n});  \n  \ntest('second', async ({ page }) => {  \n  // page is signed in.  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/best-practices"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const locator = page.getByRole('button');  \nawait assert(locator).toHaveAccessibleDescription('Upload a photo');", "output": "const locator = page.getByRole('button');  \nawait expect(locator).toHaveAccessibleDescription('Upload a photo');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Here is a global setup example that authenticates once and reuses authentication state in tests. It uses the `baseURL` and `storageState` options from the configuration file. | global-setup.ts", "output": "import { chromium, type FullConfig } from '@playwright/test';  \n  \nasync function globalSetup(config: FullConfig) {  \n  const { baseURL, storageState } = config.projects[0].use;  \n  const browser = await chromium.launch();  \n  const page = await browser.newPage();  \n  await page.goto(baseURL!);  \n  await page.getByLabel('User Name').fill('user');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByText('Sign in').click();  \n  await page.context().storageState({ path: storageState as string });  \n  await browser.close();  \n}  \n  \nexport default globalSetup;", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.locator('button').locator('visible=true').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Base URL to use in actions like `await page.navigate('/')`.  \n    baseURL: 'http://127.0.0.1:3000',  \n  \n    // Populates context with given storage state.  \n    storageState: 'state.json',  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Base URL to use in actions like `await page.goto('/')`.  \n    baseURL: 'http://127.0.0.1:3000',  \n  \n    // Populates context with given storage state.  \n    storageState: 'state.json',  \n  },  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-use-options", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect(page.locator('.status')).toHaveText('Submitted');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "It is now possible to do response interception by combining [API Testing](/docs/api-testing) with [request interception](/docs/network#modify-requests). | For example, we can blur all the images on the page:", "output": "import { test, expect } from '@playwright/test';  \nimport jimp from 'jimp'; // image processing library  \n  \ntest('response interception', async ({ page }) => {  \n  await page.route('**/*.jpeg', async route => {  \n    const response = await page._request.fetch(route.request());  \n    const image = await jimp.read(await response.body());  \n    await image.blur(5);  \n    await route.fulfill({  \n      response,  \n      body: await image.getBufferAsync('image/jpeg'),  \n    });  \n  });  \n  const response = await page.goto('https://playwright.dev');  \n  expect(response.status()).toBe(200);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test.beforeEach(async ({ page }) => {  \n  // ...  \n});  \n  \ntest.afterEach(async ({ page }) => {  \n  // ...  \n});  \n  \n[  \n  { name: 'Alice', expected: 'Hello, Alice!' },  \n  { name: 'Bob', expected: 'Hello, Bob!' },  \n  { name: 'Charlie', expected: 'Hello, Charlie!' },  \n].forEach(({ name, expected }) => {  \n  test(`testing with ${name}`, async ({ page }) => {  \n    await page.goto(`https://example.com/greet?name=${name}`);  \n    await expect(page.getByRole('heading')).toHaveText(expected);  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parameterize", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  await page.navigate('https://playwright.dev/');  \n  await page.getByRole('link', { name: 'Get started' }).click();  \n  await assert(page.getByLabel('Breadcrumbs').getByRole('list')).toContainText('Installation');  \n  await assert(page.getByLabel('Search')).toBeVisible();  \n  await page.getByLabel('Search').click();  \n  await page.getByPlaceholder('Search docs').fill('locator');  \n  await assert(page.getByPlaceholder('Search docs')).toHaveValue('locator');  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  await page.getByRole('link', { name: 'Get started' }).click();  \n  await expect(page.getByLabel('Breadcrumbs').getByRole('list')).toContainText('Installation');  \n  await expect(page.getByLabel('Search')).toBeVisible();  \n  await page.getByLabel('Search').click();  \n  await page.getByPlaceholder('Search docs').fill('locator');  \n  await expect(page.getByPlaceholder('Search docs')).toHaveValue('locator');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "[  \n  { name: 'Alice', asserted: 'Hello, Alice!' },  \n  { name: 'Bob', asserted: 'Hello, Bob!' },  \n  { name: 'Charlie', asserted: 'Hello, Charlie!' },  \n].forEach(({ name, asserted }) => {  \n  test.describe(() => {  \n    test.beforeEach(async ({ page }) => {  \n      await page.navigate(`https://example.com/greet?name=${name}`);  \n    });  \n    test(`testing with ${asserted}`, async ({ page }) => {  \n      await assert(page.getByRole('heading')).toHaveText(asserted);  \n    });  \n  });  \n});", "output": "[  \n  { name: 'Alice', expected: 'Hello, Alice!' },  \n  { name: 'Bob', expected: 'Hello, Bob!' },  \n  { name: 'Charlie', expected: 'Hello, Charlie!' },  \n].forEach(({ name, expected }) => {  \n  test.describe(() => {  \n    test.beforeEach(async ({ page }) => {  \n      await page.goto(`https://example.com/greet?name=${name}`);  \n    });  \n    test(`testing with ${expected}`, async ({ page }) => {  \n      await expect(page.getByRole('heading')).toHaveText(expected);  \n    });  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parameterize", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test('gets the json from api and adds a new fruit', async ({ page }) => {  \n  // Get the response and add to it  \n  await page.route('*/**/api/v1/fruits', async route => {  \n    const response = await route.fetch();  \n    const json = await response.json();  \n    json.push({ name: 'Loquat', id: 100 });  \n    // Fulfill using the original response, while patching the response body  \n    // with the given JSON object.  \n    await route.fulfill({ response, json });  \n  });  \n  \n  // Go to the page  \n  await page.navigate('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the new fruit is visible  \n  await assert(page.getByText('Loquat', { exact: true })).toBeVisible();  \n});", "output": "test('gets the json from api and adds a new fruit', async ({ page }) => {  \n  // Get the response and add to it  \n  await page.route('*/**/api/v1/fruits', async route => {  \n    const response = await route.fetch();  \n    const json = await response.json();  \n    json.push({ name: 'Loquat', id: 100 });  \n    // Fulfill using the original response, while patching the response body  \n    // with the given JSON object.  \n    await route.fulfill({ response, json });  \n  });  \n  \n  // Go to the page  \n  await page.goto('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the new fruit is visible  \n  await expect(page.getByText('Loquat', { exact: true })).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.locator('css=button').click();  \nawait page.locator('xpath=//button').click();  \n  \nawait page.locator('button').click();  \nawait page.locator('//button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.getByRole('button').count();", "output": "await page.getByRole('button').count();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('should use custom proxy on a new context', async ({ browser }) => {  \n  const context = await browser.newContext({  \n    proxy: {  \n      server: 'http://myproxy.com:3128',  \n    }  \n  });  \n  const page = await context.newPage();  \n  \n  await context.close();  \n});  \n\n\n\nconst browser = await chromium.launch();  \nconst context = await browser.newContext({  \n  proxy: { server: 'http://myproxy.com:3128' }  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect(page.getByRole('listitem')).toHaveCount(3);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Press the common keyboard shortcut Control+S or Meta+S to trigger a \"Save\" operation.  \nawait page.keyboard.press('ControlOrMeta+S');", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Now **disable parallel execution** by setting workers to one, and specify your test list file. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  workers: 1,  \n  testMatch: 'test.list.ts',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "try {  \n  await page.locator('.foo').waitFor();  \n} catch (e) {  \n  if (e instanceof playwright.errors.TimeoutError) {  \n    // Do something if this is a timeout.  \n  }  \n}", "output": "try {  \n  await page.locator('.foo').waitFor();  \n} catch (e) {  \n  if (e instanceof playwright.errors.TimeoutError) {  \n    // Do something if this is a timeout.  \n  }  \n}", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/api/class-playwright", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['blob', { outputFile: `./blob-report/report-${os.platform()}.zip` }]],  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['blob', { outputFile: `./blob-report/report-${os.platform()}.zip` }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect.poll(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  return response.status();  \n}, {  \n  // Custom expect message for reporting, optional.  \n  message: 'make sure API eventually succeeds',  \n  // Poll for 10 seconds; defaults to 5 seconds. Pass 0 to disable timeout.  \n  timeout: 10000,  \n}).toBe(200);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const { assert } = require('@playwright/test');  \n  \nexports.PlaywrightDevPage = class PlaywrightDevPage {  \n  \n  /**  \n   * @param {import('@playwright/test').Page} page  \n   */  \n  constructor(page) {  \n    this.page = page;  \n    this.getStartedLink = page.locator('a', { hasText: 'Get started' });  \n    this.gettingStartedHeader = page.locator('h1', { hasText: 'Installation' });  \n    this.pomLink = page.locator('li', {  \n      hasText: 'Guides',  \n    }).locator('a', {  \n      hasText: 'Page Object Model',  \n    });  \n    this.tocList = page.locator('article div.markdown ul > li > a');  \n  }  \n  \n  async goto() {  \n    await this.page.navigate('https://playwright.dev');  \n  }  \n  \n  async getStarted() {  \n    await this.getStartedLink.first().click();  \n    await assert(this.gettingStartedHeader).toBeVisible();  \n  }  \n  \n  async pageObjectModel() {  \n    await this.getStarted();  \n    await this.pomLink.click();  \n  }  \n};", "output": "const { expect } = require('@playwright/test');  \n  \nexports.PlaywrightDevPage = class PlaywrightDevPage {  \n  \n  /**  \n   * @param {import('@playwright/test').Page} page  \n   */  \n  constructor(page) {  \n    this.page = page;  \n    this.getStartedLink = page.locator('a', { hasText: 'Get started' });  \n    this.gettingStartedHeader = page.locator('h1', { hasText: 'Installation' });  \n    this.pomLink = page.locator('li', {  \n      hasText: 'Guides',  \n    }).locator('a', {  \n      hasText: 'Page Object Model',  \n    });  \n    this.tocList = page.locator('article div.markdown ul > li > a');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://playwright.dev');  \n  }  \n  \n  async getStarted() {  \n    await this.getStartedLink.first().click();  \n    await expect(this.gettingStartedHeader).toBeVisible();  \n  }  \n  \n  async pageObjectModel() {  \n    await this.getStarted();  \n    await this.pomLink.click();  \n  }  \n};", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/pom", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Scroll the footer into view, forcing an \"infinite list\" to load more content  \nawait page.getByText('Footer text').scrollIntoViewIfNeeded();", "output": "// Scroll the footer into view, forcing an \"infinite list\" to load more content  \nawait page.getByText('Footer text').scrollIntoViewIfNeeded();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Check the checkbox  \nawait page.getByLabel('I agree to the terms above').check();  \n  \n// Assert the checked state  \nexpect(page.getByLabel('Subscribe to newsletter')).toBeChecked();  \n  \n// Select the radio button  \nawait page.getByLabel('XL').check();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/input", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "WebSocket routing\u200b | New methods [page.routeWebSocket()](/docs/api/class-page#page-route-web-socket) and [browserContext.routeWebSocket()](/docs/api/class-browsercontext#browser-context-route-web-socket) allow to intercept, modify and mock WebSocket connections initiated in the page. Below is a simple example that mocks WebSocket communication by responding to a `\"request\"` with a `\"response\"`.", "output": "await page.routeWebSocket('/ws', ws => {  \n  ws.onMessage(message => {  \n    if (message === 'request')  \n      ws.send('response');  \n  });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Playwright 1.17 introduces [frame locators](/docs/api/class-framelocator) \\- a locator to the iframe on the page. Frame locators capture the logic sufficient to retrieve the `iframe` and then locate elements in that iframe. Frame locators are strict by default, will wait for `iframe` to appear and can be used in Web-First assertions. | Frame locators can be created with either [page.frameLocator()](/docs/api/class-page#page-frame-locator) or [locator.frameLocator()](/docs/api/class-locator#locator-frame-locator) method.", "output": "const locator = page.frameLocator('#my-iframe').locator('text=Submit');  \nawait locator.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the page_object pattern.", "input": "models/PlaywrightDevPage.js", "output": "class PlaywrightDevPage {  \n  /**  \n   * @param {import('playwright').Page} page  \n   */  \n  constructor(page) {  \n    this.page = page;  \n    this.getStartedLink = page.locator('a', { hasText: 'Get started' });  \n    this.gettingStartedHeader = page.locator('h1', { hasText: 'Installation' });  \n    this.pomLink = page.locator('li', {  \n      hasText: 'Playwright Test',  \n    }).locator('a', {  \n      hasText: 'Page Object Model',  \n    });  \n    this.tocList = page.locator('article div.markdown ul > li > a');  \n  }  \n  async getStarted() {  \n    await this.getStartedLink.first().click();  \n    await expect(this.gettingStartedHeader).toBeVisible();  \n  }  \n  \n  async pageObjectModel() {  \n    await this.getStarted();  \n    await this.pomLink.click();  \n  }  \n}  \nmodule.exports = { PlaywrightDevPage };", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/pom"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Tests have access to the `process.env` properties set in the global setup.", "output": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  // environment variables which are set in globalSetup are only available inside test().  \n  const { FOO, BAR } = process.env;  \n  \n  // FOO and BAR properties are populated.  \n  expect(FOO).toEqual('some data');  \n  \n  const complexData = JSON.parse(BAR);  \n  expect(BAR).toEqual({ some: 'data' });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "test('should not have any accessibility violations outside of elements with known issues', async ({  \n  page,  \n}) => {  \n  await page.goto('https://your-site.com/page-with-known-issues');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .exclude('#element-with-known-issue')  \n      .analyze();  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Get the element handle  \nconst elementHandle = page.waitForSelector('#box');  \n  \n// Assert bounding box for the element  \nconst boundingBox = await elementHandle.boundingBox();  \nassert(boundingBox.width).toBe(100);  \n  \n// Assert attribute for the element  \nconst classNames = await elementHandle.getAttribute('class');  \nassert(classNames.includes('highlighted')).toBeTruthy();", "output": "// Get the element handle  \nconst elementHandle = page.waitForSelector('#box');  \n  \n// Assert bounding box for the element  \nconst boundingBox = await elementHandle.boundingBox();  \nexpect(boundingBox.width).toBe(100);  \n  \n// Assert attribute for the element  \nconst classNames = await elementHandle.getAttribute('class');  \nexpect(classNames.includes('highlighted')).toBeTruthy();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/handles", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "expect.configure\u200b | You can create your own pre-configured `expect` instance to have its own defaults such as `timeout` and `soft`.", "output": "const slowExpect = expect.configure({ timeout: 10000 });  \nawait slowExpect(locator).toHaveText('Submit');  \n  \n// Always do soft assertions.  \nconst softExpect = expect.configure({ soft: true });  \nawait softExpect(locator).toHaveText('Submit');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('unmount', async ({ mount }) => {  \n  const component = await mount(Component);  \n  await component.unmount();  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "If your application contains many different preexisting violations of a specific rule, you can use [`AxeBuilder.disableRules()`](https://github.com/dequelabs/axe-core-npm/blob/develop/packages/playwright/README.md#axebuilderdisablerulesrules-stringarray) to temporarily disable individual rules until you're able to fix the issues. | You can find the rule IDs to pass to `disableRules()` in the `id` property of the violations you want to suppress. A [complete list of axe's rules](https://github.com/dequelabs/axe-core/blob/master/doc/rule-descriptions.md) can be found in `axe-core`'s documentation.", "output": "test('should not have any accessibility violations outside of rules with known issues', async ({  \n  page,  \n}) => {  \n  await page.goto('https://your-site.com/page-with-known-issues');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .disableRules(['duplicate-id'])  \n      .analyze();  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const slowExpect = expect.configure({ timeout: 10000 });  \nawait slowExpect(locator).toHaveText('Submit');  \n  \n// Always do soft assertions.  \nconst softExpect = expect.configure({ soft: true });  \nawait softExpect(locator).toHaveText('Submit');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  innerFixture: [async ({}, use, testInfo) => {  \n    // ...  \n  }, { title: 'my fixture' }],  \n});", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  innerFixture: [async ({}, use, testInfo) => {  \n    // ...  \n  }, { title: 'my fixture' }],  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  assert: {  \n    toHaveScreenshot: {  \n      stylePath: './screenshot.css'  \n    },  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  expect: {  \n    toHaveScreenshot: {  \n      stylePath: './screenshot.css'  \n    },  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "If using the built-in `browser` fixture, calling [browser.newContext()](/docs/api/class-browser#browser-new-context) will create a context with options inherited from the config: | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    userAgent: 'some custom ua',  \n    viewport: { width: 100, height: 100 },  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Rest of your config...  \n  \n  // Run your local dev server before starting the tests  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n  },  \n  use: {  \n    baseURL: 'http://127.0.0.1:3000',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-webserver", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "my-test.ts", "output": "import { test as base } from '@playwright/test';  \n  \nexport type TestOptions = {  \n  person: string;  \n};  \n  \nexport const test = base.extend<TestOptions>({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  person: ['John', { option: true }],  \n  \n  // Override default \"page\" fixture.  \n  page: async ({ page, person }, use) => {  \n    await page.goto('/chat');  \n    // We use \"person\" parameter as a \"name\" for the chat room.  \n    await page.getByLabel('User Name').fill(person);  \n    await page.getByText('Enter chat room').click();  \n    // Each test will get a \"page\" that already has the person name.  \n    await use(page);  \n  },  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "axe-test.ts", "output": "import { test as base } from '@playwright/test';  \nimport AxeBuilder from '@axe-core/playwright';  \n  \ntype AxeFixture = {  \n  makeAxeBuilder: () => AxeBuilder;  \n};  \n  \n// Extend base test by providing \"makeAxeBuilder\"  \n//  \n// This new \"test\" can be used in multiple test files, and each of them will get  \n// a consistently configured AxeBuilder instance.  \nexport const test = base.extend<AxeFixture>({  \n  makeAxeBuilder: async ({ page }, use, testInfo) => {  \n    const makeAxeBuilder = () => new AxeBuilder({ page })  \n        .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])  \n        .exclude('#commonly-reused-element-with-known-issue');  \n  \n    await use(makeAxeBuilder);  \n  }  \n});  \nexport { expect } from '@playwright/test';  \n\n\n\n// axe-test.js  \nconst base = require('@playwright/test');  \nconst AxeBuilder = require('@axe-core/playwright').default;  \n  \n// Extend base test by providing \"makeAxeBuilder\"  \n//  \n// This new \"test\" can be used in multiple test files, and each of them will get  \n// a consistently configured AxeBuilder instance.  \nexports.test = base.test.extend({  \n  makeAxeBuilder: async ({ page }, use, testInfo) => {  \n    const makeAxeBuilder = () => new AxeBuilder({ page })  \n        .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])  \n        .exclude('#commonly-reused-element-with-known-issue');  \n  \n    await use(makeAxeBuilder);  \n  }  \n});  \nexports.expect = base.expect;", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/accessibility-testing"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "For multi-page scenarios, you can access the video file associated with the page via the [page.video()](/docs/api/class-page#page-video).", "output": "const path = await page.video().path();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/videos"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Glob patterns or regular expressions to ignore test files.  \n  testIgnore: '*test-assets',  \n  \n  // Glob patterns or regular expressions that match test files.  \n  testMatch: '*todo-tests/*.spec.ts',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-configuration", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "The use of [ElementHandle](/docs/api/class-elementhandle \"ElementHandle\") is discouraged, use [Locator](/docs/api/class-locator \"Locator\") objects and web-first assertions instead. | When [ElementHandle](/docs/api/class-elementhandle \"ElementHandle\") is required, it is recommended to fetch it with the [page.waitForSelector()](/docs/api/class-page#page-wait-for-selector) or [frame.waitForSelector()](/docs/api/class-frame#frame-wait-for-selector) methods. These APIs wait for the element to be attached and visible.", "output": "// Get the element handle  \nconst elementHandle = page.waitForSelector('#box');  \n  \n// Assert bounding box for the element  \nconst boundingBox = await elementHandle.boundingBox();  \nexpect(boundingBox.width).toBe(100);  \n  \n// Assert attribute for the element  \nconst classNames = await elementHandle.getAttribute('class');  \nexpect(classNames.includes('highlighted')).toBeTruthy();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/handles"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  expect: {  \n    timeout: 10_000,  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/experimental-ct-vue';  \nimport type { HooksConfig } from '../playwright';  \nimport Store from './Store.vue';  \n  \ntest('override initialState ', async ({ mount }) => {  \n  const component = await mount<HooksConfig>(Store, {  \n    hooksConfig: {  \n      store: { name: 'override initialState' }  \n    }  \n  });  \n  await expect(component).toContainText('override initialState');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: Here is a global setup example that authenticates once and reuses authentication state in tests. It uses the `baseURL` and `storageState` options from the configuration file. | global-setup.ts", "input": "", "output": "import { chromium, type FullConfig } from '@playwright/test';  \n  \nasync function globalSetup(config: FullConfig) {  \n  const { baseURL, storageState } = config.projects[0].use;  \n  const browser = await chromium.launch();  \n  const page = await browser.newPage();  \n  await page.goto(baseURL!);  \n  await page.getByLabel('User Name').fill('user');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByText('Sign in').click();  \n  await page.context().storageState({ path: storageState as string });  \n  await browser.close();  \n}  \n  \nexport default globalSetup;", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "Validating postconditions\u200b | The following test creates a new issue via user interface in the browser and then uses checks if it was created via API:", "output": "import { test, expect } from '@playwright/test';  \n  \nconst REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \n// Request context is reused by all tests in the file.  \nlet apiContext;  \n  \ntest.beforeAll(async ({ playwright }) => {  \n  apiContext = await playwright.request.newContext({  \n    // All requests we send go to this API endpoint.  \n    baseURL: 'https://api.github.com',  \n    extraHTTPHeaders: {  \n      // We set this header per GitHub guidelines.  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add authorization token to all requests.  \n      // Assuming personal access token available in the environment.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    },  \n  });  \n});  \n  \ntest.afterAll(async ({ }) => {  \n  // Dispose all responses.  \n  await apiContext.dispose();  \n});  \n  \ntest('last created issue should be on the server', async ({ page }) => {  \n  await page.goto(`https://github.com/${USER}/${REPO}/issues`);  \n  await page.getByText('New Issue').click();  \n  await page.getByRole('textbox', { name: 'Title' }).fill('Bug report 1');  \n  await page.getByRole('textbox', { name: 'Comment body' }).fill('Bug description');  \n  await page.getByText('Submit new issue').click();  \n  const issueId = page.url().substr(page.url().lastIndexOf('/'));  \n  \n  const newIssue = await apiContext.get(  \n      `https://api.github.com/repos/${USER}/${REPO}/issues/${issueId}`  \n  );  \n  expect(newIssue.ok()).toBeTruthy();  \n  expect(newIssue.json()).toEqual(expect.objectContaining({  \n    title: 'Bug report 1'  \n  }));  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/api-testing"}}
{"instruction": "Generate a Playwright test for the following scenario: Downloaded files are deleted when the browser context that produced them is closed. | Here is the simplest way to handle the file download:", "input": "", "output": "// Start waiting for download before clicking. Note no await.  \nconst downloadPromise = page.waitForEvent('download');  \nawait page.getByText('Download file').click();  \nconst download = await downloadPromise;  \n  \n// Wait for the download process to complete and save the downloaded file somewhere.  \nawait download.saveAs('/path/to/save/at/' + download.suggestedFilename());", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/downloads"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.pause();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/debug", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Consistent time and timers\u200b | Sometimes your timers depend on `Date.now` and are confused when the `Date.now` value does not change over time. In this case, you can install the clock and fast forward to the time of interest when testing.", "output": "<div id=\"current-time\" data-testid=\"current-time\"></div>  \n<script>  \n  const renderTime = () => {  \n    document.getElementById('current-time').textContent =  \n        new Date().toLocaleString();  \n  };  \n  setInterval(renderTime, 1000);  \n</script>  \n\n\n\n// Initialize clock with some time before the test time and let the page load  \n// naturally. `Date.now` will progress as the timers fire.  \nawait page.clock.install({ time: new Date('2024-02-02T08:00:00') });  \nawait page.goto('http://localhost:3333');  \n  \n// Pretend that the user closed the laptop lid and opened it again at 10am,  \n// Pause the time once reached that point.  \nawait page.clock.pauseAt(new Date('2024-02-02T10:00:00'));  \n  \n// Assert the page state.  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \n// Close the laptop lid again and open it at 10:30am.  \nawait page.clock.fastForward('30:00');  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:30:00 AM');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/clock"}}
{"instruction": "Create a Playwright test that demonstrates the form_interaction pattern.", "input": "However, if the property is [configurable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#configurable), you can still override it using the plain JavaScript:", "output": "await page.addInitScript(() => {  \n  Object.defineProperty(Object.getPrototypeOf(navigator), 'cookieEnabled', { value: false });  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/mock-browser-apis"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.locator('article:has(div.promo)').textContent();", "output": "await page.locator('article:has(div.promo)').textContent();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Basic Configuration\u200b | Here are some of the most common configuration options.", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Look for test files in the \"tests\" directory, relative to this configuration file.  \n  testDir: 'tests',  \n  \n  // Run all tests in parallel.  \n  fullyParallel: true,  \n  \n  // Fail the build on CI if you accidentally left test.only in the source code.  \n  forbidOnly: !!process.env.CI,  \n  \n  // Retry on CI only.  \n  retries: process.env.CI ? 2 : 0,  \n  \n  // Opt out of parallel tests on CI.  \n  workers: process.env.CI ? 1 : undefined,  \n  \n  // Reporter to use  \n  reporter: 'html',  \n  \n  use: {  \n    // Base URL to use in actions like `await page.goto('/')`.  \n    baseURL: 'http://127.0.0.1:3000',  \n  \n    // Collect trace when retrying the failed test.  \n    trace: 'on-first-retry',  \n  },  \n  // Configure projects for major browsers.  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n    },  \n  ],  \n  // Run your local dev server before starting the tests.  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n  },  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-configuration"}}
{"instruction": "Generate a Playwright test for the following scenario: You can combine custom matchers from multiple files or modules. | fixtures.ts", "input": "", "output": "import { mergeTests, mergeExpects } from '@playwright/test';  \nimport { test as dbTest, expect as dbExpect } from 'database-test-utils';  \nimport { test as a11yTest, expect as a11yExpect } from 'a11y-test-utils';  \n  \nexport const expect = mergeExpects(dbExpect, a11yExpect);  \nexport const test = mergeTests(dbTest, a11yTest);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "tests/example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  geolocation: { longitude: 41.890221, latitude: 12.492348 },  \n  permissions: ['geolocation'],  \n});  \n  \ntest('my test with geolocation', async ({ page, context }) => {  \n  // overwrite the location for this test  \n  await context.setGeolocation({ longitude: 48.858455, latitude: 2.294474 });  \n});  \n\n\n\nawait context.setGeolocation({ longitude: 48.858455, latitude: 2.294474 });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/test';  \n  \ntest('admin and user', async ({ browser }) => {  \n  // adminContext and all pages inside, including adminPage, are signed in as \"admin\".  \n  const adminContext = await browser.newContext({ storageState: 'playwright/.auth/admin.json' });  \n  const adminPage = await adminContext.newPage();  \n  \n  // userContext and all pages inside, including userPage, are signed in as \"user\".  \n  const userContext = await browser.newContext({ storageState: 'playwright/.auth/user.json' });  \n  const userPage = await userContext.newPage();  \n  \n  // ... interact with both adminPage and userPage ...  \n  \n  await adminContext.close();  \n  await userContext.close();  \n});", "output": "import { test } from '@playwright/test';  \n  \ntest('admin and user', async ({ browser }) => {  \n  // adminContext and all pages inside, including adminPage, are signed in as \"admin\".  \n  const adminContext = await browser.newContext({ storageState: 'playwright/.auth/admin.json' });  \n  const adminPage = await adminContext.newPage();  \n  \n  // userContext and all pages inside, including userPage, are signed in as \"user\".  \n  const userContext = await browser.newContext({ storageState: 'playwright/.auth/user.json' });  \n  const userPage = await userContext.newPage();  \n  \n  // ... interact with both adminPage and userPage ...  \n  \n  await adminContext.close();  \n  await userContext.close();  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/auth", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Programmatic click\u200b | If you are not interested in testing your app under the real conditions and want to simulate the click by any means possible, you can trigger the [`HTMLElement.click()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click) behavior via simply dispatching a click event on the element with [locator.dispatchEvent()](/docs/api/class-locator#locator-dispatch-event):", "output": "await page.getByRole('button').dispatchEvent('click');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, type Page } from '@playwright/test';  \n  \n// Annotate entire file as serial.  \ntest.describe.configure({ mode: 'serial' });  \n  \nlet page: Page;  \n  \ntest.beforeAll(async ({ browser }) => {  \n  page = await browser.newPage();  \n});  \n  \ntest.afterAll(async () => {  \n  await page.close();  \n});  \n  \ntest('runs first', async () => {  \n  await page.goto('https://playwright.dev/');  \n});  \n  \ntest('runs second', async () => {  \n  await page.getByText('Get Started').click();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-parallel", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Locators Update\u200b | Use [locator.or()](/docs/api/class-locator#locator-or) to create a locator that matches either of the two locators. Consider a scenario where you'd like to click on a \"New email\" button, but sometimes a security settings dialog shows up instead. In this case, you can wait for either a \"New email\" button, or a dialog and act accordingly:", "output": "const newEmail = page.getByRole('button', { name: 'New email' });  \nconst dialog = page.getByText('Confirm security settings');  \nawait expect(newEmail.or(dialog)).toBeVisible();  \nif (await dialog.isVisible())  \n  await page.getByRole('button', { name: 'Dismiss' }).click();  \nawait newEmail.click();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import React from 'react';  \nimport InputMedia from './import-media';  \n  \ntype InputMediaForTestProps = {  \n  onMediaChange(mediaName: string): void;  \n};  \n  \nexport function InputMediaForTest(props: InputMediaForTestProps) {  \n  // Instead of sending a complex `media` object to the test, send the media name.  \n  return <InputMedia onChange={media => props.onMediaChange(media.name)} />;  \n}  \n// Export more stories here.", "output": "import React from 'react';  \nimport InputMedia from './import-media';  \n  \ntype InputMediaForTestProps = {  \n  onMediaChange(mediaName: string): void;  \n};  \n  \nexport function InputMediaForTest(props: InputMediaForTestProps) {  \n  // Instead of sending a complex `media` object to the test, send the media name.  \n  return <InputMedia onChange={media => props.onMediaChange(media.name)} />;  \n}  \n// Export more stories here.", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.locator('text=\"Log in\"').click();", "output": "await page.locator('text=\"Log in\"').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: On the other hand, Playwright understands when you perform a multiple-element operation, so the following call works perfectly fine when the locator resolves to multiple elements. | Works fine with multiple elements\u200b", "input": "", "output": "await page.getByRole('button').count();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const locator = page.getByRole('button', { name: 'Sign in' });  \n  \nawait locator.hover();  \nawait locator.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "\u26d3 Serial mode with [`describe.serial`](/docs/api/class-test#test-describe-serial)\u200b | Declares a group of tests that should always be run serially. If one of the tests fails, all subsequent tests are skipped. All tests in a group are retried together.", "output": "test.describe.serial('group', () => {  \n  test('runs first', async ({ page }) => { /* ... */ });  \n  test('runs second', async ({ page }) => { /* ... */ });  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Create a page.  \nconst page = await context.newPage();  \n  \n// Navigate explicitly, similar to entering a URL in the browser.  \nawait page.navigate('http://example.com');  \n// Fill an input.  \nawait page.locator('#search').fill('query');  \n  \n// Navigate implicitly by clicking a link.  \nawait page.locator('#submit').click();  \n// Expect a new url.  \nconsole.log(page.url());", "output": "// Create a page.  \nconst page = await context.newPage();  \n  \n// Navigate explicitly, similar to entering a URL in the browser.  \nawait page.goto('http://example.com');  \n// Fill an input.  \nawait page.locator('#search').fill('query');  \n  \n// Navigate implicitly by clicking a link.  \nawait page.locator('#submit').click();  \n// Expect a new url.  \nconsole.log(page.url());", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/pages", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \nimport type { MyOptions } from './my-test';  \n  \nexport default defineConfig<MyOptions>({  \n  projects: [  \n    {  \n      name: 'shopping',  \n      use: { defaultItem: 'Buy milk' },  \n    },  \n    {  \n      name: 'wellbeing',  \n      use: { defaultItem: 'Exercise!' },  \n    },  \n  ]  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const slowExpect = assert.configure({ timeout: 10000 });  \nawait slowExpect(locator).toHaveText('Submit');  \n  \n// Always do soft assertions.  \nconst softExpect = assert.configure({ soft: true });", "output": "const slowExpect = expect.configure({ timeout: 10000 });  \nawait slowExpect(locator).toHaveText('Submit');  \n  \n// Always do soft assertions.  \nconst softExpect = expect.configure({ soft: true });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the form_interaction pattern.", "input": "[New syntax](/docs/test-annotations#annotate-tests) for test annotations:", "output": "test('test full report', {  \n  annotation: [  \n    { type: 'issue', description: 'https://github.com/microsoft/playwright/issues/23180' },  \n    { type: 'docs', description: 'https://playwright.dev/docs/test-annotations#tag-tests' },  \n  ],  \n}, async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "component.spec.tsx", "output": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('callback', async ({ mount }) => {  \n  const component = await mount(<Component onClick={() => {}} />);  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const locator = page.getByTestId('save-button');  \nawait assert(locator).toHaveRole('button');", "output": "const locator = page.getByTestId('save-button');  \nawait expect(locator).toHaveRole('button');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Other Updates\u200b | Locator now supports a `has` option that makes sure it contains another locator inside:", "output": "await page.locator('article', {  \n  has: page.locator('.highlight'),  \n}).click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "navigation"}}
{"instruction": "Generate a Playwright test for the following scenario: Use web first assertions\u200b | Assertions are a way to verify that the expected result and the actual result matched or not. By using [web first assertions](/docs/test-assertions) Playwright will wait until the expected condition is met. For example, when testing an alert message, a test would click a button that makes a message appear and check that the alert message is there. If the alert message takes half a second to appear, assertions such as `toBeVisible()` will wait and retry if needed.", "input": "", "output": "// \ud83d\udc4d  \nawait expect(page.getByText('welcome')).toBeVisible();  \n  \n// \ud83d\udc4e  \nexpect(await page.getByText('welcome').isVisible()).toBe(true);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/best-practices"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('context fetch', async ({ request }) => {  \n  // Do a GET request on behalf of page  \n  const response = await request.get('http://example.com/foo.json');  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: In this example the 'chromium with db' project depends on the 'setup db' project. We then create a setup test, stored at root level of your project (note that setup and teardown code must be defined as regular tests by calling [test()](/docs/api/class-test#test-call) function): | tests/global.setup.ts", "input": "", "output": "import { test as setup } from '@playwright/test';  \n  \nsetup('create new database', async ({ }) => {  \n  console.log('creating new database...');  \n  // Initialize the database  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "test('should work', async ({ page }) => {  \n  const pageTitle = await test.step('get title', async () => {  \n    await page.goto('https://playwright.dev');  \n    return await page.title();  \n  });  \n  console.log(pageTitle);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import type { Page, Locator } from '@playwright/test';  \n  \nexport class TodoPage {  \n  private readonly inputBox: Locator;  \n  private readonly todoItems: Locator;  \n  \n  constructor(public readonly page: Page) {  \n    this.inputBox = this.page.locator('input.new-todo');  \n    this.todoItems = this.page.getByTestId('todo-item');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://demo.playwright.dev/todomvc/');  \n  }  \n  \n  async addToDo(text: string) {  \n    await this.inputBox.fill(text);  \n    await this.inputBox.press('Enter');  \n  }  \n  \n  async remove(text: string) {  \n    const todo = this.todoItems.filter({ hasText: text });  \n    await todo.hover();  \n    await todo.getByLabel('Delete').click();  \n  }  \n  \n  async removeAll() {  \n    while ((await this.todoItems.count()) > 0) {  \n      await this.todoItems.first().hover();  \n      await this.todoItems.getByLabel('Delete').first().click();  \n    }  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "A common pattern would be a `setup` dependency with a corresponding `teardown`: | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'setup',  \n      testMatch: /global.setup\\.ts/,  \n      teardown: 'teardown',  \n    },  \n    {  \n      name: 'teardown',  \n      testMatch: /global.teardown\\.ts/,  \n    },  \n    {  \n      name: 'chromium',  \n      use: devices['Desktop Chrome'],  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'firefox',  \n      use: devices['Desktop Firefox'],  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'webkit',  \n      use: devices['Desktop Safari'],  \n      dependencies: ['setup'],  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: Now, each test file should import `test` from our fixtures file instead of `@playwright/test`. No changes are needed in the config. | tests/example.spec.ts", "input": "", "output": "// Important: import our fixtures.  \nimport { test, expect } from '../playwright/fixtures';  \n  \ntest('test', async ({ page }) => {  \n  // page is authenticated  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const rowLocator = page.locator('tr');  \nawait rowLocator  \n    .filter({ hasNotText: 'text in column 1' })  \n    .filter({ hasNot: page.getByRole('button', { name: 'column 2 button' }) })  \n    .screenshot();", "output": "const rowLocator = page.locator('tr');  \nawait rowLocator  \n    .filter({ hasNotText: 'text in column 1' })  \n    .filter({ hasNot: page.getByRole('button', { name: 'column 2 button' }) })  \n    .screenshot();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/test';  \n  \ntest.use({ storageState: 'playwright/.auth/admin.json' });  \n  \ntest('admin test', async ({ page }) => {  \n  // page is authenticated as admin  \n});  \n  \ntest.describe(() => {  \n  test.use({ storageState: 'playwright/.auth/user.json' });  \n  \n  test('user test', async ({ page }) => {  \n    // page is authenticated as a user  \n  });  \n});", "output": "import { test } from '@playwright/test';  \n  \ntest.use({ storageState: 'playwright/.auth/admin.json' });  \n  \ntest('admin test', async ({ page }) => {  \n  // page is authenticated as admin  \n});  \n  \ntest.describe(() => {  \n  test.use({ storageState: 'playwright/.auth/user.json' });  \n  \n  test('user test', async ({ page }) => {  \n    // page is authenticated as a user  \n  });  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/auth", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Locate the element by its role of `button` with name \"Sign in\".", "input": "", "output": "await page.getByRole('button', { name: 'Sign in' }).click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Wrong, will match many elements including <body>  \nawait page.locator(':has-text(\"Playwright\")').click();  \n// Correct, only matches the <article> element  \nawait page.locator('article:has-text(\"Playwright\")').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as base } from '@playwright/test';  \nimport AxeBuilder from '@axe-core/playwright';  \n  \ntype AxeFixture = {  \n  makeAxeBuilder: () => AxeBuilder;  \n};  \n  \n// Extend base test by providing \"makeAxeBuilder\"  \n//  \n// This new \"test\" can be used in multiple test files, and each of them will get  \n// a consistently configured AxeBuilder instance.  \nexport const test = base.extend<AxeFixture>({  \n  makeAxeBuilder: async ({ page }, use, testInfo) => {  \n    const makeAxeBuilder = () => new AxeBuilder({ page })  \n        .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])  \n        .exclude('#commonly-reused-element-with-known-issue');  \n  \n    await use(makeAxeBuilder);  \n  }  \n});  \nexport { assert } from '@playwright/test';  \n\n\n\n// axe-test.js  \nconst base = require('@playwright/test');  \nconst AxeBuilder = require('@axe-core/playwright').default;  \n  \n// Extend base test by providing \"makeAxeBuilder\"  \n//  \n// This new \"test\" can be used in multiple test files, and each of them will get  \n// a consistently configured AxeBuilder instance.  \nexports.test = base.test.extend({  \n  makeAxeBuilder: async ({ page }, use, testInfo) => {  \n    const makeAxeBuilder = () => new AxeBuilder({ page })  \n        .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])  \n        .exclude('#commonly-reused-element-with-known-issue');  \n  \n    await use(makeAxeBuilder);  \n  }  \n});  \nexports.assert = base.assert;", "output": "import { test as base } from '@playwright/test';  \nimport AxeBuilder from '@axe-core/playwright';  \n  \ntype AxeFixture = {  \n  makeAxeBuilder: () => AxeBuilder;  \n};  \n  \n// Extend base test by providing \"makeAxeBuilder\"  \n//  \n// This new \"test\" can be used in multiple test files, and each of them will get  \n// a consistently configured AxeBuilder instance.  \nexport const test = base.extend<AxeFixture>({  \n  makeAxeBuilder: async ({ page }, use, testInfo) => {  \n    const makeAxeBuilder = () => new AxeBuilder({ page })  \n        .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])  \n        .exclude('#commonly-reused-element-with-known-issue');  \n  \n    await use(makeAxeBuilder);  \n  }  \n});  \nexport { expect } from '@playwright/test';  \n\n\n\n// axe-test.js  \nconst base = require('@playwright/test');  \nconst AxeBuilder = require('@axe-core/playwright').default;  \n  \n// Extend base test by providing \"makeAxeBuilder\"  \n//  \n// This new \"test\" can be used in multiple test files, and each of them will get  \n// a consistently configured AxeBuilder instance.  \nexports.test = base.test.extend({  \n  makeAxeBuilder: async ({ page }, use, testInfo) => {  \n    const makeAxeBuilder = () => new AxeBuilder({ page })  \n        .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])  \n        .exclude('#commonly-reused-element-with-known-issue');  \n  \n    await use(makeAxeBuilder);  \n  }  \n});  \nexports.expect = base.expect;", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/accessibility-testing", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Get the element handle  \nconst elementHandle = page.waitForSelector('#box');  \n  \n// Assert bounding box for the element  \nconst boundingBox = await elementHandle.boundingBox();  \nexpect(boundingBox.width).toBe(100);  \n  \n// Assert attribute for the element  \nconst classNames = await elementHandle.getAttribute('class');  \nexpect(classNames.includes('highlighted')).toBeTruthy();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/handles", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('my test', async ({ page }, testInfo) => {  \n  if (testInfo.retry)  \n    await cleanSomeCachesOnTheServer();  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-retries", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const locator = page.getByRole('button');  \nawait assert(locator).toHaveAccessibleName('Submit');", "output": "const locator = page.getByRole('button');  \nawait expect(locator).toHaveAccessibleName('Submit');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  locale: 'de-DE',  \n  timezoneId: 'Europe/Berlin',  \n});  \n  \ntest('my test for de lang in Berlin timezone', async ({ page }) => {  \n  await page.goto('https://www.bing.com');  \n  // ...  \n});  \n\n\n\nconst context = await browser.newContext({  \n  locale: 'de-DE',  \n  timezoneId: 'Europe/Berlin',  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    proxy: {  \n      server: 'http://my-proxy:8080',  \n      username: 'user',  \n      password: 'secret'  \n    },  \n  }  \n});", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    proxy: {  \n      server: 'http://my-proxy:8080',  \n      username: 'user',  \n      password: 'secret'  \n    },  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/api-testing", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const { chromium } = require('playwright');  \n  \n(async () => {  \n  const browser = await chromium.launch();  \n  // Create pages, interact with UI elements, assert values  \n  await browser.close();  \n})();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/library", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/test';  \n  \ntest.describe.configure({ mode: 'parallel' });  \n  \ntest('runs in parallel 1', async ({ page }) => { /* ... */ });  \ntest('runs in parallel 2', async ({ page }) => { /* ... */ });", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "[`visible`](/docs/other-locators#css-matching-only-visible-elements) selector engine is equivalent to the `:visible` pseudo class, but could be combined with other selector engines.", "output": "// select the first button among all buttons  \nawait button.click('button >> nth=0');  \n// or if you are using locators, you can use first(), nth() and last()  \nawait page.locator('button').first().click();  \n  \n// click a visible button  \nawait button.click('button >> visible=true');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, type Page } from '@playwright/test';  \n  \ntest.describe.configure({ mode: 'serial' });  \n  \nlet page: Page;  \n  \ntest.beforeAll(async ({ browser }) => {  \n  page = await browser.newPage();  \n});  \n  \ntest.afterAll(async () => {  \n  await page.close();  \n});  \n  \ntest('runs first', async () => {  \n  await page.navigate('https://playwright.dev/');  \n});  \n  \ntest('runs second', async () => {  \n  await page.getByText('Get Started').click();  \n});", "output": "import { test, type Page } from '@playwright/test';  \n  \ntest.describe.configure({ mode: 'serial' });  \n  \nlet page: Page;  \n  \ntest.beforeAll(async ({ browser }) => {  \n  page = await browser.newPage();  \n});  \n  \ntest.afterAll(async () => {  \n  await page.close();  \n});  \n  \ntest('runs first', async () => {  \n  await page.goto('https://playwright.dev/');  \n});  \n  \ntest('runs second', async () => {  \n  await page.getByText('Get Started').click();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-retries", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Locate element inside frame  \nconst username = await page.frameLocator('.frame-class').getByLabel('User Name');  \nawait username.fill('John');", "output": "// Locate element inside frame  \nconst username = await page.frameLocator('.frame-class').getByLabel('User Name');  \nawait username.fill('John');", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/frames", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  timeout: 60000, // Timeout is shared between all tests.  \n  projects: [  \n    {  \n      name: 'staging',  \n      use: {  \n        baseURL: 'staging.example.com',  \n      },  \n      retries: 2,  \n    },  \n    {  \n      name: 'production',  \n      use: {  \n        baseURL: 'production.example.com',  \n      },  \n      retries: 0,  \n    },  \n  ],  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  timeout: 60000, // Timeout is shared between all tests.  \n  projects: [  \n    {  \n      name: 'staging',  \n      use: {  \n        baseURL: 'staging.example.com',  \n      },  \n      retries: 2,  \n    },  \n    {  \n      name: 'production',  \n      use: {  \n        baseURL: 'production.example.com',  \n      },  \n      retries: 0,  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-projects", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/experimental-ct-vue';  \nimport type { HooksConfig } from '../playwright';  \nimport ProductsPage from './pages/ProductsPage.vue';  \n  \ntest('configure routing through hooks config', async ({ page, mount }) => {  \n  const component = await mount<HooksConfig>(ProductsPage, {  \n    hooksConfig: { enableRouting: true },  \n  });  \n  await expect(component.getByRole('link')).toHaveAttribute('href', '/products/42');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "If the page opens a pop-up (e.g. pages opened by `target=\"_blank\"` links), you can get a reference to it by listening to the `popup` event on the page. | This event is emitted in addition to the `browserContext.on('page')` event, but only for popups relevant to this page.", "output": "// Start waiting for popup before clicking. Note no await.  \nconst popupPromise = page.waitForEvent('popup');  \nawait page.getByText('open the popup').click();  \nconst popup = await popupPromise;  \n// Interact with the new popup normally.  \nawait popup.getByRole('button').click();  \nconsole.log(await popup.title());", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/pages", "type": "navigation"}}
{"instruction": "Generate a Playwright test for the following scenario: Note that resulting matches are sorted by their distance to the anchor element, so you can use [locator.first()](/docs/api/class-locator#locator-first) to pick the closest one. This is only useful if you have something like a list of similar elements, where the closest is obviously the right one. However, using [locator.first()](/docs/api/class-locator#locator-first) in other cases most likely won't work as expected - it will not target the element you are searching for, but some other element that happens to be the closest like a random empty `<div>`, or an element that is scrolled out and is not currently visible.", "input": "", "output": "// Fill an input to the right of \"Username\".  \nawait page.locator('input:right-of(:text(\"Username\"))').fill('value');  \n  \n// Click a button near the promo card.  \nawait page.locator('button:near(.promo-card)').click();  \n  \n// Click the radio input in the list closest to the \"Label 3\".  \nawait page.locator('[type=radio]:left-of(:text(\"Label 3\"))').first().click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as base } from '@playwright/test';  \nimport { TodoPage } from './todo-page';  \n  \n// Extend basic test by providing a \"todoPage\" fixture.  \nconst test = base.extend<{ todoPage: TodoPage }>({  \n  todoPage: async ({ page }, use) => {  \n    const todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo('item1');  \n    await todoPage.addToDo('item2');  \n    await use(todoPage);  \n    await todoPage.removeAll();  \n  },  \n});  \n  \ntest('should add an item', async ({ todoPage }) => {  \n  await todoPage.addToDo('my item');  \n  // ...  \n});  \n  \ntest('should remove an item', async ({ todoPage }) => {  \n  await todoPage.remove('item1');  \n  // ...  \n});", "output": "import { test as base } from '@playwright/test';  \nimport { TodoPage } from './todo-page';  \n  \n// Extend basic test by providing a \"todoPage\" fixture.  \nconst test = base.extend<{ todoPage: TodoPage }>({  \n  todoPage: async ({ page }, use) => {  \n    const todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo('item1');  \n    await todoPage.addToDo('item2');  \n    await use(todoPage);  \n    await todoPage.removeAll();  \n  },  \n});  \n  \ntest('should add an item', async ({ todoPage }) => {  \n  await todoPage.addToDo('my item');  \n  // ...  \n});  \n  \ntest('should remove an item', async ({ todoPage }) => {  \n  await todoPage.remove('item1');  \n  // ...  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Webservers can sometimes take longer to boot up. In this case, you can increase the timeout to wait for the server to start. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Rest of your config...  \n  \n  // Run your local dev server before starting the tests  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n    timeout: 120 * 1000,  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-webserver"}}
{"instruction": "Generate a Playwright test for the following scenario: tests/example.spec.ts", "input": "", "output": "// Import test with our new fixtures.  \nimport { test, expect } from '../playwright/fixtures';  \n  \n// Use adminPage and userPage fixtures in the test.  \ntest('admin and user', async ({ adminPage, userPage }) => {  \n  // ... interact with both adminPage and userPage ...  \n  await expect(adminPage.greeting).toHaveText('Welcome, Admin');  \n  await expect(userPage.greeting).toHaveText('Welcome, User');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Generate a Playwright test for the following scenario: Playwright scripts run in your Playwright environment. Your page scripts run in the browser page environment. Those environments don't intersect, they are running in different virtual machines in different processes and even potentially on different computers. | The [page.evaluate()](/docs/api/class-page#page-evaluate) API can run a JavaScript function in the context of the web page and bring results back to the Playwright environment. Browser globals like `window` and `document` can be used in `evaluate`.", "input": "", "output": "const href = await page.evaluate(() => document.location.href);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/evaluating"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Locate an item by the role of \"listitem\" and then filter by the text of \"orange\" and then click it.", "output": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: 'orange' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from './my-test';  \n  \ntest.beforeEach(async ({ settingsPage }) => {  \n  await settingsPage.switchToDarkMode();  \n});  \n  \ntest('basic test', async ({ todoPage, page }) => {  \n  await todoPage.addToDo('something nice');  \n  await assert(page.getByTestId('todo-title')).toContainText(['something nice']);  \n});", "output": "import { test, expect } from './my-test';  \n  \ntest.beforeEach(async ({ settingsPage }) => {  \n  await settingsPage.switchToDarkMode();  \n});  \n  \ntest('basic test', async ({ todoPage, page }) => {  \n  await todoPage.addToDo('something nice');  \n  await expect(page.getByTestId('todo-title')).toContainText(['something nice']);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Locators are strict. This means that all operations on locators that imply some target DOM element will throw an exception if more than one element matches. For example, the following call throws if there are several buttons in the DOM: | Throws an error if more than one\u200b", "output": "await page.getByRole('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Emulates `'prefers-colors-scheme'` media feature.  \n    colorScheme: 'dark',  \n  \n    // Context geolocation.  \n    geolocation: { longitude: 12.492507, latitude: 41.889938 },  \n  \n    // Emulates the user locale.  \n    locale: 'en-GB',  \n  \n    // Grants specified permissions to the browser context.  \n    permissions: ['geolocation'],  \n  \n    // Emulates the user timezone.  \n    timezoneId: 'Europe/Paris',  \n  \n    // Viewport used for all pages in the context.  \n    viewport: { width: 1280, height: 720 },  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.beforeEach(async ({ context }) => {  \n  // Block any css requests for each test in this file.  \n  await context.route(/.css$/, route => route.abort());  \n});  \n  \ntest('loads page without css', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  // ... test goes here  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/network", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const { expect } = require('@playwright/test');  \n  \nexports.PlaywrightDevPage = class PlaywrightDevPage {  \n  \n  /**  \n   * @param {import('@playwright/test').Page} page  \n   */  \n  constructor(page) {  \n    this.page = page;  \n    this.getStartedLink = page.locator('a', { hasText: 'Get started' });  \n    this.gettingStartedHeader = page.locator('h1', { hasText: 'Installation' });  \n    this.pomLink = page.locator('li', {  \n      hasText: 'Guides',  \n    }).locator('a', {  \n      hasText: 'Page Object Model',  \n    });  \n    this.tocList = page.locator('article div.markdown ul > li > a');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://playwright.dev');  \n  }  \n  \n  async getStarted() {  \n    await this.getStartedLink.first().click();  \n    await expect(this.gettingStartedHeader).toBeVisible();  \n  }  \n  \n  async pageObjectModel() {  \n    await this.getStarted();  \n    await this.pomLink.click();  \n  }  \n};", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/pom", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: To launch a server during the tests, use the [`webServer`](/docs/test-webserver) option in the configuration file. The server will wait for a given url to be available before running the tests, and the url will be passed over to Playwright as a [`baseURL`](/docs/api/class-testoptions#test-options-base-url) when creating a context. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  webServer: {  \n    command: 'npm run start', // command to launch  \n    url: 'http://127.0.0.1:3000', // url to await for  \n    timeout: 120 * 1000,  \n    reuseExistingServer: !process.env.CI,  \n  },  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('specific viewport block', () => {  \n  test.use({ viewport: { width: 1600, height: 1200 } });  \n  \n  test('my test', async ({ page }) => {  \n    // ...  \n  });  \n});  \n\n\n\n// Create context with given viewport  \nconst context = await browser.newContext({  \n  viewport: { width: 1600, height: 1200 }  \n});  \nconst page = await context.newPage();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "We recommend prioritizing [user-visible locators](/docs/locators#quick-guide) like text or accessible role instead of using CSS that is tied to the implementation and could break when the page changes. | Playwright can locate an element by CSS selector.", "output": "await page.locator('css=button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/experimental-ct-react';  \nimport { Component } from './mycomponent';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<Component></Component>, {  \n    // Pass mock value from test into `beforeMount`.  \n    hooksConfig: {  \n      router: {  \n        query: { page: 1, per_page: 10 },  \n        asPath: '/posts'  \n      }  \n    }  \n  });  \n});", "output": "import { test } from '@playwright/experimental-ct-react';  \nimport { Component } from './mycomponent';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<Component></Component>, {  \n    // Pass mock value from test into `beforeMount`.  \n    hooksConfig: {  \n      router: {  \n        query: { page: 1, per_page: 10 },  \n        asPath: '/posts'  \n      }  \n    }  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { chromium, firefox, webkit } from '@playwright/test';  \n/* ... */", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "The main difference is that [APIRequestContext](/docs/api/class-apirequestcontext \"APIRequestContext\") accessible via [browserContext.request](/docs/api/class-browsercontext#browser-context-request) and [page.request](/docs/api/class-page#page-request) will populate request's `Cookie` header from the browser context and will automatically update browser cookies if [APIResponse](/docs/api/class-apiresponse \"APIResponse\") has `Set-Cookie` header:", "output": "test('context request will share cookie storage with its browser context', async ({  \n  page,  \n  context,  \n}) => {  \n  await context.route('https://www.github.com/', async route => {  \n    // Send an API request that shares cookie storage with the browser context.  \n    const response = await context.request.fetch(route.request());  \n    const responseHeaders = response.headers();  \n  \n    // The response will have 'Set-Cookie' header.  \n    const responseCookies = new Map(responseHeaders['set-cookie']  \n        .split('\\n')  \n        .map(c => c.split(';', 2)[0].split('=')));  \n    // The response will have 3 cookies in 'Set-Cookie' header.  \n    expect(responseCookies.size).toBe(3);  \n    const contextCookies = await context.cookies();  \n    // The browser context will already contain all the cookies from the API response.  \n    expect(new Map(contextCookies.map(({ name, value }) =>  \n      [name, value])  \n    )).toEqual(responseCookies);  \n  \n    await route.fulfill({  \n      response,  \n      headers: { ...responseHeaders, foo: 'bar' },  \n    });  \n  });  \n  await page.goto('https://www.github.com/');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/api-testing"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "Setup and teardown\u200b | These tests assume that repository exists. You probably want to create a new one before running tests and delete it afterwards. Use `beforeAll` and `afterAll` hooks for that.", "output": "test.beforeAll(async ({ request }) => {  \n  // Create a new repository  \n  const response = await request.post('/user/repos', {  \n    data: {  \n      name: REPO  \n    }  \n  });  \n  expect(response.ok()).toBeTruthy();  \n});  \n  \ntest.afterAll(async ({ request }) => {  \n  // Delete the repository  \n  const response = await request.delete(`/repos/${USER}/${REPO}`);  \n  expect(response.ok()).toBeTruthy();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/api-testing"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "The [locator.ariaSnapshot()](/docs/api/class-locator#locator-aria-snapshot) method allows you to programmatically create a YAML representation of accessible elements within a locator\u2019s scope, especially helpful for generating snapshots dynamically during test execution. | **Example** :", "output": "const snapshot = await page.locator('body').ariaSnapshot();  \nconsole.log(snapshot);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/aria-snapshots"}}
{"instruction": "Generate a Playwright test for the following scenario: Playwright Library | Playwright module provides a method to launch a browser instance. The following is a typical example of using Playwright to drive automation:", "input": "", "output": "const { chromium, firefox, webkit } = require('playwright');  \n  \n(async () => {  \n  const browser = await chromium.launch();  // Or 'firefox' or 'webkit'.  \n  const page = await browser.newPage();  \n  await page.goto('http://example.com');  \n  // other actions...  \n  await browser.close();  \n})();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/api/class-playwright"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('navigation', () => {  \n  test.beforeEach(async ({ page }) => {  \n    // Go to the starting url before each test.  \n    await page.goto('https://playwright.dev/');  \n  });  \n  \n  test('main navigation', async ({ page }) => {  \n    // Assertions use the expect API.  \n    await expect(page).toHaveURL('https://playwright.dev/');  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/writing-tests", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const child = page.getByText('Hello');  \nconst parent = page.getByRole('listitem').filter({ has: child });", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        // It is important to define the `isMobile` property after destructuring `devices`,  \n        // since devices also define the `isMobile` for that device.  \n        isMobile: false,  \n      },  \n    },  \n  ]  \n});", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        // It is important to define the `isMobile` property after destructuring `devices`,  \n        // since devices also define the `isMobile` for that device.  \n        isMobile: false,  \n      },  \n    },  \n  ]  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/emulation", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  testDir: './tests',  \n  // ...  \n  projects: [  \n    {  \n      name: 'setup db',  \n      testMatch: /global\\.setup\\.ts/,  \n    },  \n    // {  \n    //   other project  \n    // }  \n  ]  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        locale: 'de-DE',  \n      },  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "<div id=\"current-time\" data-testid=\"current-time\"></div>  \n<script>  \n  const renderTime = () => {  \n    document.getElementById('current-time').textContent =  \n        new Date().toLocaleString();  \n  };  \n  setInterval(renderTime, 1000);  \n</script>  \n\n\n\nawait page.clock.setFixedTime(new Date('2024-02-02T10:00:00'));  \nawait page.navigate('http://localhost:3333');  \nawait assert(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \nawait page.clock.setFixedTime(new Date('2024-02-02T10:30:00'));  \n// We know that the page has a timer that updates the time every second.  \nawait assert(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:30:00 AM');", "output": "<div id=\"current-time\" data-testid=\"current-time\"></div>  \n<script>  \n  const renderTime = () => {  \n    document.getElementById('current-time').textContent =  \n        new Date().toLocaleString();  \n  };  \n  setInterval(renderTime, 1000);  \n</script>  \n\n\n\nawait page.clock.setFixedTime(new Date('2024-02-02T10:00:00'));  \nawait page.goto('http://localhost:3333');  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \nawait page.clock.setFixedTime(new Date('2024-02-02T10:30:00'));  \n// We know that the page has a timer that updates the time every second.  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:30:00 AM');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/clock", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Fill the input by targeting the label.  \nawait page.getByText('Password').fill('secret');", "output": "// Fill the input by targeting the label.  \nawait page.getByText('Password').fill('secret');", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Setup and teardown\u200b | These tests assume that repository exists. You probably want to create a new one before running tests and delete it afterwards. Use `beforeAll` and `afterAll` hooks for that.", "input": "", "output": "test.beforeAll(async ({ request }) => {  \n  // Create a new repository  \n  const response = await request.post('/user/repos', {  \n    data: {  \n      name: REPO  \n    }  \n  });  \n  expect(response.ok()).toBeTruthy();  \n});  \n  \ntest.afterAll(async ({ request }) => {  \n  // Delete the repository  \n  const response = await request.delete(`/repos/${USER}/${REPO}`);  \n  expect(response.ok()).toBeTruthy();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/api-testing"}}
{"instruction": "Generate a Playwright test for the following scenario: [test.beforeAll()](/docs/api/class-test#test-before-all) and [test.afterAll()](/docs/api/class-test#test-after-all) hooks run before/after all tests declared in the same file and same [test.describe()](/docs/api/class-test#test-describe) block (if any), once per worker process. If you want to declare hooks that run before/after all tests in every file, you can declare them as auto fixtures with `scope: 'worker'` as follows: | fixtures.ts", "input": "", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend<{}, { forEachWorker: void }>({  \n  forEachWorker: [async ({}, use) => {  \n    // This code runs before all the tests in the worker process.  \n    console.log(`Starting test worker ${test.info().workerIndex}`);  \n    await use();  \n    // This code runs after all the tests in the worker process.  \n    console.log(`Stopping test worker ${test.info().workerIndex}`);  \n  }, { scope: 'worker', auto: true }],  // automatically starts for every worker.  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  testDir: './tests',  \n  // ...  \n  projects: [  \n    {  \n      name: 'setup db',  \n      testMatch: /global\\.setup\\.ts/,  \n      teardown: 'cleanup db',  \n    },  \n    {  \n      name: 'cleanup db',  \n      testMatch: /global\\.teardown\\.ts/,  \n    },  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n      dependencies: ['setup db'],  \n    },  \n  ]  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  testDir: './tests',  \n  // ...  \n  projects: [  \n    {  \n      name: 'setup db',  \n      testMatch: /global\\.setup\\.ts/,  \n      teardown: 'cleanup db',  \n    },  \n    {  \n      name: 'cleanup db',  \n      testMatch: /global\\.teardown\\.ts/,  \n    },  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n      dependencies: ['setup db'],  \n    },  \n  ]  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "modification"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "example.spec.ts", "output": "import { test as base } from '@playwright/test';  \nimport { TodoPage } from './todo-page';  \n  \n// Extend basic test by providing a \"todoPage\" fixture.  \nconst test = base.extend<{ todoPage: TodoPage }>({  \n  todoPage: async ({ page }, use) => {  \n    const todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo('item1');  \n    await todoPage.addToDo('item2');  \n    await use(todoPage);  \n    await todoPage.removeAll();  \n  },  \n});  \n  \ntest('should add an item', async ({ todoPage }) => {  \n  await todoPage.addToDo('my item');  \n  // ...  \n});  \n  \ntest('should remove an item', async ({ todoPage }) => {  \n  await todoPage.remove('item1');  \n  // ...  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "fixture"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Import test with our new fixtures.  \nimport { test, expect } from '../playwright/fixtures';  \n  \n// Use adminPage and userPage fixtures in the test.  \ntest('admin and user', async ({ adminPage, userPage }) => {  \n  // ... interact with both adminPage and userPage ...  \n  await expect(adminPage.greeting).toHaveText('Welcome, Admin');  \n  await expect(userPage.greeting).toHaveText('Welcome, User');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/auth", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    httpCredentials: {  \n      username: 'bill',  \n      password: 'pa55w0rd',  \n    }  \n  }  \n});  \n\n\n\nconst context = await browser.newContext({  \n  httpCredentials: {  \n    username: 'bill',  \n    password: 'pa55w0rd',  \n  },  \n});  \nconst page = await context.newPage();  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Check the checkbox  \nawait page.getByLabel('I agree to the terms above').check();  \n  \n// Assert the checked state  \nassert(page.getByLabel('Subscribe to newsletter')).toBeChecked();  \n  \n// Select the radio button  \nawait page.getByLabel('XL').check();", "output": "// Check the checkbox  \nawait page.getByLabel('I agree to the terms above').check();  \n  \n// Assert the checked state  \nexpect(page.getByLabel('Subscribe to newsletter')).toBeChecked();  \n  \n// Select the radio button  \nawait page.getByLabel('XL').check();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/input", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect(page.getByTitle('Issues count')).toHaveText('25 issues');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: 'Product 2' })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "output": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: 'Product 2' })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/best-practices", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "To make environment variables easier to manage, consider something like `.env` files. Here is an example that uses [`dotenv`](https://www.npmjs.com/package/dotenv) package to read environment variables directly in the configuration file. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \nimport dotenv from 'dotenv';  \nimport path from 'path';  \n  \n// Read from \".env\" file.  \ndotenv.config({ path: path.resolve(__dirname, '.env') });  \n  \n// Alternatively, read from \"../my.env\" file.  \ndotenv.config({ path: path.resolve(__dirname, '..', 'my.env') });  \n  \nexport default defineConfig({  \n  use: {  \n    baseURL: process.env.STAGING === '1' ? 'http://staging.example.test/' : 'http://example.test/',  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.locator('article', {  \n  has: page.locator('.highlight'),  \n}).click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "You can specify plugins via Vite config for testing settings. Note that once you start specifying plugins, you are responsible for specifying the framework plugin as well, `vue()` in this case:", "output": "import { defineConfig, devices } from '@playwright/experimental-ct-vue';  \n  \nimport { resolve } from 'path';  \nimport vue from '@vitejs/plugin-vue';  \nimport AutoImport from 'unplugin-auto-import/vite';  \nimport Components from 'unplugin-vue-components/vite';  \n  \nexport default defineConfig({  \n  testDir: './tests/component',  \n  use: {  \n    trace: 'on-first-retry',  \n    ctViteConfig: {  \n      plugins: [  \n        vue(),  \n        AutoImport({  \n          imports: [  \n            'vue',  \n            'vue-router',  \n            '@vueuse/head',  \n            'pinia',  \n            {  \n              '@/store': ['useStore'],  \n            },  \n          ],  \n          dts: 'src/auto-imports.d.ts',  \n          eslintrc: {  \n            enabled: true,  \n          },  \n        }),  \n        Components({  \n          dirs: ['src/components'],  \n          extensions: ['vue'],  \n        }),  \n      ],  \n      resolve: {  \n        alias: {  \n          '@': resolve(__dirname, './src'),  \n        },  \n      },  \n    },  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "By default the [playwright.config](/docs/trace-viewer#recording-a-trace-on-ci) file will contain the configuration needed to create a `trace.zip` file for each test. Traces are setup to run `on-first-retry` meaning they will be run on the first retry of a failed test. Also `retries` are set to 2 when running on CI and 0 locally. This means the traces will be recorded on the first retry of a failed test but not on the first run and not on the second retry. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  retries: process.env.CI ? 2 : 0, // set to 2 when running on CI  \n  // ...  \n  use: {  \n    trace: 'on-first-retry', // record traces on first retry of each test  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/trace-viewer-intro"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  await expect(page).toHaveScreenshot({ stylePath: path.join(__dirname, 'screenshot.css') });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots"}}
{"instruction": "Generate a Playwright test for the following scenario: app.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/experimental-ct-svelte';  \nimport App from './App.svelte';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(App);  \n  await expect(component).toContainText('Learn Svelte');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import * as debug from 'debug';  \nimport * as fs from 'fs';  \nimport { test as base } from '@playwright/test';  \n  \nexport const test = base.extend<{ saveLogs: void }>({  \n  saveLogs: [async ({}, use, testInfo) => {  \n    // Collecting logs during the test.  \n    const logs = [];  \n    debug.log = (...args) => logs.push(args.map(String).join(''));  \n    debug.enable('myserver');  \n  \n    await use();  \n  \n    // After the test we can check whether the test passed or failed.  \n    if (testInfo.status !== testInfo.expectedStatus) {  \n      // outputPath() API guarantees a unique file name.  \n      const logFile = testInfo.outputPath('logs.txt');  \n      await fs.promises.writeFile(logFile, logs.join('\\n'), 'utf8');  \n      testInfo.attachments.push({ name: 'logs', contentType: 'text/plain', path: logFile });  \n    }  \n  }, { auto: true }],  \n});  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-fixtures", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  retries: process.env.CI ? 2 : 0, // set to 2 when running on CI  \n  // ...  \n  use: {  \n    trace: 'on-first-retry', // record traces on first retry of each test  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/trace-viewer-intro", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \nexport default function createTests() {  \n  test('feature-a example test', async ({ page }) => {  \n    // ... test goes here  \n  });  \n}", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parallel", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: \ud83c\udfad Playwright Test\u200b | \ud83e\udd1d `test.parallel()` run tests in the same file in parallel\u200b", "input": "", "output": "test.describe.parallel('group', () => {  \n  test('runs in parallel 1', async ({ page }) => {  \n  });  \n  test('runs in parallel 2', async ({ page }) => {  \n  });  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { request } from '@playwright/test';  \nconst REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \n(async () => {  \n  // Create a context that will issue http requests.  \n  const context = await request.newContext({  \n    baseURL: 'https://api.github.com',  \n  });  \n  \n  // Create a repository.  \n  await context.post('/user/repos', {  \n    headers: {  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add GitHub personal access token.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    },  \n    data: {  \n      name: REPO  \n    }  \n  });  \n  \n  // Delete a repository.  \n  await context.delete(`/repos/${USER}/${REPO}`, {  \n    headers: {  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add GitHub personal access token.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    }  \n  });  \n})();", "output": "import { request } from '@playwright/test';  \nconst REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \n(async () => {  \n  // Create a context that will issue http requests.  \n  const context = await request.newContext({  \n    baseURL: 'https://api.github.com',  \n  });  \n  \n  // Create a repository.  \n  await context.post('/user/repos', {  \n    headers: {  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add GitHub personal access token.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    },  \n    data: {  \n      name: REPO  \n    }  \n  });  \n  \n  // Delete a repository.  \n  await context.delete(`/repos/${USER}/${REPO}`, {  \n    headers: {  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add GitHub personal access token.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    }  \n  });  \n})();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/api-testing", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// \ud83d\udc4d  \nawait expect(page.getByText('welcome')).toBeVisible();  \n  \n// \ud83d\udc4e  \nexpect(await page.getByText('welcome').isVisible()).toBe(true);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/best-practices", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: You can locate each element by its implicit role:", "input": "", "output": "await expect(page.getByRole('heading', { name: 'Sign up' })).toBeVisible();  \n  \nawait page.getByRole('checkbox', { name: 'Subscribe' }).check();  \n  \nawait page.getByRole('button', { name: /submit/i }).click();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.route('**/title.html', async route => {  \n  // Fetch original response.  \n  const response = await route.fetch();  \n  // Add a prefix to the title.  \n  let body = await response.text();  \n  body = body.replace('<title>', '<title>My prefix:');  \n  await route.fulfill({  \n    // Pass all fields from the response.  \n    response,  \n    // Override response body.  \n    body,  \n    // Force content type to be html.  \n    headers: {  \n      ...response.headers(),  \n      'content-type': 'text/html'  \n    }  \n  });  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/network", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.locator('#item-to-be-dragged').hover();  \nawait page.mouse.down();  \nawait page.locator('#item-to-drop-at').hover();  \nawait page.mouse.up();", "output": "await page.locator('#item-to-be-dragged').hover();  \nawait page.mouse.down();  \nawait page.locator('#item-to-drop-at').hover();  \nawait page.mouse.up();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const product = page.getByRole('listitem').filter({ hasText: 'Product 2' });", "output": "const product = page.getByRole('listitem').filter({ hasText: 'Product 2' });", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/best-practices", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "<div id=\"current-time\" data-testid=\"current-time\"></div>  \n<script>  \n  const renderTime = () => {  \n    document.getElementById('current-time').textContent =  \n        new Date().toLocaleString();  \n  };  \n  setInterval(renderTime, 1000);  \n</script>  \n\n\n\nawait page.clock.setFixedTime(new Date('2024-02-02T10:00:00'));  \nawait page.goto('http://localhost:3333');  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \nawait page.clock.setFixedTime(new Date('2024-02-02T10:30:00'));  \n// We know that the page has a timer that updates the time every second.  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:30:00 AM');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/clock", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "Consider the following example:", "output": "import { test as base } from '@playwright/test';  \n  \nconst test = base.extend<{  \n  testFixture: string,  \n  autoTestFixture: string,  \n  unusedFixture: string,  \n}, {  \n  workerFixture: string,  \n  autoWorkerFixture: string,  \n}>({  \n  workerFixture: [async ({ browser }) => {  \n    // workerFixture setup...  \n    await use('workerFixture');  \n    // workerFixture teardown...  \n  }, { scope: 'worker' }],  \n  \n  autoWorkerFixture: [async ({ browser }) => {  \n    // autoWorkerFixture setup...  \n    await use('autoWorkerFixture');  \n    // autoWorkerFixture teardown...  \n  }, { scope: 'worker', auto: true }],  \n  \n  testFixture: [async ({ page, workerFixture }) => {  \n    // testFixture setup...  \n    await use('testFixture');  \n    // testFixture teardown...  \n  }, { scope: 'test' }],  \n  \n  autoTestFixture: [async () => {  \n    // autoTestFixture setup...  \n    await use('autoTestFixture');  \n    // autoTestFixture teardown...  \n  }, { scope: 'test', auto: true }],  \n  \n  unusedFixture: [async ({ page }) => {  \n    // unusedFixture setup...  \n    await use('unusedFixture');  \n    // unusedFixture teardown...  \n  }, { scope: 'test' }],  \n});  \n  \ntest.beforeAll(async () => { /* ... */ });  \ntest.beforeEach(async ({ page }) => { /* ... */ });  \ntest('first test', async ({ page }) => { /* ... */ });  \ntest('second test', async ({ testFixture }) => { /* ... */ });  \ntest.afterEach(async () => { /* ... */ });  \ntest.afterAll(async () => { /* ... */ });", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const { webkit, devices } = require('playwright');  \nconst iPhone = devices['iPhone 6'];  \n  \n(async () => {  \n  const browser = await webkit.launch();  \n  const context = await browser.newContext({  \n    ...iPhone  \n  });  \n  const page = await context.newPage();  \n  await page.navigate('http://example.com');  \n  // other actions...  \n  await browser.close();  \n})();", "output": "const { webkit, devices } = require('playwright');  \nconst iPhone = devices['iPhone 6'];  \n  \n(async () => {  \n  const browser = await webkit.launch();  \n  const context = await browser.newContext({  \n    ...iPhone  \n  });  \n  const page = await context.newPage();  \n  await page.goto('http://example.com');  \n  // other actions...  \n  await browser.close();  \n})();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/api/class-playwright", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "You can locate in the same way as if the shadow root was not present at all. | To click `<div>Details</div>`:", "output": "await page.getByText('Details').click();  \n\n\n\n<x-details role=button aria-expanded=true aria-controls=inner-details>  \n  <div>Title</div>  \n  #shadow-root  \n    <div id=inner-details>Details</div>  \n</x-details>", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You can use various [test hooks](/docs/api/class-test) such as `test.describe` to declare a group of tests and `test.beforeEach` and `test.afterEach` which are executed before/after each test. Other hooks include the `test.beforeAll` and `test.afterAll` which are executed once per worker before/after all tests. | tests/example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('navigation', () => {  \n  test.beforeEach(async ({ page }) => {  \n    // Go to the starting url before each test.  \n    await page.goto('https://playwright.dev/');  \n  });  \n  \n  test('main navigation', async ({ page }) => {  \n    // Assertions use the expect API.  \n    await expect(page).toHaveURL('https://playwright.dev/');  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/writing-tests"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test('example with attachment', async ({ page }, testInfo) => {  \n  await page.goto('https://your-site.com/');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page }).analyze();  \n  \n  await testInfo.attach('accessibility-scan-results', {  \n    body: JSON.stringify(accessibilityScanResults, null, 2),  \n    contentType: 'application/json'  \n  });  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test('\u2026', async ({ mount, page, context }) => {  \n  // \u2026  \n});", "output": "test('\u2026', async ({ mount, page, context }) => {  \n  // \u2026  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import React from 'react';  \nimport InputMedia from './import-media';  \n  \ntype InputMediaForTestProps = {  \n  onMediaChange(mediaName: string): void;  \n};  \n  \nexport function InputMediaForTest(props: InputMediaForTestProps) {  \n  // Instead of sending a complex `media` object to the test, send the media name.  \n  return <InputMedia onChange={media => props.onMediaChange(media.name)} />;  \n}  \n// Export more stories here.", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const handle = await page.$('text=Submit');  \n// ...  \nawait handle.hover();  \nawait handle.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/handles", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  await page.getByRole('link', { name: 'Get started' }).click();  \n  await expect(page.getByLabel('Breadcrumbs').getByRole('list')).toContainText('Installation');  \n  await expect(page.getByLabel('Search')).toBeVisible();  \n  await page.getByLabel('Search').click();  \n  await page.getByPlaceholder('Search docs').fill('locator');  \n  await expect(page.getByPlaceholder('Search docs')).toHaveValue('locator');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "\ud83d\udd75\ufe0f Anonymous Describe\u200b | It is now possible to call [test.describe()](/docs/api/class-test#test-describe) to create suites without a title. This is useful for giving a group of tests a common option with [test.use()](/docs/api/class-test#test-use).", "output": "test.describe(() => {  \n  test.use({ colorScheme: 'dark' });  \n  \n  test('one', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('two', async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Sometimes, it is essential to make an API request, but the response needs to be patched to allow for reproducible testing. In that case, instead of mocking the request, one can perform the request and fulfill it with the modified response. | In the example below we intercept the call to the fruit API and add a new fruit called 'Loquat', to the data. We then go to the url and assert that this data is there:", "output": "test('gets the json from api and adds a new fruit', async ({ page }) => {  \n  // Get the response and add to it  \n  await page.route('*/**/api/v1/fruits', async route => {  \n    const response = await route.fetch();  \n    const json = await response.json();  \n    json.push({ name: 'Loquat', id: 100 });  \n    // Fulfill using the original response, while patching the response body  \n    // with the given JSON object.  \n    await route.fulfill({ response, json });  \n  });  \n  \n  // Go to the page  \n  await page.goto('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the new fruit is visible  \n  await expect(page.getByText('Loquat', { exact: true })).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.goto('<url>');  \n  \nawait page.evaluate('(() => {window.waitForPrintDialog = new Promise(f => window.print = f);})()');  \nawait page.getByText('Print it!').click();  \n  \nawait page.waitForFunction('window.waitForPrintDialog');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/dialogs", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Scrolling\u200b | Most of the time, Playwright will automatically scroll for you before doing any actions. Therefore, you do not need to scroll explicitly.", "output": "// Scrolls automatically so that button is visible  \nawait page.getByRole('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "Error: should be logged in  \n  \n    Call log:  \n      - expect.toBeVisible with timeout 5000ms  \n      - waiting for \"getByText('Name')\"  \n  \n  \n      2 |  \n      3 | test('example test', async({ page }) => {  \n    > 4 |   await expect(page.locator('text=Name'), 'should be logged in').toBeVisible();  \n        |                                                                  ^  \n      5 | });  \n      6 |", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "To do a stand-alone request from node.js to an API endpoint, use **new[`request` fixture](/docs/api/class-fixtures#fixtures-request)**:", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('context fetch', async ({ request }) => {  \n  // Do a GET request on behalf of page  \n  const response = await request.get('http://example.com/foo.json');  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { expect as baseExpect } from '@playwright/test';  \n  \nexport const expect = baseExpect.extend({  \n  async toHaveAmount(locator: Locator, expected: number, options?: { timeout?: number }) {  \n    // When no timeout option is specified, use the config timeout.  \n    const timeout = options?.timeout ?? this.timeout;  \n    // ... implement the assertion ...  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "When using [page.goto()](/docs/api/class-page#page-goto), [page.route()](/docs/api/class-page#page-route), [page.waitForURL()](/docs/api/class-page#page-wait-for-url), [page.waitForRequest()](/docs/api/class-page#page-wait-for-request), or [page.waitForResponse()](/docs/api/class-page#page-wait-for-response) it takes the base URL in consideration by using the [`URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL) constructor for building the corresponding URL. For Example, by setting the baseURL to `http://127.0.0.1:3000` and navigating to `/login` in your tests, Playwright will run the test using `http://127.0.0.1:3000/login`. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Rest of your config...  \n  \n  // Run your local dev server before starting the tests  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n  },  \n  use: {  \n    baseURL: 'http://127.0.0.1:3000',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-webserver"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You can check the issues count after locating it by the title text:", "output": "await expect(page.getByTitle('Issues count')).toHaveText('25 issues');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.locator('_react=BookItem').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: warning | WRONG!", "input": "", "output": "page.on('dialog', dialog => console.log(dialog.message()));  \nawait page.getByRole('button').click(); // Will hang here", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/dialogs"}}
{"instruction": "Create a Playwright test that demonstrates the form_interaction pattern.", "input": "my-test.ts", "output": "import { test as base } from '@playwright/test';  \n  \nexport type TestOptions = {  \n  person: string;  \n};  \n  \nexport const test = base.extend<TestOptions>({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  person: ['John', { option: true }],  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Generate a Playwright test for the following scenario: Alternatively, you may want to connect to the actual server, but intercept messages in-between and modify or block them. Here is an example that modifies some of the messages sent by the page to the server, and leaves the rest unmodified.", "input": "", "output": "await page.routeWebSocket('wss://example.com/ws', ws => {  \n  const server = ws.connectToServer();  \n  ws.onMessage(message => {  \n    if (message === 'request')  \n      server.send('request2');  \n    else  \n      server.send(message);  \n  });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/mock"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  globalTimeout: 3_600_000,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-timeouts", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: test.spec.ts", "input": "", "output": "import { test, expect } from './fixtures';  \n  \ntest('passes', async ({ page, database }) => {  \n  await expect(database).toHaveDatabaseUser('admin');  \n  await expect(page).toPassA11yAudit();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: Set an exact match:", "input": "", "output": "await expect(page.getByText('Welcome, John', { exact: true })).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test for the following scenario: New options `host` and `port` for the html reporter.", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['html', { host: 'localhost', port: '9223' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert.poll(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  return response.status();  \n}, {  \n  // Custom assert message for reporting, optional.  \n  message: 'make sure API eventually succeeds',  \n  // Poll for 10 seconds; defaults to 5 seconds. Pass 0 to disable timeout.  \n  timeout: 10000,  \n}).toBe(200);", "output": "await expect.poll(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  return response.status();  \n}, {  \n  // Custom expect message for reporting, optional.  \n  message: 'make sure API eventually succeeds',  \n  // Poll for 10 seconds; defaults to 5 seconds. Pass 0 to disable timeout.  \n  timeout: 10000,  \n}).toBe(200);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Scrolling\u200b | Most of the time, Playwright will automatically scroll for you before doing any actions. Therefore, you do not need to scroll explicitly.", "input": "", "output": "// Scrolls automatically so that button is visible  \nawait page.getByRole('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const path = await page.video().path();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/videos", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: If you'd like to share the default value among all the tests in the project, you can specify it in the playwright config, either globally or per project: | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  expect: {  \n    toHaveScreenshot: {  \n      stylePath: './screenshot.css'  \n    },  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.locator('button').click();", "output": "await page.locator('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.navigate('https://playwright.dev');  \n  assert(await page.textContent('.hero__title')).toMatchSnapshot('hero.txt');  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  expect(await page.textContent('.hero__title')).toMatchSnapshot('hero.txt');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \nconst REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \n// Request context is reused by all tests in the file.  \nlet apiContext;  \n  \ntest.beforeAll(async ({ playwright }) => {  \n  apiContext = await playwright.request.newContext({  \n    // All requests we send go to this API endpoint.  \n    baseURL: 'https://api.github.com',  \n    extraHTTPHeaders: {  \n      // We set this header per GitHub guidelines.  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add authorization token to all requests.  \n      // Assuming personal access token available in the environment.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    },  \n  });  \n});  \n  \ntest.afterAll(async ({ }) => {  \n  // Dispose all responses.  \n  await apiContext.dispose();  \n});  \n  \ntest('last created issue should be on the server', async ({ page }) => {  \n  await page.navigate(`https://github.com/${USER}/${REPO}/issues`);  \n  await page.getByText('New Issue').click();  \n  await page.getByRole('textbox', { name: 'Title' }).fill('Bug report 1');  \n  await page.getByRole('textbox', { name: 'Comment body' }).fill('Bug description');  \n  await page.getByText('Submit new issue').click();  \n  const issueId = page.url().substr(page.url().lastIndexOf('/'));  \n  \n  const newIssue = await apiContext.get(  \n      `https://api.github.com/repos/${USER}/${REPO}/issues/${issueId}`  \n  );  \n  assert(newIssue.ok()).toBeTruthy();  \n  assert(newIssue.json()).toEqual(assert.objectContaining({  \n    title: 'Bug report 1'  \n  }));  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \nconst REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \n// Request context is reused by all tests in the file.  \nlet apiContext;  \n  \ntest.beforeAll(async ({ playwright }) => {  \n  apiContext = await playwright.request.newContext({  \n    // All requests we send go to this API endpoint.  \n    baseURL: 'https://api.github.com',  \n    extraHTTPHeaders: {  \n      // We set this header per GitHub guidelines.  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add authorization token to all requests.  \n      // Assuming personal access token available in the environment.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    },  \n  });  \n});  \n  \ntest.afterAll(async ({ }) => {  \n  // Dispose all responses.  \n  await apiContext.dispose();  \n});  \n  \ntest('last created issue should be on the server', async ({ page }) => {  \n  await page.goto(`https://github.com/${USER}/${REPO}/issues`);  \n  await page.getByText('New Issue').click();  \n  await page.getByRole('textbox', { name: 'Title' }).fill('Bug report 1');  \n  await page.getByRole('textbox', { name: 'Comment body' }).fill('Bug description');  \n  await page.getByText('Submit new issue').click();  \n  const issueId = page.url().substr(page.url().lastIndexOf('/'));  \n  \n  const newIssue = await apiContext.get(  \n      `https://api.github.com/repos/${USER}/${REPO}/issues/${issueId}`  \n  );  \n  expect(newIssue.ok()).toBeTruthy();  \n  expect(newIssue.json()).toEqual(expect.objectContaining({  \n    title: 'Bug report 1'  \n  }));  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/api-testing", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: component.spec.ts", "input": "", "output": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('unmount', async ({ mount }) => {  \n  const component = await mount(Component);  \n  await component.unmount();  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test for the following scenario: component.spec.ts", "input": "", "output": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('slot', async ({ mount }) => {  \n  const component = await mount(Component, { slots: { default: 'Slot' } });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test for the following scenario: [page.getByTitle()](/docs/api/class-page#page-get-by-title) to locate an element by its title.", "input": "", "output": "await page.getByLabel('User Name').fill('John');  \n  \nawait page.getByLabel('Password').fill('secret-password');  \n  \nawait page.getByRole('button', { name: 'Sign in' }).click();  \n  \nawait expect(page.getByText('Welcome, John!')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert(page.getByTestId('status')).toHaveText('Submitted');", "output": "await expect(page.getByTestId('status')).toHaveText('Submitted');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect(page  \n    .getByRole('listitem')  \n    .filter({ has: page.getByRole('heading', { name: 'Product 2' }) }))  \n    .toHaveCount(1);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: You can't pass complex live objects to your component. Only plain JavaScript objects and built-in types like strings, numbers, dates etc. can be passed.", "input": "", "output": "test('this will work', async ({ mount }) => {  \n  const component = await mount(<ProcessViewer process={{ name: 'playwright' }}/>);  \n});  \n  \ntest('this will not work', async ({ mount }) => {  \n  // `process` is a Node object, we can't pass it to the browser and expect it to work.  \n  const component = await mount(<ProcessViewer process={process}/>);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport App from './App';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<App />);  \n  await expect(component).toContainText('Learn React');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Grants specified permissions to the browser context.  \n    permissions: ['notifications'],  \n  },  \n});  \n\n\n\nconst context = await browser.newContext({  \n  permissions: ['notifications'],  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.getByTestId('orange').click();", "output": "await page.getByTestId('orange').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.getByTestId('directions').click();", "output": "await page.getByTestId('directions').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Set timeout for a single test\u200b | example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('slow test', async ({ page }) => {  \n  test.slow(); // Easy way to triple the default timeout  \n  // ...  \n});  \n  \ntest('very slow test', async ({ page }) => {  \n  test.setTimeout(120_000);  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest.use({  \n  colorScheme: 'dark' // or 'light'  \n});  \n  \ntest('my test with dark mode', async ({ page }) => {  \n  // ...  \n});  \n\n\n\n// Create context with dark mode  \nconst context = await browser.newContext({  \n  colorScheme: 'dark' // or 'light'  \n});  \n  \n// Create page with dark mode  \nconst page = await browser.newPage({  \n  colorScheme: 'dark' // or 'light'  \n});  \n  \n// Change color scheme for the page  \nawait page.emulateMedia({ colorScheme: 'dark' });  \n  \n// Change media for page  \nawait page.emulateMedia({ media: 'print' });", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  colorScheme: 'dark' // or 'light'  \n});  \n  \ntest('my test with dark mode', async ({ page }) => {  \n  // ...  \n});  \n\n\n\n// Create context with dark mode  \nconst context = await browser.newContext({  \n  colorScheme: 'dark' // or 'light'  \n});  \n  \n// Create page with dark mode  \nconst page = await browser.newPage({  \n  colorScheme: 'dark' // or 'light'  \n});  \n  \n// Change color scheme for the page  \nawait page.emulateMedia({ colorScheme: 'dark' });  \n  \n// Change media for page  \nawait page.emulateMedia({ media: 'print' });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation", "type": "modification"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "Then use these fixtures in a test:", "output": "import { test, expect } from './fixtures';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://example.com');  \n  await expect(page.locator('body')).toHaveText('Changed by my-extension');  \n});  \n  \ntest('popup page', async ({ page, extensionId }) => {  \n  await page.goto(`chrome-extension://${extensionId}/popup.html`);  \n  await expect(page.locator('body')).toHaveText('my-extension popup');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/chrome-extensions", "type": "fixture"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Selector ambiguity is a common problem in automation testing. **\"strict\" mode** ensures that your selector points to a single element and throws otherwise. | Pass `strict: true` into your action calls to opt in.", "output": "// This will throw if you have more than one button!  \nawait page.click('button', { strict: true });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "New mode `retain-on-first-failure` for [testOptions.trace](/docs/api/class-testoptions#test-options-trace). In this mode, trace is recorded for the first run of each test, but not for retires. When test run fails, the trace file is retained, otherwise it is removed.", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    trace: 'retain-on-first-failure',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: component.spec.tsx", "input": "", "output": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('event', async ({ mount }) => {  \n  const component = await mount(<Component v-on:click={() => {}} />);  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test('records or updates the HAR file', async ({ page }) => {  \n  // Get the response from the HAR file  \n  await page.routeFromHAR('./hars/fruit.har', {  \n    url: '*/**/api/v1/fruits',  \n    update: true,  \n  });  \n  \n  // Go to the page  \n  await page.navigate('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the fruit is visible  \n  await assert(page.getByText('Strawberry')).toBeVisible();  \n});", "output": "test('records or updates the HAR file', async ({ page }) => {  \n  // Get the response from the HAR file  \n  await page.routeFromHAR('./hars/fruit.har', {  \n    url: '*/**/api/v1/fruits',  \n    update: true,  \n  });  \n  \n  // Go to the page  \n  await page.goto('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the fruit is visible  \n  await expect(page.getByText('Strawberry')).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect(page.locator('.status')).toHaveText('Submitted');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: You can create a test list file that will control the order of tests - first run `feature-b` tests, then `feature-a` tests. Note how each test file is wrapped in a `test.describe()` block that calls the function where tests are defined. This way `test.use()` calls only affect tests from a single file. | test.list.ts", "input": "", "output": "import { test } from '@playwright/test';  \nimport featureBTests from './feature-b.spec.ts';  \nimport featureATests from './feature-a.spec.ts';  \n  \ntest.describe(featureBTests);  \ntest.describe(featureATests);", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Fill the input by targeting the label.  \nawait assert(page.locator('label')).toHaveText('Password');", "output": "// Fill the input by targeting the label.  \nawait expect(page.locator('label')).toHaveText('Password');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Here is an example of reusing your existing MSW handlers in the test.", "input": "", "output": "import { handlers } from '@src/mocks/handlers';  \n  \ntest.beforeEach(async ({ router }) => {  \n  // install common handlers before each test  \n  await router.use(...handlers);  \n});  \n  \ntest('example test', async ({ mount }) => {  \n  // test as usual, your handlers are active  \n  // ...  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  await expect(page).toHaveScreenshot();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Full page screenshots\u200b | Full page screenshot is a screenshot of a full scrollable page, as if you had a very tall screen and the page could fit it entirely.", "input": "", "output": "await page.screenshot({ path: 'screenshot.png', fullPage: true });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/screenshots"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.pause();", "output": "await page.pause();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/debug", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "test('context request will share cookie storage with its browser context', async ({  \n  page,  \n  context,  \n}) => {  \n  await context.route('https://www.github.com/', async route => {  \n    // Send an API request that shares cookie storage with the browser context.  \n    const response = await context.request.fetch(route.request());  \n    const responseHeaders = response.headers();  \n  \n    // The response will have 'Set-Cookie' header.  \n    const responseCookies = new Map(responseHeaders['set-cookie']  \n        .split('\\n')  \n        .map(c => c.split(';', 2)[0].split('=')));  \n    // The response will have 3 cookies in 'Set-Cookie' header.  \n    expect(responseCookies.size).toBe(3);  \n    const contextCookies = await context.cookies();  \n    // The browser context will already contain all the cookies from the API response.  \n    expect(new Map(contextCookies.map(({ name, value }) =>  \n      [name, value])  \n    )).toEqual(responseCookies);  \n  \n    await route.fulfill({  \n      response,  \n      headers: { ...responseHeaders, foo: 'bar' },  \n    });  \n  });  \n  await page.goto('https://www.github.com/');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/api-testing", "type": "completion"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "The proper way to make a fixture parametrized in the config file is to specify `option: true` when defining the fixture. For example,", "output": "// CORRECT: THIS SNIPPET WORKS SINCE v1.18.  \n  \n// fixtures.js  \nconst test = base.extend({  \n  // Fixtures marked as \"option: true\" will get a value specified in the config,  \n  // or fallback to the default value.  \n  myParameter: ['default', { option: true }],  \n});  \n  \n// playwright.config.js  \nmodule.exports = {  \n  use: {  \n    myParameter: 'value',  \n  },  \n};", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/release-notes", "type": "fixture"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport App from './App';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<App />);  \n  await expect(component).toContainText('Learn React');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: Alternatively, if you cannot find a suitable locator for the parent element, use `xpath=..`. Note that this method is not as reliable, because any changes to the DOM structure will break your tests. Prefer [locator.filter()](/docs/api/class-locator#locator-filter) when possible.", "input": "", "output": "const parent = page.getByText('Hello').locator('xpath=..');", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "Validating postconditions\u200b | The following test creates a new issue via user interface in the browser and then uses checks if it was created via API:", "output": "import { test, expect } from '@playwright/test';  \n  \nconst REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \n// Request context is reused by all tests in the file.  \nlet apiContext;  \n  \ntest.beforeAll(async ({ playwright }) => {  \n  apiContext = await playwright.request.newContext({  \n    // All requests we send go to this API endpoint.  \n    baseURL: 'https://api.github.com',  \n    extraHTTPHeaders: {  \n      // We set this header per GitHub guidelines.  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add authorization token to all requests.  \n      // Assuming personal access token available in the environment.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    },  \n  });  \n});  \n  \ntest.afterAll(async ({ }) => {  \n  // Dispose all responses.  \n  await apiContext.dispose();  \n});  \n  \ntest('last created issue should be on the server', async ({ page }) => {  \n  await page.goto(`https://github.com/${USER}/${REPO}/issues`);  \n  await page.getByText('New Issue').click();  \n  await page.getByRole('textbox', { name: 'Title' }).fill('Bug report 1');  \n  await page.getByRole('textbox', { name: 'Comment body' }).fill('Bug description');  \n  await page.getByText('Submit new issue').click();  \n  const issueId = page.url().substr(page.url().lastIndexOf('/'));  \n  \n  const newIssue = await apiContext.get(  \n      `https://api.github.com/repos/${USER}/${REPO}/issues/${issueId}`  \n  );  \n  expect(newIssue.ok()).toBeTruthy();  \n  expect(newIssue.json()).toEqual(expect.objectContaining({  \n    title: 'Bug report 1'  \n  }));  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/api-testing", "type": "fixture"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { chromium, devices } from 'playwright';  \nimport assert from 'node:assert';  \n  \n(async () => {  \n  // Setup  \n  const browser = await chromium.launch();  \n  const context = await browser.newContext(devices['iPhone 11']);  \n  const page = await context.newPage();  \n  \n  // The actual interesting bit  \n  await context.route('**.jpg', route => route.abort());  \n  await page.goto('https://example.com/');  \n  \n  assert(await page.title() === 'Example Domain'); // \ud83d\udc4e not a Web First assertion  \n  \n  // Teardown  \n  await context.close();  \n  await browser.close();  \n})();  \n\n\n\nconst assert = require('node:assert');  \nconst { chromium, devices } = require('playwright');  \n  \n(async () => {  \n  // Setup  \n  const browser = await chromium.launch();  \n  const context = await browser.newContext(devices['iPhone 11']);  \n  const page = await context.newPage();  \n  \n  // The actual interesting bit  \n  await context.route('**.jpg', route => route.abort());  \n  await page.goto('https://example.com/');  \n  \n  assert(await page.title() === 'Example Domain'); // \ud83d\udc4e not a Web First assertion  \n  \n  // Teardown  \n  await context.close();  \n  await browser.close();  \n})();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/library", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: New assertion [expect(locator).toBeInViewport()](/docs/api/class-locatorassertions#locator-assertions-to-be-in-viewport) ensures that locator points to an element that intersects viewport, according to the [intersection observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API).", "input": "", "output": "const button = page.getByRole('button');  \n  \n// Make sure at least some part of element intersects viewport.  \nawait expect(button).toBeInViewport();  \n  \n// Make sure element is fully outside of viewport.  \nawait expect(button).not.toBeInViewport();  \n  \n// Make sure that at least half of the element intersects viewport.  \nawait expect(button).toBeInViewport({ ratio: 0.5 });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "tests/example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  geolocation: { longitude: 41.890221, latitude: 12.492348 },  \n  permissions: ['geolocation'],  \n});  \n  \ntest('my test with geolocation', async ({ page }) => {  \n  // ...  \n});  \n\n\n\nconst context = await browser.newContext({  \n  geolocation: { longitude: 41.890221, latitude: 12.492348 },  \n  permissions: ['geolocation']  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Generate a Playwright test for the following scenario: \ud83d\udc3e Steps API with [`test.step`](/docs/api/class-test#test-step)\u200b | Split long tests into multiple steps using `test.step()` API:", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  await test.step('Log in', async () => {  \n    // ...  \n  });  \n  await test.step('news feed', async () => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const status = await page.evaluate(async () => {  \n  const response = await fetch(location.href);  \n  return response.status;  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/evaluating", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.route('**/api/fetch_data_third_party_dependency', route => route.fulfill({  \n  status: 200,  \n  body: testData,  \n}));  \nawait page.navigate('https://example.com');", "output": "await page.route('**/api/fetch_data_third_party_dependency', route => route.fulfill({  \n  status: 200,  \n  body: testData,  \n}));  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/best-practices", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Locate an item by its text content and click it.", "input": "", "output": "await page.getByText('orange').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  // environment variables which are set in globalSetup are only available inside test().  \n  const { FOO, BAR } = process.env;  \n  \n  // FOO and BAR properties are populated.  \n  expect(FOO).toEqual('some data');  \n  \n  const complexData = JSON.parse(BAR);  \n  expect(BAR).toEqual({ some: 'data' });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  testDir: './tests',  \n  snapshotPathTemplate: '{testDir}/__screenshots__/{testFilePath}/{arg}{ext}',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  webServer: {  \n    command: 'npm run start', // command to launch  \n    url: 'http://127.0.0.1:3000', // url to await for  \n    timeout: 120 * 1000,  \n    reuseExistingServer: !process.env.CI,  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  webServer: {  \n    command: 'npm run start', // command to launch  \n    url: 'http://127.0.0.1:3000', // url to await for  \n    timeout: 120 * 1000,  \n    reuseExistingServer: !process.env.CI,  \n  },  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "This method will emit all the necessary keyboard events, with all the `keydown`, `keyup`, `keypress` events in place. You can even specify the optional `delay` between the key presses to simulate real user behavior. | Keys and shortcuts\u200b", "output": "// Hit Enter  \nawait page.getByText('Submit').press('Enter');  \n  \n// Dispatch Control+Right  \nawait page.getByRole('textbox').press('Control+ArrowRight');  \n  \n// Press $ sign on keyboard  \nawait page.getByRole('textbox').press('$');", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "Now we can use `toHaveAmount` in the test. | example.spec.ts", "output": "import { test, expect } from './fixtures';  \n  \ntest('amount', async () => {  \n  await expect(page.locator('.cart')).toHaveAmount(4);  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Navigate and click element  \n// Click will auto-wait for the element  \nawait page.goto('https://example.com');  \nawait page.getByText('Example Domain').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/navigations", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// <input id=name>  \nawait page.locator('#name').press('Shift+A');  \n  \n// <input id=name>  \nawait page.locator('#name').press('Shift+ArrowLeft');", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "The proper way to make a fixture parametrized in the config file is to specify `option: true` when defining the fixture. For example,", "output": "// CORRECT: THIS SNIPPET WORKS SINCE v1.18.  \n  \n// fixtures.js  \nconst test = base.extend({  \n  // Fixtures marked as \"option: true\" will get a value specified in the config,  \n  // or fallback to the default value.  \n  myParameter: ['default', { option: true }],  \n});  \n  \n// playwright.config.js  \nmodule.exports = {  \n  use: {  \n    myParameter: 'value',  \n  },  \n};", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Playwright Library | Playwright module provides a method to launch a browser instance. The following is a typical example of using Playwright to drive automation:", "output": "const { chromium, firefox, webkit } = require('playwright');  \n  \n(async () => {  \n  const browser = await chromium.launch();  // Or 'firefox' or 'webkit'.  \n  const page = await browser.newPage();  \n  await page.goto('http://example.com');  \n  // other actions...  \n  await browser.close();  \n})();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/api/class-playwright", "type": "navigation"}}
{"instruction": "Generate a Playwright test for the following scenario: [test.beforeEach()](/docs/api/class-test#test-before-each) and [test.afterEach()](/docs/api/class-test#test-after-each) hooks run before/after each test declared in the same file and same [test.describe()](/docs/api/class-test#test-describe) block (if any). If you want to declare hooks that run before/after each test globally, you can declare them as auto fixtures like this: | fixtures.ts", "input": "", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend<{ forEachTest: void }>({  \n  forEachTest: [async ({ page }, use) => {  \n    // This code runs before every test.  \n    await page.goto('http://localhost:8000');  \n    await use();  \n    // This code runs after every test.  \n    console.log('Last URL:', page.url());  \n  }, { auto: true }],  // automatically starts for every test.  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \nimport { PlaywrightDevPage } from './playwright-dev-page';  \n  \ntest('getting started should contain table of contents', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.getStarted();  \n  await assert(playwrightDev.tocList).toHaveText([  \n    `How to install Playwright`,  \n    `What's Installed`,  \n    `How to run the example test`,  \n    `How to open the HTML test report`,  \n    `Write tests using web first assertions, page fixtures and locators`,  \n    `Run single test, multiple tests, headed mode`,  \n    `Generate tests with Codegen`,  \n    `See a trace of your tests`  \n  ]);  \n});  \n  \ntest('should show Page Object Model article', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.pageObjectModel();  \n  await assert(page.locator('article')).toContainText('Page Object Model is a common pattern');  \n});", "output": "import { test, expect } from '@playwright/test';  \nimport { PlaywrightDevPage } from './playwright-dev-page';  \n  \ntest('getting started should contain table of contents', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.getStarted();  \n  await expect(playwrightDev.tocList).toHaveText([  \n    `How to install Playwright`,  \n    `What's Installed`,  \n    `How to run the example test`,  \n    `How to open the HTML test report`,  \n    `Write tests using web first assertions, page fixtures and locators`,  \n    `Run single test, multiple tests, headed mode`,  \n    `Generate tests with Codegen`,  \n    `See a trace of your tests`  \n  ]);  \n});  \n  \ntest('should show Page Object Model article', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.pageObjectModel();  \n  await expect(page.locator('article')).toContainText('Page Object Model is a common pattern');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/pom", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.locator('x-details', { hasText: 'Details' }).click();  \n\n\n\n<x-details role=button aria-expanded=true aria-controls=inner-details>  \n  <div>Title</div>  \n  #shadow-root  \n    <div id=inner-details>Details</div>  \n</x-details>", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: When using [page.goto()](/docs/api/class-page#page-goto), [page.route()](/docs/api/class-page#page-route), [page.waitForURL()](/docs/api/class-page#page-wait-for-url), [page.waitForRequest()](/docs/api/class-page#page-wait-for-request), or [page.waitForResponse()](/docs/api/class-page#page-wait-for-response) it takes the base URL in consideration by using the [`URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL) constructor for building the corresponding URL. For Example, by setting the baseURL to `http://127.0.0.1:3000` and navigating to `/login` in your tests, Playwright will run the test using `http://127.0.0.1:3000/login`. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Rest of your config...  \n  \n  // Run your local dev server before starting the tests  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n  },  \n  use: {  \n    baseURL: 'http://127.0.0.1:3000',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-webserver"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  expect: {  \n    timeout: 10_000,  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "You can override options for a specific project using the `project` option in the Playwright config.", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        locale: 'de-DE',  \n      },  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Tests start already authenticated because we specified `storageState` in the config. | tests/example.spec.ts", "output": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  // page is authenticated  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as baseTest, request } from '@playwright/test';  \nimport fs from 'fs';  \nimport path from 'path';  \n  \nexport * from '@playwright/test';  \nexport const test = baseTest.extend<{}, { workerStorageState: string }>({  \n  // Use the same storage state for all tests in this worker.  \n  storageState: ({ workerStorageState }, use) => use(workerStorageState),  \n  \n  // Authenticate once per worker with a worker-scoped fixture.  \n  workerStorageState: [async ({}, use) => {  \n    // Use parallelIndex as a unique identifier for each worker.  \n    const id = test.info().parallelIndex;  \n    const fileName = path.resolve(test.info().project.outputDir, `.auth/${id}.json`);  \n  \n    if (fs.existsSync(fileName)) {  \n      // Reuse existing authentication state if any.  \n      await use(fileName);  \n      return;  \n    }  \n  \n    // Important: make sure we authenticate in a clean environment by unsetting storage state.  \n    const context = await request.newContext({ storageState: undefined });  \n  \n    // Acquire a unique account, for example create a new one.  \n    // Alternatively, you can have a list of precreated accounts for testing.  \n    // Make sure that accounts are unique, so that multiple team members  \n    // can run tests at the same time without interference.  \n    const account = await acquireAccount(id);  \n  \n    // Send authentication request. Replace with your own.  \n    await context.post('https://github.com/login', {  \n      form: {  \n        'user': 'user',  \n        'password': 'password'  \n      }  \n    });  \n  \n    await context.storageState({ path: fileName });  \n    await context.dispose();  \n    await use(fileName);  \n  }, { scope: 'worker' }],  \n});", "output": "import { test as baseTest, request } from '@playwright/test';  \nimport fs from 'fs';  \nimport path from 'path';  \n  \nexport * from '@playwright/test';  \nexport const test = baseTest.extend<{}, { workerStorageState: string }>({  \n  // Use the same storage state for all tests in this worker.  \n  storageState: ({ workerStorageState }, use) => use(workerStorageState),  \n  \n  // Authenticate once per worker with a worker-scoped fixture.  \n  workerStorageState: [async ({}, use) => {  \n    // Use parallelIndex as a unique identifier for each worker.  \n    const id = test.info().parallelIndex;  \n    const fileName = path.resolve(test.info().project.outputDir, `.auth/${id}.json`);  \n  \n    if (fs.existsSync(fileName)) {  \n      // Reuse existing authentication state if any.  \n      await use(fileName);  \n      return;  \n    }  \n  \n    // Important: make sure we authenticate in a clean environment by unsetting storage state.  \n    const context = await request.newContext({ storageState: undefined });  \n  \n    // Acquire a unique account, for example create a new one.  \n    // Alternatively, you can have a list of precreated accounts for testing.  \n    // Make sure that accounts are unique, so that multiple team members  \n    // can run tests at the same time without interference.  \n    const account = await acquireAccount(id);  \n  \n    // Send authentication request. Replace with your own.  \n    await context.post('https://github.com/login', {  \n      form: {  \n        'user': 'user',  \n        'password': 'password'  \n      }  \n    });  \n  \n    await context.storageState({ path: fileName });  \n    await context.dispose();  \n    await use(fileName);  \n  }, { scope: 'worker' }],  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/auth", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test } from '@playwright/experimental-ct-vue';  \nimport { Component } from './mycomponent';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(Component, {  \n    hooksConfig: {  \n      /* anything to configure your app */  \n    }  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Example\u200b | Here is what a typical component test looks like:", "output": "test('event should work', async ({ mount }) => {  \n  let clicked = false;  \n  \n  // Mount a component. Returns locator pointing to the component.  \n  const component = await mount(  \n    <Button title=\"Submit\" onClick={() => { clicked = true }}></Button>  \n  );  \n  \n  // As with any Playwright test, assert locator text.  \n  await expect(component).toContainText('Submit');  \n  \n  // Perform locator click. This will trigger the event.  \n  await component.click();  \n  \n  // Assert that respective events have been fired.  \n  expect(clicked).toBeTruthy();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test for the following scenario: You can convert any synchronous `expect` to an asynchronous polling one using `expect.poll`. | The following method will poll given function until it returns HTTP status 200:", "input": "", "output": "await expect.poll(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  return response.status();  \n}, {  \n  // Custom expect message for reporting, optional.  \n  message: 'make sure API eventually succeeds',  \n  // Poll for 10 seconds; defaults to 5 seconds. Pass 0 to disable timeout.  \n  timeout: 10000,  \n}).toBe(200);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('navigation', () => {  \n  test.beforeEach(async ({ page }) => {  \n    // Go to the starting url before each test.  \n    await page.goto('https://playwright.dev/');  \n  });  \n  \n  test('main navigation', async ({ page }) => {  \n    // Assertions use the expect API.  \n    await expect(page).toHaveURL('https://playwright.dev/');  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/writing-tests", "type": "completion"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "`/Log\\s*in/i` \\- body can be a [JavaScript-like regex](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp) wrapped in `/` symbols. For example, `text=/Log\\s*in/i` matches `<button>Login</button>` and `<button>log IN</button>`.", "output": "await page.locator('text=/Log\\\\s*in/i').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.getByLabel('Password').focus();", "output": "await page.getByLabel('Password').focus();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input", "type": "modification"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "For example, you can run a group of tests just in Chromium by passing a callback. | example.spec.ts", "output": "test.describe('chromium only', () => {  \n  test.skip(({ browserName }) => browserName !== 'chromium', 'Chromium only!');  \n  \n  test.beforeAll(async () => {  \n    // This hook is only run in Chromium.  \n  });  \n  \n  test('test 1', async ({ page }) => {  \n    // This test is only run in Chromium.  \n  });  \n  \n  test('test 2', async ({ page }) => {  \n    // This test is only run in Chromium.  \n  });  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-annotations", "type": "fixture"}}
{"instruction": "Generate a Playwright test for the following scenario: And then locate the element as you would normally do:", "input": "", "output": "await page.getByTestId('directions').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "By setting up projects we can also run a group of tests with different timeouts or retries or run a group of tests against different environments. For example we can run our tests against a staging environment with 2 retries as well as against a production environment with 0 retries. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  timeout: 60000, // Timeout is shared between all tests.  \n  projects: [  \n    {  \n      name: 'staging',  \n      use: {  \n        baseURL: 'staging.example.com',  \n      },  \n      retries: 2,  \n    },  \n    {  \n      name: 'production',  \n      use: {  \n        baseURL: 'production.example.com',  \n      },  \n      retries: 0,  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-projects"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "my-test.js", "output": "const base = require('@playwright/test');  \n  \nexports.test = base.test.extend({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  person: ['John', { option: true }],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Click a button with accessible name \"log in\"  \nawait page.locator('role=button[name=\"log in\"]').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    testIdAttribute: 'data-pw'  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the page_object pattern.", "input": "Below is an example that [creates fixtures](/docs/test-fixtures#creating-a-fixture) for two [Page Object Models](/docs/pom) \\- admin POM and user POM. It assumes `adminStorageState.json` and `userStorageState.json` files were created in the global setup. | playwright/fixtures.ts", "output": "import { test as base, type Page, type Locator } from '@playwright/test';  \n  \n// Page Object Model for the \"admin\" page.  \n// Here you can add locators and helper methods specific to the admin page.  \nclass AdminPage {  \n  // Page signed in as \"admin\".  \n  page: Page;  \n  \n  // Example locator pointing to \"Welcome, Admin\" greeting.  \n  greeting: Locator;  \n  \n  constructor(page: Page) {  \n    this.page = page;  \n    this.greeting = page.locator('#greeting');  \n  }  \n}  \n  \n// Page Object Model for the \"user\" page.  \n// Here you can add locators and helper methods specific to the user page.  \nclass UserPage {  \n  // Page signed in as \"user\".  \n  page: Page;  \n  \n  // Example locator pointing to \"Welcome, User\" greeting.  \n  greeting: Locator;  \n  \n  constructor(page: Page) {  \n    this.page = page;  \n    this.greeting = page.locator('#greeting');  \n  }  \n}  \n  \n// Declare the types of your fixtures.  \ntype MyFixtures = {  \n  adminPage: AdminPage;  \n  userPage: UserPage;  \n};  \n  \nexport * from '@playwright/test';  \nexport const test = base.extend<MyFixtures>({  \n  adminPage: async ({ browser }, use) => {  \n    const context = await browser.newContext({ storageState: 'playwright/.auth/admin.json' });  \n    const adminPage = new AdminPage(await context.newPage());  \n    await use(adminPage);  \n    await context.close();  \n  },  \n  userPage: async ({ browser }, use) => {  \n    const context = await browser.newContext({ storageState: 'playwright/.auth/user.json' });  \n    const userPage = new UserPage(await context.newPage());  \n    await use(userPage);  \n    await context.close();  \n  },  \n});", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect(page).toHaveScreenshot('landing.png');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend<{ forEachTest: void }>({  \n  forEachTest: [async ({ page }, use) => {  \n    // This code runs before every test.  \n    await page.navigate('http://localhost:8000');  \n    await use();  \n    // This code runs after every test.  \n    console.log('Last URL:', page.url());  \n  }, { auto: true }],  // automatically starts for every test.  \n});", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend<{ forEachTest: void }>({  \n  forEachTest: [async ({ page }, use) => {  \n    // This code runs before every test.  \n    await page.goto('http://localhost:8000');  \n    await use();  \n    // This code runs after every test.  \n    console.log('Last URL:', page.url());  \n  }, { auto: true }],  // automatically starts for every test.  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  assert: {  \n    timeout: 10_000,  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  expect: {  \n    timeout: 10_000,  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: New [page.removeLocatorHandler()](/docs/api/class-page#page-remove-locator-handler) method for removing previously added locator handlers.", "input": "", "output": "const locator = page.getByText('This interstitial covers the button');  \nawait page.addLocatorHandler(locator, async overlay => {  \n  await overlay.locator('#close').click();  \n}, { times: 3, noWaitAfter: true });  \n// Run your tests that can be interrupted by the overlay.  \n// ...  \nawait page.removeLocatorHandler(locator);", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: Now you can use a relative path when navigating the page: | test.spec.ts", "input": "", "output": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  // This will navigate to http://127.0.0.1:3000/login  \n  await page.goto('./login');  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-webserver"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const buffer = await page.screenshot();  \nconsole.log(buffer.toString('base64'));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/screenshots", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the page_object pattern.", "input": "Click to expand the code for the `TodoPage` | todo-page.ts", "output": "import type { Page, Locator } from '@playwright/test';  \n  \nexport class TodoPage {  \n  private readonly inputBox: Locator;  \n  private readonly todoItems: Locator;  \n  \n  constructor(public readonly page: Page) {  \n    this.inputBox = this.page.locator('input.new-todo');  \n    this.todoItems = this.page.getByTestId('todo-item');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://demo.playwright.dev/todomvc/');  \n  }  \n  \n  async addToDo(text: string) {  \n    await this.inputBox.fill(text);  \n    await this.inputBox.press('Enter');  \n  }  \n  \n  async remove(text: string) {  \n    const todo = this.todoItems.filter({ hasText: text });  \n    await todo.hover();  \n    await todo.getByLabel('Delete').click();  \n  }  \n  \n  async removeAll() {  \n    while ((await this.todoItems.count()) > 0) {  \n      await this.todoItems.first().hover();  \n      await this.todoItems.getByLabel('Delete').first().click();  \n    }  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test for the following scenario: If you'd like to target the parent `<li>` of a label with text `\"Hello\"`, using [locator.filter()](/docs/api/class-locator#locator-filter) works best:", "input": "", "output": "const child = page.getByText('Hello');  \nconst parent = page.getByRole('listitem').filter({ has: child });", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test as baseTest, expect } from '@playwright/test';  \n// Import project utils for managing users in the test database.  \nimport { createUserInTestDatabase, deleteUserFromTestDatabase } from './my-db-utils';  \n  \nexport * from '@playwright/test';  \nexport const test = baseTest.extend<{}, { dbUserName: string }>({  \n  // Returns db user name unique for the worker.  \n  dbUserName: [async ({ }, use) => {  \n    // Use workerIndex as a unique identifier for each worker.  \n    const userName = `user-${test.info().workerIndex}`;  \n    // Initialize user in the database.  \n    await createUserInTestDatabase(userName);  \n    await use(userName);  \n    // Clean up after the tests are done.  \n    await deleteUserFromTestDatabase(userName);  \n  }, { scope: 'worker' }],  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parallel", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "component.spec.tsx", "output": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(<Component/>);  \n  await component.update(  \n      <Component msg=\"greetings\" v-on:click={() => {}}>Child</Component>  \n  );  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Single selection matching the value or label  \nawait page.getByLabel('Choose a color').selectOption('blue');  \n  \n// Single selection matching the label  \nawait page.getByLabel('Choose a color').selectOption({ label: 'Blue' });  \n  \n// Multiple selected items  \nawait page.getByLabel('Choose multiple colors').selectOption(['red', 'green', 'blue']);", "output": "// Single selection matching the value or label  \nawait page.getByLabel('Choose a color').selectOption('blue');  \n  \n// Single selection matching the label  \nawait page.getByLabel('Choose a color').selectOption({ label: 'Blue' });  \n  \n// Multiple selected items  \nawait page.getByLabel('Choose multiple colors').selectOption(['red', 'green', 'blue']);", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/input", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: `:nth-match()` is also useful to wait until a specified number of elements appear, using [locator.waitFor()](/docs/api/class-locator#locator-wait-for).", "input": "", "output": "// Wait until all three buttons are visible  \nawait page.locator(':nth-match(:text(\"Buy\"), 3)').waitFor();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "The `:has()` pseudo-class is an [experimental CSS pseudo-class](https://developer.mozilla.org/en-US/docs/Web/CSS/:has). It returns an element if any of the selectors passed as parameters relative to the `:scope` of the given element match at least one element. | Following snippet returns text content of an `<article>` element that has a `<div class=promo>` inside.", "output": "await page.locator('article:has(div.promo)').textContent();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "With Playwright you can emulate a real device such as a mobile phone or tablet. See our [guide on projects](/docs/test-projects) for more info on emulating devices. You can also emulate the `\"geolocation\"`, `\"locale\"` and `\"timezone\"` for all tests or for a specific test as well as set the `\"permissions\"` to show notifications or change the `\"colorScheme\"`. See our [Emulation](/docs/emulation) guide to learn more. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Emulates `'prefers-colors-scheme'` media feature.  \n    colorScheme: 'dark',  \n  \n    // Context geolocation.  \n    geolocation: { longitude: 12.492507, latitude: 41.889938 },  \n  \n    // Emulates the user locale.  \n    locale: 'en-GB',  \n  \n    // Grants specified permissions to the browser context.  \n    permissions: ['geolocation'],  \n  \n    // Emulates the user timezone.  \n    timezoneId: 'Europe/Paris',  \n  \n    // Viewport used for all pages in the context.  \n    viewport: { width: 1280, height: 720 },  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options"}}
{"instruction": "Generate a Playwright test for the following scenario: Handling new pages\u200b | The `page` event on browser contexts can be used to get new pages that are created in the context. This can be used to handle new pages opened by `target=\"_blank\"` links.", "input": "", "output": "// Start waiting for new page before clicking. Note no await.  \nconst pagePromise = context.waitForEvent('page');  \nawait page.getByText('open new tab').click();  \nconst newPage = await pagePromise;  \n// Interact with the new page normally.  \nawait newPage.getByRole('button').click();  \nconsole.log(await newPage.title());", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/pages"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from './my-test';  \n  \ntest.beforeEach(async ({ settingsPage }) => {  \n  await settingsPage.switchToDarkMode();  \n});  \n  \ntest('basic test', async ({ todoPage, page }) => {  \n  await todoPage.addToDo('something nice');  \n  await expect(page.getByTestId('todo-title')).toContainText(['something nice']);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-fixtures", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: Set action and navigation timeouts in the config\u200b | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    actionTimeout: 10 * 1000,  \n    navigationTimeout: 30 * 1000,  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-timeouts"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "test('this will work', async ({ mount }) => {  \n  const component = await mount(<ProcessViewer process={{ name: 'playwright' }}/>);  \n});  \n  \ntest('this will not work', async ({ mount }) => {  \n  // `process` is a Node object, we can't pass it to the browser and expect it to work.  \n  const component = await mount(<ProcessViewer process={process}/>);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "completion"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Scrolling\u200b | Most of the time, Playwright will automatically scroll for you before doing any actions. Therefore, you do not need to scroll explicitly.", "output": "// Scrolls automatically so that button is visible  \nawait page.getByRole('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input", "type": "navigation"}}
{"instruction": "Generate a Playwright test for the following scenario: Using `.zip` path for `recordHar` context option automatically zips the resulting HAR:", "input": "", "output": "const context = await browser.newContext({  \n  recordHar: {  \n    path: 'github.har.zip',  \n  }  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.routeWebSocket('/ws', ws => {  \n  ws.onMessage(message => {  \n    if (message === 'request')  \n      ws.send('response');  \n  });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Limit the number of workers on CI, use default locally  \n  workers: process.env.CI ? 2 : undefined,  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Limit the number of workers on CI, use default locally  \n  workers: process.env.CI ? 2 : undefined,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Mouse click\u200b | Performs a simple human click.", "input": "", "output": "// Generic click  \nawait page.getByRole('button').click();  \n  \n// Double click  \nawait page.getByText('Item').dblclick();  \n  \n// Right click  \nawait page.getByText('Item').click({ button: 'right' });  \n  \n// Shift + click  \nawait page.getByText('Item').click({ modifiers: ['Shift'] });  \n  \n// Ctrl + click or Windows and Linux  \n// Meta + click on macOS  \nawait page.getByText('Item').click({ modifiers: ['ControlOrMeta'] });  \n  \n// Hover over element  \nawait page.getByText('Item').hover();  \n  \n// Click the top left corner  \nawait page.getByText('Item').click({ position: { x: 0, y: 0 } });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Hit Enter  \nawait page.getByText('Submit').press('Enter');  \n  \n// Dispatch Control+Right  \nawait page.getByRole('textbox').press('Control+ArrowRight');  \n  \n// Press $ sign on keyboard  \nawait page.getByRole('textbox').press('$');", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('my test', async ({ page }, testInfo) => {  \n  if (testInfo.retry)  \n    await cleanSomeCachesOnTheServer();  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-retries", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Specify expect timeout for a single assertion\u200b | example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example', async ({ page }) => {  \n  await expect(locator).toHaveText('hello', { timeout: 10_000 });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/experimental-ct-vue';  \nimport App from './App.vue';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(App);  \n  await expect(component).toContainText('Learn Vue');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.locator(  \n    '#tsf > div:nth-child(2) > div.A8SBwf > div.RNNXgb > div > div.a4bIc > input'  \n).click();  \n  \nawait page  \n    .locator('//*[@id=\"tsf\"]/div[2]/div[1]/div[1]/div/div[2]/input')  \n    .click();", "output": "await page.locator(  \n    '#tsf > div:nth-child(2) > div.A8SBwf > div.RNNXgb > div > div.a4bIc > input'  \n).click();  \n  \nawait page  \n    .locator('//*[@id=\"tsf\"]/div[2]/div[1]/div[1]/div/div[2]/input')  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('slow test', async ({ page }) => {  \n  test.slow(); // Easy way to triple the default timeout  \n  // ...  \n});  \n  \ntest('very slow test', async ({ page }) => {  \n  test.setTimeout(120_000);  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Start waiting for popup before clicking. Note no await.  \nconst popupPromise = page.waitForEvent('popup');  \nawait page.getByText('open the popup').click();  \nconst popup = await popupPromise;  \n// Interact with the new popup normally.  \nawait popup.getByRole('button').click();  \nconsole.log(await popup.title());", "output": "// Start waiting for popup before clicking. Note no await.  \nconst popupPromise = page.waitForEvent('popup');  \nawait page.getByText('open the popup').click();  \nconst popup = await popupPromise;  \n// Interact with the new popup normally.  \nawait popup.getByRole('button').click();  \nconsole.log(await popup.title());", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/pages", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// This will throw if you have more than one button!  \nawait page.click('button', { strict: true });", "output": "// This will throw if you have more than one button!  \nawait page.click('button', { strict: true });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('context fetch', async ({ page }) => {  \n  // Do a GET request on behalf of page  \n  const response = await page.request.get('http://example.com/foo.json');  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "We can use this option in the test, similarly to [fixtures](/docs/test-fixtures). | example.spec.ts", "output": "import { test } from './my-test';  \n  \ntest('test 1', async ({ page, person }) => {  \n  await page.goto(`/index.html`);  \n  await expect(page.locator('#node')).toContainText(person);  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Change timeout from a `beforeEach` hook\u200b | example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.beforeEach(async ({ page }, testInfo) => {  \n  // Extend timeout for all tests running this hook by 30 seconds.  \n  testInfo.setTimeout(testInfo.timeout + 30_000);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    /* Test against desktop browsers */  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n    },  \n    {  \n      name: 'firefox',  \n      use: { ...devices['Desktop Firefox'] },  \n    },  \n    {  \n      name: 'webkit',  \n      use: { ...devices['Desktop Safari'] },  \n    },  \n    /* Test against mobile viewports. */  \n    {  \n      name: 'Mobile Chrome',  \n      use: { ...devices['Pixel 5'] },  \n    },  \n    {  \n      name: 'Mobile Safari',  \n      use: { ...devices['iPhone 12'] },  \n    },  \n    /* Test against branded browsers. */  \n    {  \n      name: 'Google Chrome',  \n      use: { ...devices['Desktop Chrome'], channel: 'chrome' }, // or 'chrome-beta'  \n    },  \n    {  \n      name: 'Microsoft Edge',  \n      use: { ...devices['Desktop Edge'], channel: 'msedge' }, // or 'msedge-dev'  \n    },  \n  ],  \n});", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    /* Test against desktop browsers */  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n    },  \n    {  \n      name: 'firefox',  \n      use: { ...devices['Desktop Firefox'] },  \n    },  \n    {  \n      name: 'webkit',  \n      use: { ...devices['Desktop Safari'] },  \n    },  \n    /* Test against mobile viewports. */  \n    {  \n      name: 'Mobile Chrome',  \n      use: { ...devices['Pixel 5'] },  \n    },  \n    {  \n      name: 'Mobile Safari',  \n      use: { ...devices['iPhone 12'] },  \n    },  \n    /* Test against branded browsers. */  \n    {  \n      name: 'Google Chrome',  \n      use: { ...devices['Desktop Chrome'], channel: 'chrome' }, // or 'chrome-beta'  \n    },  \n    {  \n      name: 'Microsoft Edge',  \n      use: { ...devices['Desktop Edge'], channel: 'msedge' }, // or 'msedge-dev'  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/browsers", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "In most cases, it'll be written in one line:", "output": "await page.getByRole('link', { name: 'Get started' }).click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/writing-tests"}}
{"instruction": "Generate a Playwright test for the following scenario: `beforeAll` and `afterAll` hooks have a separate timeout, by default equal to test timeout. You can change it separately for each hook by calling [testInfo.setTimeout()](/docs/api/class-testinfo#test-info-set-timeout) inside the hook. | example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.beforeAll(async () => {  \n  // Set timeout for this hook.  \n  test.setTimeout(60000);  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-timeouts"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Other Options\u200b | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Maximum time each action such as `click()` can take. Defaults to 0 (no limit).  \n    actionTimeout: 0,  \n  \n    // Name of the browser that runs tests. For example `chromium`, `firefox`, `webkit`.  \n    browserName: 'chromium',  \n  \n    // Toggles bypassing Content-Security-Policy.  \n    bypassCSP: true,  \n  \n    // Channel to use, for example \"chrome\", \"chrome-beta\", \"msedge\", \"msedge-beta\".  \n    channel: 'chrome',  \n  \n    // Run browser in headless mode.  \n    headless: false,  \n  \n    // Change the default data-testid attribute.  \n    testIdAttribute: 'pw-test-id',  \n  },  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-use-options"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test('test customer login', {  \n  tag: ['@fast', '@login'],  \n}, async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Create `playwright/fixtures.ts` file that will [create `dbUserName` fixture](/docs/test-fixtures#creating-a-fixture) and initialize a new user in the test database. Use [testInfo.workerIndex](/docs/api/class-testinfo#test-info-worker-index) to differentiate between workers. | playwright/fixtures.ts", "output": "import { test as baseTest, expect } from '@playwright/test';  \n// Import project utils for managing users in the test database.  \nimport { createUserInTestDatabase, deleteUserFromTestDatabase } from './my-db-utils';  \n  \nexport * from '@playwright/test';  \nexport const test = baseTest.extend<{}, { dbUserName: string }>({  \n  // Returns db user name unique for the worker.  \n  dbUserName: [async ({ }, use) => {  \n    // Use workerIndex as a unique identifier for each worker.  \n    const userName = `user-${test.info().workerIndex}`;  \n    // Initialize user in the database.  \n    await createUserInTestDatabase(userName);  \n    await use(userName);  \n    // Clean up after the tests are done.  \n    await deleteUserFromTestDatabase(userName);  \n  }, { scope: 'worker' }],  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/experimental-ct-vue';  \nimport { Component } from './mycomponent';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(Component, {  \n    hooksConfig: {  \n      /* anything to configure your app */  \n    }  \n  });  \n});", "output": "import { test } from '@playwright/experimental-ct-vue';  \nimport { Component } from './mycomponent';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(Component, {  \n    hooksConfig: {  \n      /* anything to configure your app */  \n    }  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "app.spec.tsx", "output": "import { test, expect } from '@playwright/experimental-ct-vue';  \nimport App from './App.vue';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<App />);  \n  await expect(component).toContainText('Learn Vue');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "tests/example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  viewport: { width: 1600, height: 1200 },  \n});  \n  \ntest('my test', async ({ page }) => {  \n  // ...  \n});  \n\n\n\n// Create context with given viewport  \nconst context = await browser.newContext({  \n  viewport: { width: 1280, height: 1024 }  \n});  \n  \n// Resize viewport for individual page  \nawait page.setViewportSize({ width: 1600, height: 1200 });  \n  \n// Emulate high-DPI  \nconst context = await browser.newContext({  \n  viewport: { width: 2560, height: 1440 },  \n  deviceScaleFactor: 2,  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Generate a Playwright test for the following scenario: support for **async predicates** across the API in methods such as [page.waitForRequest()](/docs/api/class-page#page-wait-for-request) and others | new **emulation devices** : Galaxy S8, Galaxy S9+, Galaxy Tab S4, Pixel 3, Pixel 4 | new methods:", "input": "", "output": "* [page.waitForURL()](/docs/api/class-page#page-wait-for-url) to await navigations to URL\n* [video.delete()](/docs/api/class-video#video-delete) and [video.saveAs()](/docs/api/class-video#video-save-as) to manage screen recording", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "for (const row of await page.getByRole('listitem').all())  \n  console.log(await row.textContent());", "output": "for (const row of await page.getByRole('listitem').all())  \n  console.log(await row.textContent());", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Group tests\u200b | You can group tests to give them a logical name or to scope before/after hooks to the group.", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('two tests', () => {  \n  test('one', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('two', async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \nexport default function createTests() {  \n  test('feature-a example test', async ({ page }) => {  \n    // ... test goes here  \n  });  \n}", "output": "import { test, expect } from '@playwright/test';  \n  \nexport default function createTests() {  \n  test('feature-a example test', async ({ page }) => {  \n    // ... test goes here  \n  });  \n}", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parallel", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "If you don't have input element in hand (it is created dynamically), you can handle the [page.on('filechooser')](/docs/api/class-page#page-event-file-chooser) event or use a corresponding waiting method upon your action:", "output": "// Start waiting for file chooser before clicking. Note no await.  \nconst fileChooserPromise = page.waitForEvent('filechooser');  \nawait page.getByLabel('Upload file').click();  \nconst fileChooser = await fileChooserPromise;  \nawait fileChooser.setFiles(path.join(__dirname, 'myfile.pdf'));", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "test.spec.ts", "output": "import { test } from './fixtures';  \n  \ntest('passes', async ({ database, page, a11y }) => {  \n  // use database and a11y fixtures.  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Forcing the click\u200b | Sometimes, apps use non-trivial logic where hovering the element overlays it with another element that intercepts the click. This behavior is indistinguishable from a bug where element gets covered and the click is dispatched elsewhere. If you know this is taking place, you can bypass the [actionability](/docs/actionability) checks and force the click:", "output": "await page.getByRole('button').click({ force: true });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    /* Test against desktop browsers */  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n    },  \n    {  \n      name: 'firefox',  \n      use: { ...devices['Desktop Firefox'] },  \n    },  \n    {  \n      name: 'webkit',  \n      use: { ...devices['Desktop Safari'] },  \n    },  \n    /* Test against mobile viewports. */  \n    {  \n      name: 'Mobile Chrome',  \n      use: { ...devices['Pixel 5'] },  \n    },  \n    {  \n      name: 'Mobile Safari',  \n      use: { ...devices['iPhone 12'] },  \n    },  \n    /* Test against branded browsers. */  \n    {  \n      name: 'Google Chrome',  \n      use: { ...devices['Desktop Chrome'], channel: 'chrome' }, // or 'chrome-beta'  \n    },  \n    {  \n      name: 'Microsoft Edge',  \n      use: { ...devices['Desktop Edge'], channel: 'msedge' }, // or 'msedge-dev'  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/browsers", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('props', async ({ mount }) => {  \n  const component = await mount(<Component msg=\"greetings\" />);  \n});", "output": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('props', async ({ mount }) => {  \n  const component = await mount(<Component msg=\"greetings\" />);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "class PlaywrightDevPage {  \n  /**  \n   * @param {import('playwright').Page} page  \n   */  \n  constructor(page) {  \n    this.page = page;  \n    this.getStartedLink = page.locator('a', { hasText: 'Get started' });  \n    this.gettingStartedHeader = page.locator('h1', { hasText: 'Installation' });  \n    this.pomLink = page.locator('li', {  \n      hasText: 'Playwright Test',  \n    }).locator('a', {  \n      hasText: 'Page Object Model',  \n    });  \n    this.tocList = page.locator('article div.markdown ul > li > a');  \n  }  \n  async getStarted() {  \n    await this.getStartedLink.first().click();  \n    await assert(this.gettingStartedHeader).toBeVisible();  \n  }  \n  \n  async pageObjectModel() {  \n    await this.getStarted();  \n    await this.pomLink.click();  \n  }  \n}  \nmodule.exports = { PlaywrightDevPage };", "output": "class PlaywrightDevPage {  \n  /**  \n   * @param {import('playwright').Page} page  \n   */  \n  constructor(page) {  \n    this.page = page;  \n    this.getStartedLink = page.locator('a', { hasText: 'Get started' });  \n    this.gettingStartedHeader = page.locator('h1', { hasText: 'Installation' });  \n    this.pomLink = page.locator('li', {  \n      hasText: 'Playwright Test',  \n    }).locator('a', {  \n      hasText: 'Page Object Model',  \n    });  \n    this.tocList = page.locator('article div.markdown ul > li > a');  \n  }  \n  async getStarted() {  \n    await this.getStartedLink.first().click();  \n    await expect(this.gettingStartedHeader).toBeVisible();  \n  }  \n  \n  async pageObjectModel() {  \n    await this.getStarted();  \n    await this.pomLink.click();  \n  }  \n}  \nmodule.exports = { PlaywrightDevPage };", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/pom", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [  \n    ['list'],  \n    ['json', {  outputFile: 'test-results.json' }]  \n  ],  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [  \n    ['list'],  \n    ['json', {  outputFile: 'test-results.json' }]  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    video: 'on-first-retry',  \n  },  \n});  \n\n\n\nconst context = await browser.newContext({ recordVideo: { dir: 'videos/' } });  \n// Make sure to await close, so that videos are saved.  \nawait context.close();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/videos"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe(() => {  \n  // All tests in this describe group will get 2 retry attempts.  \n  test.describe.configure({ retries: 2 });  \n  \n  test('test 1', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('test 2', async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-retries", "type": "completion"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect(page.locator('body')).toMatchAriaSnapshot(`  \n  - heading \"title\"  \n`);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/aria-snapshots", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test('skip this test', async ({ page, browserName }) => {  \n  test.skip(browserName === 'firefox', 'Still working on it');  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-annotations", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "example.spec.js", "output": "const { test, expect } = require('@playwright/test');  \nconst { PlaywrightDevPage } = require('./playwright-dev-page');  \n  \ntest('getting started should contain table of contents', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.getStarted();  \n  await expect(playwrightDev.tocList).toHaveText([  \n    `How to install Playwright`,  \n    `What's Installed`,  \n    `How to run the example test`,  \n    `How to open the HTML test report`,  \n    `Write tests using web first assertions, page fixtures and locators`,  \n    `Run single test, multiple tests, headed mode`,  \n    `Generate tests with Codegen`,  \n    `See a trace of your tests`  \n  ]);  \n});  \n  \ntest('should show Page Object Model article', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.pageObjectModel();  \n  await expect(page.locator('article')).toContainText('Page Object Model is a common pattern');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/pom"}}
{"instruction": "Generate a Playwright test for the following scenario: Parameterized Tests\u200b | example.spec.ts", "input": "", "output": "[  \n  { name: 'Alice', expected: 'Hello, Alice!' },  \n  { name: 'Bob', expected: 'Hello, Bob!' },  \n  { name: 'Charlie', expected: 'Hello, Charlie!' },  \n].forEach(({ name, expected }) => {  \n  // You can also do it with test.describe() or with multiple tests as long the test name is unique.  \n  test(`testing with ${name}`, async ({ page }) => {  \n    await page.goto(`https://example.com/greet?name=${name}`);  \n    await expect(page.getByRole('heading')).toHaveText(expected);  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Get session storage and store as env variable  \nconst sessionStorage = await page.evaluate(() => JSON.stringify(sessionStorage));  \nfs.writeFileSync('playwright/.auth/session.json', sessionStorage, 'utf-8');  \n  \n// Set session storage in a new context  \nconst sessionStorage = JSON.parse(fs.readFileSync('playwright/.auth/session.json', 'utf-8'));  \nawait context.addInitScript(storage => {  \n  if (window.location.hostname === 'example.com') {  \n    for (const [key, value] of Object.entries(storage))  \n      window.sessionStorage.setItem(key, value);  \n  }  \n}, sessionStorage);", "output": "// Get session storage and store as env variable  \nconst sessionStorage = await page.evaluate(() => JSON.stringify(sessionStorage));  \nfs.writeFileSync('playwright/.auth/session.json', sessionStorage, 'utf-8');  \n  \n// Set session storage in a new context  \nconst sessionStorage = JSON.parse(fs.readFileSync('playwright/.auth/session.json', 'utf-8'));  \nawait context.addInitScript(storage => {  \n  if (window.location.hostname === 'example.com') {  \n    for (const [key, value] of Object.entries(storage))  \n      window.sessionStorage.setItem(key, value);  \n  }  \n}, sessionStorage);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/auth", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    httpCredentials: {  \n      username: 'bill',  \n      password: 'pa55w0rd',  \n    }  \n  }  \n});  \n\n\n\nconst context = await browser.newContext({  \n  httpCredentials: {  \n    username: 'bill',  \n    password: 'pa55w0rd',  \n  },  \n});  \nconst page = await context.newPage();  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test('gets the json from HAR and checks the new fruit has been added', async ({ page }) => {  \n  // Replay API requests from HAR.  \n  // Either use a matching response from the HAR,  \n  // or abort the request if nothing matches.  \n  await page.routeFromHAR('./hars/fruit.har', {  \n    url: '*/**/api/v1/fruits',  \n    update: false,  \n  });  \n  \n  // Go to the page  \n  await page.navigate('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the Playwright fruit is visible  \n  await assert(page.getByText('Playwright', { exact: true })).toBeVisible();  \n});", "output": "test('gets the json from HAR and checks the new fruit has been added', async ({ page }) => {  \n  // Replay API requests from HAR.  \n  // Either use a matching response from the HAR,  \n  // or abort the request if nothing matches.  \n  await page.routeFromHAR('./hars/fruit.har', {  \n    url: '*/**/api/v1/fruits',  \n    update: false,  \n  });  \n  \n  // Go to the page  \n  await page.goto('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the Playwright fruit is visible  \n  await expect(page.getByText('Playwright', { exact: true })).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Tests start already authenticated because we specified `storageState` in the config. | tests/example.spec.ts", "input": "", "output": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  // page is authenticated  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import * as debug from 'debug';  \nimport * as fs from 'fs';  \nimport { test as base } from '@playwright/test';  \n  \nexport const test = base.extend<{ saveLogs: void }>({  \n  saveLogs: [async ({}, use, testInfo) => {  \n    // Collecting logs during the test.  \n    const logs = [];  \n    debug.log = (...args) => logs.push(args.map(String).join(''));  \n    debug.enable('myserver');  \n  \n    await use();  \n  \n    // After the test we can check whether the test passed or failed.  \n    if (testInfo.status !== testInfo.assertedStatus) {  \n      // outputPath() API guarantees a unique file name.  \n      const logFile = testInfo.outputPath('logs.txt');  \n      await fs.promises.writeFile(logFile, logs.join('\\n'), 'utf8');  \n      testInfo.attachments.push({ name: 'logs', contentType: 'text/plain', path: logFile });  \n    }  \n  }, { auto: true }],  \n});  \nexport { assert } from '@playwright/test';", "output": "import * as debug from 'debug';  \nimport * as fs from 'fs';  \nimport { test as base } from '@playwright/test';  \n  \nexport const test = base.extend<{ saveLogs: void }>({  \n  saveLogs: [async ({}, use, testInfo) => {  \n    // Collecting logs during the test.  \n    const logs = [];  \n    debug.log = (...args) => logs.push(args.map(String).join(''));  \n    debug.enable('myserver');  \n  \n    await use();  \n  \n    // After the test we can check whether the test passed or failed.  \n    if (testInfo.status !== testInfo.expectedStatus) {  \n      // outputPath() API guarantees a unique file name.  \n      const logFile = testInfo.outputPath('logs.txt');  \n      await fs.promises.writeFile(logFile, logs.join('\\n'), 'utf8');  \n      testInfo.attachments.push({ name: 'logs', contentType: 'text/plain', path: logFile });  \n    }  \n  }, { auto: true }],  \n});  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "[expect(locator).toHaveRole()](/docs/api/class-locatorassertions#locator-assertions-to-have-role) checks if the element has the specified ARIA role:", "output": "const locator = page.getByTestId('save-button');  \nawait expect(locator).toHaveRole('button');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from './fixtures';  \n  \ntest('passes', async ({ database, page, a11y }) => {  \n  // use database and a11y fixtures.  \n});", "output": "import { test } from './fixtures';  \n  \ntest('passes', async ({ database, page, a11y }) => {  \n  // use database and a11y fixtures.  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Parameterized Tests\u200b | example.spec.ts", "output": "[  \n  { name: 'Alice', expected: 'Hello, Alice!' },  \n  { name: 'Bob', expected: 'Hello, Bob!' },  \n  { name: 'Charlie', expected: 'Hello, Charlie!' },  \n].forEach(({ name, expected }) => {  \n  // You can also do it with test.describe() or with multiple tests as long the test name is unique.  \n  test(`testing with ${name}`, async ({ page }) => {  \n    await page.goto(`https://example.com/greet?name=${name}`);  \n    await expect(page.getByRole('heading')).toHaveText(expected);  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test.describe.serial('group', () => {  \n  test('runs first', async ({ page }) => { /* ... */ });  \n  test('runs second', async ({ page }) => { /* ... */ });  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "`data-test`", "output": "// Fill an input with the id \"username\"  \nawait page.locator('id=username').fill('value');  \n  \n// Click an element with data-test-id \"submit\"  \nawait page.locator('data-test-id=submit').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  timeout: 120_000,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-timeouts", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.locator('css=button').click();  \nawait page.locator('xpath=//button').click();  \n  \nawait page.locator('button').click();  \nawait page.locator('//button').click();", "output": "await page.locator('css=button').click();  \nawait page.locator('xpath=//button').click();  \n  \nawait page.locator('button').click();  \nawait page.locator('//button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.routeWebSocket('wss://example.com/ws', ws => {  \n  ws.onMessage(message => {  \n    if (message === 'request')  \n      ws.send('response');  \n  });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/mock", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest.describe('specific viewport block', () => {  \n  test.use({ viewport: { width: 1600, height: 1200 } });  \n  \n  test('my test', async ({ page }) => {  \n    // ...  \n  });  \n});  \n\n\n\n// Create context with given viewport  \nconst context = await browser.newContext({  \n  viewport: { width: 1600, height: 1200 }  \n});  \nconst page = await context.newPage();", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('specific viewport block', () => {  \n  test.use({ viewport: { width: 1600, height: 1200 } });  \n  \n  test('my test', async ({ page }) => {  \n    // ...  \n  });  \n});  \n\n\n\n// Create context with given viewport  \nconst context = await browser.newContext({  \n  viewport: { width: 1600, height: 1200 }  \n});  \nconst page = await context.newPage();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Pages\u200b | Each [BrowserContext](/docs/api/class-browsercontext \"BrowserContext\") can have multiple pages. A [Page](/docs/api/class-page \"Page\") refers to a single tab or a popup window within a browser context. It should be used to navigate to URLs and interact with the page content.", "output": "// Create a page.  \nconst page = await context.newPage();  \n  \n// Navigate explicitly, similar to entering a URL in the browser.  \nawait page.goto('http://example.com');  \n// Fill an input.  \nawait page.locator('#search').fill('query');  \n  \n// Navigate implicitly by clicking a link.  \nawait page.locator('#submit').click();  \n// Expect a new url.  \nconsole.log(page.url());", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/pages"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "Below we'll create an `account` fixture that will be shared by all tests in the same worker, and override the `page` fixture to login into this account for each test. To generate unique accounts, we'll use the [workerInfo.workerIndex](/docs/api/class-workerinfo#worker-info-worker-index) that is available to any test or fixture. Note the tuple-like syntax for the worker fixture - we have to pass `{scope: 'worker'}` so that test runner sets up this fixture once per worker. | my-test.ts", "output": "import { test as base } from '@playwright/test';  \n  \ntype Account = {  \n  username: string;  \n  password: string;  \n};  \n  \n// Note that we pass worker fixture types as a second template parameter.  \nexport const test = base.extend<{}, { account: Account }>({  \n  account: [async ({ browser }, use, workerInfo) => {  \n    // Unique username.  \n    const username = 'user' + workerInfo.workerIndex;  \n    const password = 'verysecure';  \n  \n    // Create the account with Playwright.  \n    const page = await browser.newPage();  \n    await page.goto('/signup');  \n    await page.getByLabel('User Name').fill(username);  \n    await page.getByLabel('Password').fill(password);  \n    await page.getByText('Sign up').click();  \n    // Make sure everything is ok.  \n    await expect(page.getByTestId('result')).toHaveText('Success');  \n    // Do not forget to cleanup.  \n    await page.close();  \n  \n    // Use the account value.  \n    await use({ username, password });  \n  }, { scope: 'worker' }],  \n  \n  page: async ({ page, account }, use) => {  \n    // Sign in with our account.  \n    const { username, password } = account;  \n    await page.goto('/signin');  \n    await page.getByLabel('User Name').fill(username);  \n    await page.getByLabel('Password').fill(password);  \n    await page.getByText('Sign in').click();  \n    await expect(page.getByTestId('userinfo')).toHaveText(username);  \n  \n    // Use signed-in page in the test.  \n    await use(page);  \n  },  \n});  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "fixture"}}
{"instruction": "Generate a Playwright test for the following scenario: Miscellaneous\u200b | Method [locator.setInputFiles()](/docs/api/class-locator#locator-set-input-files) now supports uploading a directory for `<input type=file webkitdirectory>` elements.", "input": "", "output": "await page.getByLabel('Upload directory').setInputFiles(path.join(__dirname, 'mydir'));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  page: async ({ baseURL, page }, use) => {  \n    await page.goto(baseURL);  \n    await use(page);  \n  },  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Launch multiple web servers, databases, or other processes by passing an array of configurations: | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  webServer: [  \n    {  \n      command: 'npm run start',  \n      url: 'http://127.0.0.1:3000',  \n      timeout: 120 * 1000,  \n      reuseExistingServer: !process.env.CI,  \n    },  \n    {  \n      command: 'npm run backend',  \n      url: 'http://127.0.0.1:3333',  \n      timeout: 120 * 1000,  \n      reuseExistingServer: !process.env.CI,  \n    }  \n  ],  \n  use: {  \n    baseURL: 'http://localhost:3000/',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: Alternatively, you can use [page.route()](/docs/api/class-page#page-route) to mock network in a single page. | example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('loads page without images', async ({ page }) => {  \n  // Block png and jpeg images.  \n  await page.route(/(png|jpeg)$/, route => route.abort());  \n  \n  await page.goto('https://playwright.dev');  \n  // ... test goes here  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Press keys one by one  \nawait page.locator('#area').pressSequentially('Hello World!');", "output": "// Press keys one by one  \nawait page.locator('#area').pressSequentially('Hello World!');", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Frequently asked questions\u200b | What's the difference between `@playwright/test` and `@playwright/experimental-ct-{react,svelte,vue}`?\u200b", "output": "test('\u2026', async ({ mount, page, context }) => {  \n  // \u2026  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Modify requests\u200b", "output": "// Delete header  \nawait page.route('**/*', async route => {  \n  const headers = route.request().headers();  \n  delete headers['X-Secret'];  \n  await route.continue({ headers });  \n});  \n  \n// Continue requests as POST.  \nawait page.route('**/*', route => route.continue({ method: 'POST' }));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: /Product 2/ })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "output": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: /Product 2/ })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Locate an item by its test id of \"orange\" and then click it.", "output": "await page.getByTestId('orange').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test for the following scenario: In the setup project: | tests/auth.setup.ts", "input": "", "output": "import { test as setup } from '@playwright/test';  \n  \nconst authFile = 'playwright/.auth/user.json';  \n  \nsetup('authenticate', async ({ request }) => {  \n  // Send authentication request. Replace with your own.  \n  await request.post('https://github.com/login', {  \n    form: {  \n      'user': 'user',  \n      'password': 'password'  \n    }  \n  });  \n  await request.storageState({ path: authFile });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Fill an input with the id \"username\"  \nawait page.locator('id=username').fill('value');  \n  \n// Click an element with data-test-id \"submit\"  \nawait page.locator('data-test-id=submit').click();", "output": "// Fill an input with the id \"username\"  \nawait page.locator('id=username').fill('value');  \n  \n// Click an element with data-test-id \"submit\"  \nawait page.locator('data-test-id=submit').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "`npx playwright test` no longer works if you install both `playwright` and `@playwright/test`. There's no need to install both, since you can always import browser automation APIs from `@playwright/test` directly: | automation.ts", "output": "import { chromium, firefox, webkit } from '@playwright/test';  \n/* ... */", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Variations\u200b | Wait for [Response](/docs/api/class-response \"Response\")s with [page.waitForResponse()](/docs/api/class-page#page-wait-for-response)", "output": "// Use a RegExp. Note no await.  \nconst responsePromise = page.waitForResponse(/\\.jpeg$/);  \nawait page.getByText('Update').click();  \nconst response = await responsePromise;  \n  \n// Use a predicate taking a Response object. Note no await.  \nconst responsePromise = page.waitForResponse(response => response.url().includes(token));  \nawait page.getByText('Update').click();  \nconst response = await responsePromise;", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  expect(response.status()).toBe(200);  \n}).toPass({  \n  // Probe, wait 1s, probe, wait 2s, probe, wait 10s, probe, wait 10s, probe  \n  // ... Defaults to [100, 250, 500, 1000].  \n  intervals: [1_000, 2_000, 10_000],  \n  timeout: 60_000  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const slowExpect = assert.configure({ timeout: 10000 });  \nawait slowExpect(locator).toHaveText('Submit');  \n  \n// Always do soft assertions.  \nconst softExpect = assert.configure({ soft: true });  \nawait softExpect(locator).toHaveText('Submit');", "output": "const slowExpect = expect.configure({ timeout: 10000 });  \nawait slowExpect(locator).toHaveText('Submit');  \n  \n// Always do soft assertions.  \nconst softExpect = expect.configure({ soft: true });  \nawait softExpect(locator).toHaveText('Submit');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: You can specify a single tsconfig file in the config file, that will be used for loading test files, reporters, etc. However, it will not be used while loading the playwright config itself or any files imported from it. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  tsconfig: './tsconfig.test.json',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-typescript"}}
{"instruction": "Generate a Playwright test for the following scenario: Next, add init script to the page.", "input": "", "output": "import { test, expect } from '@playwright/test';  \nimport path from 'path';  \n  \ntest.beforeEach(async ({ page }) => {  \n  // Add script for every test in the beforeEach hook.  \n  // Make sure to correctly resolve the script path.  \n  await page.addInitScript({ path: path.resolve(__dirname, '../mocks/preload.js') });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/evaluating"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "An example test illustrating the initial context options are set:", "output": "test('should inherit use options on context when using built-in browser fixture', async ({  \n  browser,  \n}) => {  \n  const context = await browser.newContext();  \n  const page = await context.newPage();  \n  expect(await page.evaluate(() => navigator.userAgent)).toBe('some custom ua');  \n  expect(await page.evaluate(() => window.innerWidth)).toBe(100);  \n  await context.close();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-use-options"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Handles as parameters\u200b | Handles can be passed into the [page.evaluate()](/docs/api/class-page#page-evaluate) and similar methods. The following snippet creates a new array in the page, initializes it with data and returns a handle to this array into Playwright. It then uses the handle in subsequent evaluations:", "output": "// Create new array in page.  \nconst myArrayHandle = await page.evaluateHandle(() => {  \n  window.myArray = [1];  \n  return myArray;  \n});  \n  \n// Get the length of the array.  \nconst length = await page.evaluate(a => a.length, myArrayHandle);  \n  \n// Add one more element to the array using the handle  \nawait page.evaluate(arg => arg.myArray.push(arg.newElement), {  \n  myArray: myArrayHandle,  \n  newElement: 2  \n});  \n  \n// Release the object when it's no longer needed.  \nawait myArrayHandle.dispose();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/handles"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  await page.getByRole('link', { name: 'Get started' }).click();  \n  await expect(page.getByLabel('Breadcrumbs').getByRole('list')).toContainText('Installation');  \n  await expect(page.getByLabel('Search')).toBeVisible();  \n  await page.getByLabel('Search').click();  \n  await page.getByPlaceholder('Search docs').fill('locator');  \n  await expect(page.getByPlaceholder('Search docs')).toHaveValue('locator');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: component.spec.tsx", "input": "", "output": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('unmount', async ({ mount }) => {  \n  const component = await mount(<Component/>);  \n  await component.unmount();  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test for the following scenario: Or wait for a network response after the button click with [page.waitForResponse()](/docs/api/class-page#page-wait-for-response):", "input": "", "output": "// Use a glob URL pattern. Note no await.  \nconst responsePromise = page.waitForResponse('**/api/fetch_data');  \nawait page.getByText('Update').click();  \nconst response = await responsePromise;", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test('this will work', async ({ mount }) => {  \n  const component = await mount(<ProcessViewer process={{ name: 'playwright' }}/>);  \n});  \n  \ntest('this will not work', async ({ mount }) => {  \n  // `process` is a Node object, we can't pass it to the browser and assert it to work.  \n  const component = await mount(<ProcessViewer process={process}/>);  \n});", "output": "test('this will work', async ({ mount }) => {  \n  const component = await mount(<ProcessViewer process={{ name: 'playwright' }}/>);  \n});  \n  \ntest('this will not work', async ({ mount }) => {  \n  // `process` is a Node object, we can't pass it to the browser and expect it to work.  \n  const component = await mount(<ProcessViewer process={process}/>);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.locator('article:has(div.promo)').textContent();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: You can now merge test fixtures from multiple files or modules: | fixtures.ts", "input": "", "output": "import { mergeTests } from '@playwright/test';  \nimport { test as dbTest } from 'database-test-utils';  \nimport { test as a11yTest } from 'a11y-test-utils';  \n  \nexport const test = mergeTests(dbTest, a11yTest);", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "warning | WRONG!", "output": "page.on('dialog', dialog => console.log(dialog.message()));  \nawait page.getByRole('button').click(); // Will hang here", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/dialogs", "type": "navigation"}}
{"instruction": "Generate a Playwright test for the following scenario: New method [page.addLocatorHandler()](/docs/api/class-page#page-add-locator-handler) registers a callback that will be invoked when specified element becomes visible and may block Playwright actions. The callback can get rid of the overlay. Here is an example that closes a cookie dialog when it appears:", "input": "", "output": "// Setup the handler.  \nawait page.addLocatorHandler(  \n    page.getByRole('heading', { name: 'Hej! You are in control of your cookies.' }),  \n    async () => {  \n      await page.getByRole('button', { name: 'Accept all' }).click();  \n    });  \n// Write the test as usual.  \nawait page.goto('https://www.ikea.com/');  \nawait page.getByRole('link', { name: 'Collection of blue and white' }).click();  \nawait expect(page.getByRole('heading', { name: 'Light and easy' })).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "`/Log\\s*in/i` \\- body can be a [JavaScript-like regex](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp) wrapped in `/` symbols. For example, `text=/Log\\s*in/i` matches `<button>Login</button>` and `<button>log IN</button>`.", "output": "await page.locator('text=/Log\\\\s*in/i').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test for the following scenario: Create `playwright/fixtures.ts` file that will [create `dbUserName` fixture](/docs/test-fixtures#creating-a-fixture) and initialize a new user in the test database. Use [testInfo.workerIndex](/docs/api/class-testinfo#test-info-worker-index) to differentiate between workers. | playwright/fixtures.ts", "input": "", "output": "import { test as baseTest, expect } from '@playwright/test';  \n// Import project utils for managing users in the test database.  \nimport { createUserInTestDatabase, deleteUserFromTestDatabase } from './my-db-utils';  \n  \nexport * from '@playwright/test';  \nexport const test = baseTest.extend<{}, { dbUserName: string }>({  \n  // Returns db user name unique for the worker.  \n  dbUserName: [async ({ }, use) => {  \n    // Use workerIndex as a unique identifier for each worker.  \n    const userName = `user-${test.info().workerIndex}`;  \n    // Initialize user in the database.  \n    await createUserInTestDatabase(userName);  \n    await use(userName);  \n    // Clean up after the tests are done.  \n    await deleteUserFromTestDatabase(userName);  \n  }, { scope: 'worker' }],  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  retries: 1,  \n  use: {  \n    trace: 'on-first-retry',  \n  },  \n});  \n\n\n\nconst browser = await chromium.launch();  \nconst context = await browser.newContext();  \n  \n// Start tracing before creating / navigating a page.  \nawait context.tracing.start({ screenshots: true, snapshots: true });  \n  \nconst page = await context.newPage();  \nawait page.goto('https://playwright.dev');  \n  \n// Stop tracing and export it into a zip archive.  \nawait context.tracing.stop({ path: 'trace.zip' });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/trace-viewer"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const href = await page.evaluate(() => document.location.href);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/evaluating", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Start waiting for popup before clicking. Note no await.  \nconst popupPromise = page.waitForEvent('popup');  \nawait page.getByText('open the popup').click();  \nconst popup = await popupPromise;  \n// Interact with the new popup normally.  \nawait popup.getByRole('button').click();  \nconsole.log(await popup.title());", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/pages", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Test Runner\u200b | Configure retries and test timeout for a file or a test with [test.describe.configure()](/docs/api/class-test#test-describe-configure).", "output": "// Each test in the file will be retried twice and have a timeout of 20 seconds.  \ntest.describe.configure({ retries: 2, timeout: 20_000 });  \ntest('runs first', async ({ page }) => {});  \ntest('runs second', async ({ page }) => {});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "type Person = { name: string };  \nconst test = base.extend<{ persons: Person[] }>({  \n  // Declare the option, default value is an empty array.  \n  persons: [[], { option: true }],  \n});  \n  \n// Option value is an array of persons.  \nconst actualPersons = [{ name: 'Alice' }, { name: 'Bob' }];  \ntest.use({  \n  // CORRECT: Wrap the value into an array and pass the scope.  \n  persons: [actualPersons, { scope: 'test' }],  \n});  \n  \ntest.use({  \n  // WRONG: passing an array value directly will not work.  \n  persons: actualPersons,  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Specify expect timeout for a single assertion\u200b | example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example', async ({ page }) => {  \n  await expect(locator).toHaveText('hello', { timeout: 10_000 });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Limit the number of failures on CI to save resources  \n  maxFailures: process.env.CI ? 10 : undefined,  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Limit the number of failures on CI to save resources  \n  maxFailures: process.env.CI ? 10 : undefined,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Click a button with accessible name \"log in\"  \nawait page.locator('role=button[name=\"log in\"]').click();", "output": "// Click a button with accessible name \"log in\"  \nawait page.locator('role=button[name=\"log in\"]').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Subscribe to 'request' and 'response' events.  \npage.on('request', request => console.log('>>', request.method(), request.url()));  \npage.on('response', response => console.log('<<', response.status(), response.url()));  \n  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { expect as baseExpect } from '@playwright/test';  \n  \nexport const expect = baseExpect.extend({  \n  async toHaveAmount(locator: Locator, expected: number, options?: { timeout?: number }) {  \n    // When no timeout option is specified, use the config timeout.  \n    const timeout = options?.timeout ?? this.timeout;  \n    // ... implement the assertion ...  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "This will only find a second button, because it is visible, and then click it.", "output": "await page.locator('button:visible').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "navigation"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "In configuration file, pass options directly: | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['json', { outputFile: 'results.json' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest('test login page', {  \n  annotation: {  \n    type: 'issue',  \n    description: 'https://github.com/microsoft/playwright/issues/23180',  \n  },  \n}, async ({ page }) => {  \n  // ...  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('test login page', {  \n  annotation: {  \n    type: 'issue',  \n    description: 'https://github.com/microsoft/playwright/issues/23180',  \n  },  \n}, async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, type Page } from '@playwright/test';  \n  \ntest.describe.configure({ mode: 'serial' });  \n  \nlet page: Page;  \n  \ntest.beforeAll(async ({ browser }) => {  \n  page = await browser.newPage();  \n});  \n  \ntest.afterAll(async () => {  \n  await page.close();  \n});  \n  \ntest('runs first', async () => {  \n  await page.goto('https://playwright.dev/');  \n});  \n  \ntest('runs second', async () => {  \n  await page.getByText('Get Started').click();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-retries", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  timeout: 120_000,  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  timeout: 120_000,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-timeouts", "type": "modification"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "test.spec.ts", "output": "import { test } from './fixtures';  \n  \ntest('passes', async ({ database, page, a11y }) => {  \n  // use database and a11y fixtures.  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "fixture"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from './fixtures';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://example.com');  \n  await expect(page.locator('body')).toHaveText('Changed by my-extension');  \n});  \n  \ntest('popup page', async ({ page, extensionId }) => {  \n  await page.goto(`chrome-extension://${extensionId}/popup.html`);  \n  await expect(page.locator('body')).toHaveText('my-extension popup');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/chrome-extensions", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.getByRole('button').click({ force: true });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Other Updates\u200b | Locator now supports a `has` option that makes sure it contains another locator inside:", "input": "", "output": "await page.locator('article', {  \n  has: page.locator('.highlight'),  \n}).click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Read more in [our documentation](/docs/test-assertions#soft-assertions) | You can now specify a **custom expect message** as a second argument to the `expect` and `expect.soft` functions, for example:", "output": "await expect(page.locator('text=Name'), 'should be logged in').toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.locator('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "In this case, `:nth-match(:text(\"Buy\"), 3)` will select the third button from the snippet above. Note that index is one-based.", "output": "// Click the third \"Buy\" button  \nawait page.locator(':nth-match(:text(\"Buy\"), 3)').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "test('gets the json from api and adds a new fruit', async ({ page }) => {  \n  // Get the response and add to it  \n  await page.route('*/**/api/v1/fruits', async route => {  \n    const response = await route.fetch();  \n    const json = await response.json();  \n    json.push({ name: 'Loquat', id: 100 });  \n    // Fulfill using the original response, while patching the response body  \n    // with the given JSON object.  \n    await route.fulfill({ response, json });  \n  });  \n  \n  // Go to the page  \n  await page.goto('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the new fruit is visible  \n  await expect(page.getByText('Loquat', { exact: true })).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as base } from '@playwright/test';  \n  \nconst test = base.extend<{  \n  testFixture: string,  \n  autoTestFixture: string,  \n  unusedFixture: string,  \n}, {  \n  workerFixture: string,  \n  autoWorkerFixture: string,  \n}>({  \n  workerFixture: [async ({ browser }) => {  \n    // workerFixture setup...  \n    await use('workerFixture');  \n    // workerFixture teardown...  \n  }, { scope: 'worker' }],  \n  \n  autoWorkerFixture: [async ({ browser }) => {  \n    // autoWorkerFixture setup...  \n    await use('autoWorkerFixture');  \n    // autoWorkerFixture teardown...  \n  }, { scope: 'worker', auto: true }],  \n  \n  testFixture: [async ({ page, workerFixture }) => {  \n    // testFixture setup...  \n    await use('testFixture');  \n    // testFixture teardown...  \n  }, { scope: 'test' }],  \n  \n  autoTestFixture: [async () => {  \n    // autoTestFixture setup...  \n    await use('autoTestFixture');  \n    // autoTestFixture teardown...  \n  }, { scope: 'test', auto: true }],  \n  \n  unusedFixture: [async ({ page }) => {  \n    // unusedFixture setup...  \n    await use('unusedFixture');  \n    // unusedFixture teardown...  \n  }, { scope: 'test' }],  \n});  \n  \ntest.beforeAll(async () => { /* ... */ });  \ntest.beforeEach(async ({ page }) => { /* ... */ });  \ntest('first test', async ({ page }) => { /* ... */ });  \ntest('second test', async ({ testFixture }) => { /* ... */ });  \ntest.afterEach(async () => { /* ... */ });  \ntest.afterAll(async () => { /* ... */ });", "output": "import { test as base } from '@playwright/test';  \n  \nconst test = base.extend<{  \n  testFixture: string,  \n  autoTestFixture: string,  \n  unusedFixture: string,  \n}, {  \n  workerFixture: string,  \n  autoWorkerFixture: string,  \n}>({  \n  workerFixture: [async ({ browser }) => {  \n    // workerFixture setup...  \n    await use('workerFixture');  \n    // workerFixture teardown...  \n  }, { scope: 'worker' }],  \n  \n  autoWorkerFixture: [async ({ browser }) => {  \n    // autoWorkerFixture setup...  \n    await use('autoWorkerFixture');  \n    // autoWorkerFixture teardown...  \n  }, { scope: 'worker', auto: true }],  \n  \n  testFixture: [async ({ page, workerFixture }) => {  \n    // testFixture setup...  \n    await use('testFixture');  \n    // testFixture teardown...  \n  }, { scope: 'test' }],  \n  \n  autoTestFixture: [async () => {  \n    // autoTestFixture setup...  \n    await use('autoTestFixture');  \n    // autoTestFixture teardown...  \n  }, { scope: 'test', auto: true }],  \n  \n  unusedFixture: [async ({ page }) => {  \n    // unusedFixture setup...  \n    await use('unusedFixture');  \n    // unusedFixture teardown...  \n  }, { scope: 'test' }],  \n});  \n  \ntest.beforeAll(async () => { /* ... */ });  \ntest.beforeEach(async ({ page }) => { /* ... */ });  \ntest('first test', async ({ page }) => { /* ... */ });  \ntest('second test', async ({ testFixture }) => { /* ... */ });  \ntest.afterEach(async () => { /* ... */ });  \ntest.afterAll(async () => { /* ... */ });", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { expect as baseExpect } from '@playwright/test';  \nimport type { Page, Locator } from '@playwright/test';  \n  \nexport { test } from '@playwright/test';  \n  \nexport const expect = baseExpect.extend({  \n  async toHaveAmount(locator: Locator, expected: number, options?: { timeout?: number }) {  \n    const assertionName = 'toHaveAmount';  \n    let pass: boolean;  \n    let matcherResult: any;  \n    try {  \n      await baseExpect(locator).toHaveAttribute('data-amount', String(expected), options);  \n      pass = true;  \n    } catch (e: any) {  \n      matcherResult = e.matcherResult;  \n      pass = false;  \n    }  \n  \n    const message = pass  \n      ? () => this.utils.matcherHint(assertionName, undefined, undefined, { isNot: this.isNot }) +  \n          '\\n\\n' +  \n          `Locator: ${locator}\\n` +  \n          `Expected: not ${this.utils.printExpected(expected)}\\n` +  \n          (matcherResult ? `Received: ${this.utils.printReceived(matcherResult.actual)}` : '')  \n      : () =>  this.utils.matcherHint(assertionName, undefined, undefined, { isNot: this.isNot }) +  \n          '\\n\\n' +  \n          `Locator: ${locator}\\n` +  \n          `Expected: ${this.utils.printExpected(expected)}\\n` +  \n          (matcherResult ? `Received: ${this.utils.printReceived(matcherResult.actual)}` : '');  \n  \n    return {  \n      message,  \n      pass,  \n      name: assertionName,  \n      expected,  \n      actual: matcherResult?.actual,  \n    };  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "JavaScript", "output": "import { test, expect } from '@playwright/test';  \nimport AxeBuilder from '@axe-core/playwright'; // 1  \n  \ntest.describe('homepage', () => { // 2  \n  test('should not have any automatically detectable accessibility issues', async ({ page }) => {  \n    await page.goto('https://your-site.com/'); // 3  \n  \n    const accessibilityScanResults = await new AxeBuilder({ page }).analyze(); // 4  \n  \n    expect(accessibilityScanResults.violations).toEqual([]); // 5  \n  });  \n});  \n\n\n\nconst { test, expect } = require('@playwright/test');  \nconst AxeBuilder = require('@axe-core/playwright').default; // 1  \n  \ntest.describe('homepage', () => { // 2  \n  test('should not have any automatically detectable accessibility issues', async ({ page }) => {  \n    await page.goto('https://your-site.com/'); // 3  \n  \n    const accessibilityScanResults = await new AxeBuilder({ page }).analyze(); // 4  \n  \n    expect(accessibilityScanResults.violations).toEqual([]); // 5  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Evaluate in the page\u200b | The code inside [locator.evaluateAll()](/docs/api/class-locator#locator-evaluate-all) runs in the page, you can call any DOM apis there.", "output": "const rows = page.getByRole('listitem');  \nconst texts = await rows.evaluateAll(  \n    list => list.map(element => element.textContent));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "note | Using serial is not recommended. It is usually better to make your tests isolated, so they can be run independently.", "output": "import { test, type Page } from '@playwright/test';  \n  \n// Annotate entire file as serial.  \ntest.describe.configure({ mode: 'serial' });  \n  \nlet page: Page;  \n  \ntest.beforeAll(async ({ browser }) => {  \n  page = await browser.newPage();  \n});  \n  \ntest.afterAll(async () => {  \n  await page.close();  \n});  \n  \ntest('runs first', async () => {  \n  await page.goto('https://playwright.dev/');  \n});  \n  \ntest('runs second', async () => {  \n  await page.getByText('Get Started').click();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // runs all tests in all files of a specific project in parallel  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n      fullyParallel: true,  \n    },  \n  ]  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "<div id=\"remaining-time\" data-testid=\"remaining-time\"></div>  \n<script>  \n  const endTime = Date.now() + 5 * 60_000;  \n  const renderTime = () => {  \n    const diffInSeconds = Math.round((endTime - Date.now()) / 1000);  \n    if (diffInSeconds <= 0) {  \n      document.getElementById('remaining-time').textContent =  \n        'You have been logged out due to inactivity.';  \n    } else {  \n      document.getElementById('remaining-time').textContent =  \n        `You will be logged out in ${diffInSeconds} seconds.`;  \n    }  \n    setTimeout(renderTime, 1000);  \n  };  \n  renderTime();  \n</script>  \n<button type=\"button\">Interaction</button>  \n\n\n\n// Initial time does not matter for the test, so we can pick current time.  \nawait page.clock.install();  \nawait page.navigate('http://localhost:3333');  \n// Interact with the page  \nawait page.getByRole('button').click();  \n  \n// Fast forward time 5 minutes as if the user did not do anything.  \n// Fast forward is like closing the laptop lid and opening it after 5 minutes.  \n// All the timers due will fire once immediately, as in the real browser.  \nawait page.clock.fastForward('05:00');  \n  \n// Check that the user was logged out automatically.  \nawait assert(page.getByText('You have been logged out due to inactivity.')).toBeVisible();", "output": "<div id=\"remaining-time\" data-testid=\"remaining-time\"></div>  \n<script>  \n  const endTime = Date.now() + 5 * 60_000;  \n  const renderTime = () => {  \n    const diffInSeconds = Math.round((endTime - Date.now()) / 1000);  \n    if (diffInSeconds <= 0) {  \n      document.getElementById('remaining-time').textContent =  \n        'You have been logged out due to inactivity.';  \n    } else {  \n      document.getElementById('remaining-time').textContent =  \n        `You will be logged out in ${diffInSeconds} seconds.`;  \n    }  \n    setTimeout(renderTime, 1000);  \n  };  \n  renderTime();  \n</script>  \n<button type=\"button\">Interaction</button>  \n\n\n\n// Initial time does not matter for the test, so we can pick current time.  \nawait page.clock.install();  \nawait page.goto('http://localhost:3333');  \n// Interact with the page  \nawait page.getByRole('button').click();  \n  \n// Fast forward time 5 minutes as if the user did not do anything.  \n// Fast forward is like closing the laptop lid and opening it after 5 minutes.  \n// All the timers due will fire once immediately, as in the real browser.  \nawait page.clock.fastForward('05:00');  \n  \n// Check that the user was logged out automatically.  \nawait expect(page.getByText('You have been logged out due to inactivity.')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/clock", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "warning | Google Chrome and Microsoft Edge have switched to a [new headless mode](https://developer.chrome.com/docs/chromium/headless) implementation that is closer to a regular headed mode. This differs from [chromium headless shell](https://developer.chrome.com/blog/chrome-headless-shell) that is used in Playwright by default when running headless, so expect different behavior in some cases. See [issue #33566](https://github.com/microsoft/playwright/issues/33566) fore details.", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    /* Test against branded browsers. */  \n    {  \n      name: 'Google Chrome',  \n      use: { ...devices['Desktop Chrome'], channel: 'chrome' }, // or 'chrome-beta'  \n    },  \n    {  \n      name: 'Microsoft Edge',  \n      use: { ...devices['Desktop Edge'], channel: 'msedge' }, // or \"msedge-beta\" or 'msedge-dev'  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/browsers"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \nimport jimp from 'jimp'; // image processing library  \n  \ntest('response interception', async ({ page }) => {  \n  await page.route('**/*.jpeg', async route => {  \n    const response = await page._request.fetch(route.request());  \n    const image = await jimp.read(await response.body());  \n    await image.blur(5);  \n    await route.fulfill({  \n      response,  \n      body: await image.getBufferAsync('image/jpeg'),  \n    });  \n  });  \n  const response = await page.goto('https://playwright.dev');  \n  expect(response.status()).toBe(200);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: tests/menu.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('menu', async ({ page }) => {  \n  // Your test that depends on the database  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "component.spec.ts", "output": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(Component);  \n  await component.update({  \n    props: { msg: 'greetings' },  \n    on: { click() {} },  \n    slots: { default: 'Child' }  \n  });  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    userAgent: 'some custom ua',  \n    viewport: { width: 100, height: 100 },  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    userAgent: 'some custom ua',  \n    viewport: { width: 100, height: 100 },  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: 'list',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as base } from '@playwright/test';  \n  \nconst test = base.extend<{  \n  testFixture: string,  \n  autoTestFixture: string,  \n  unusedFixture: string,  \n}, {  \n  workerFixture: string,  \n  autoWorkerFixture: string,  \n}>({  \n  workerFixture: [async ({ browser }) => {  \n    // workerFixture setup...  \n    await use('workerFixture');  \n    // workerFixture teardown...  \n  }, { scope: 'worker' }],  \n  \n  autoWorkerFixture: [async ({ browser }) => {  \n    // autoWorkerFixture setup...  \n    await use('autoWorkerFixture');  \n    // autoWorkerFixture teardown...  \n  }, { scope: 'worker', auto: true }],  \n  \n  testFixture: [async ({ page, workerFixture }) => {  \n    // testFixture setup...  \n    await use('testFixture');  \n    // testFixture teardown...  \n  }, { scope: 'test' }],  \n  \n  autoTestFixture: [async () => {  \n    // autoTestFixture setup...  \n    await use('autoTestFixture');  \n    // autoTestFixture teardown...  \n  }, { scope: 'test', auto: true }],  \n  \n  unusedFixture: [async ({ page }) => {  \n    // unusedFixture setup...  \n    await use('unusedFixture');  \n    // unusedFixture teardown...  \n  }, { scope: 'test' }],  \n});  \n  \ntest.beforeAll(async () => { /* ... */ });  \ntest.beforeEach(async ({ page }) => { /* ... */ });  \ntest('first test', async ({ page }) => { /* ... */ });  \ntest('second test', async ({ testFixture }) => { /* ... */ });  \ntest.afterEach(async () => { /* ... */ });  \ntest.afterAll(async () => { /* ... */ });", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Locate by CSS or XPath\u200b | If you absolutely must use CSS or XPath locators, you can use [page.locator()](/docs/api/class-page#page-locator) to create a locator that takes a selector describing how to find an element in the page. Playwright supports CSS and XPath selectors, and auto-detects them if you omit `css=` or `xpath=` prefix.", "output": "await page.locator('css=button').click();  \nawait page.locator('xpath=//button').click();  \n  \nawait page.locator('button').click();  \nawait page.locator('//button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "navigation"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "test.spec.ts", "output": "import { test } from './fixtures';  \n  \ntest('passes', async ({ database, page, a11y }) => {  \n  // use database and a11y fixtures.  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: For more control, you can specify reporters programmatically in the [configuration file](/docs/test-configuration). | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: 'line',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('event', async ({ mount }) => {  \n  const component = await mount(Component, { on: { click() {} } });  \n});", "output": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('event', async ({ mount }) => {  \n  const component = await mount(Component, { on: { click() {} } });  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Click to expand the code for the `TodoPage` and `SettingsPage` | todo-page.ts", "input": "", "output": "import type { Page, Locator } from '@playwright/test';  \n  \nexport class TodoPage {  \n  private readonly inputBox: Locator;  \n  private readonly todoItems: Locator;  \n  \n  constructor(public readonly page: Page) {  \n    this.inputBox = this.page.locator('input.new-todo');  \n    this.todoItems = this.page.getByTestId('todo-item');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://demo.playwright.dev/todomvc/');  \n  }  \n  \n  async addToDo(text: string) {  \n    await this.inputBox.fill(text);  \n    await this.inputBox.press('Enter');  \n  }  \n  \n  async remove(text: string) {  \n    const todo = this.todoItems.filter({ hasText: text });  \n    await todo.hover();  \n    await todo.getByLabel('Delete').click();  \n  }  \n  \n  async removeAll() {  \n    while ((await this.todoItems.count()) > 0) {  \n      await this.todoItems.first().hover();  \n      await this.todoItems.getByLabel('Delete').first().click();  \n    }  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Poll the method until it returns an asserted result.  \nawait assert.poll(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  return response.status();  \n}).toBe(200);", "output": "// Poll the method until it returns an expected result.  \nawait expect.poll(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  return response.status();  \n}).toBe(200);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  tsconfig: './tsconfig.test.json',  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  tsconfig: './tsconfig.test.json',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-typescript", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "`expect` now supports lots of new web-first assertions. | Consider the following example:", "output": "await expect(page.locator('.status')).toHaveText('Submitted');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest('slow test', async ({ page }) => {  \n  test.slow(); // Easy way to triple the default timeout  \n  // ...  \n});  \n  \ntest('very slow test', async ({ page }) => {  \n  test.setTimeout(120_000);  \n  // ...  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('slow test', async ({ page }) => {  \n  test.slow(); // Easy way to triple the default timeout  \n  // ...  \n});  \n  \ntest('very slow test', async ({ page }) => {  \n  test.setTimeout(120_000);  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Playwright Test includes the ability to produce and visually compare screenshots using `await expect(page).toHaveScreenshot()`. On first execution, Playwright test will generate reference screenshots. Subsequent runs will compare against the reference. | example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  await expect(page).toHaveScreenshot();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Concise 'dot' for CI, default 'list' when running locally  \n  reporter: process.env.CI ? 'dot' : 'list',  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Concise 'dot' for CI, default 'list' when running locally  \n  reporter: process.env.CI ? 'dot' : 'list',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { expect, type Locator, type Page } from '@playwright/test';  \n  \nexport class PlaywrightDevPage {  \n  readonly page: Page;  \n  readonly getStartedLink: Locator;  \n  readonly gettingStartedHeader: Locator;  \n  readonly pomLink: Locator;  \n  readonly tocList: Locator;  \n  \n  constructor(page: Page) {  \n    this.page = page;  \n    this.getStartedLink = page.locator('a', { hasText: 'Get started' });  \n    this.gettingStartedHeader = page.locator('h1', { hasText: 'Installation' });  \n    this.pomLink = page.locator('li', {  \n      hasText: 'Guides',  \n    }).locator('a', {  \n      hasText: 'Page Object Model',  \n    });  \n    this.tocList = page.locator('article div.markdown ul > li > a');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://playwright.dev');  \n  }  \n  \n  async getStarted() {  \n    await this.getStartedLink.first().click();  \n    await expect(this.gettingStartedHeader).toBeVisible();  \n  }  \n  \n  async pageObjectModel() {  \n    await this.getStarted();  \n    await this.pomLink.click();  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/pom", "type": "website_test"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "example.spec.js", "output": "const { test, expect } = require('@playwright/test');  \nconst { PlaywrightDevPage } = require('./playwright-dev-page');  \n  \ntest('getting started should contain table of contents', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.getStarted();  \n  await expect(playwrightDev.tocList).toHaveText([  \n    `How to install Playwright`,  \n    `What's Installed`,  \n    `How to run the example test`,  \n    `How to open the HTML test report`,  \n    `Write tests using web first assertions, page fixtures and locators`,  \n    `Run single test, multiple tests, headed mode`,  \n    `Generate tests with Codegen`,  \n    `See a trace of your tests`  \n  ]);  \n});  \n  \ntest('should show Page Object Model article', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.pageObjectModel();  \n  await expect(page.locator('article')).toContainText('Page Object Model is a common pattern');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/pom", "type": "fixture"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "tests/example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('specific viewport block', () => {  \n  test.use({ viewport: { width: 1600, height: 1200 } });  \n  \n  test('my test', async ({ page }) => {  \n    // ...  \n  });  \n});  \n\n\n\n// Create context with given viewport  \nconst context = await browser.newContext({  \n  viewport: { width: 1600, height: 1200 }  \n});  \nconst page = await context.newPage();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Maximum time each action such as `click()` can take. Defaults to 0 (no limit).  \n    actionTimeout: 0,  \n  \n    // Name of the browser that runs tests. For example `chromium`, `firefox`, `webkit`.  \n    browserName: 'chromium',  \n  \n    // Toggles bypassing Content-Security-Policy.  \n    bypassCSP: true,  \n  \n    // Channel to use, for example \"chrome\", \"chrome-beta\", \"msedge\", \"msedge-beta\".  \n    channel: 'chrome',  \n  \n    // Run browser in headless mode.  \n    headless: false,  \n  \n    // Change the default data-testid attribute.  \n    testIdAttribute: 'pw-test-id',  \n  },  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-use-options", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { http, HttpResponse } from 'msw';  \n  \ntest('example test', async ({ mount, router }) => {  \n  await router.use(http.get('/data', async ({ request }) => {  \n    return HttpResponse.json({ value: 'mocked' });  \n  }));  \n  \n  // test as usual, your handler is active  \n  // ...  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "This will find both buttons and throw a [strictness](/docs/locators#strictness) violation error:", "output": "await page.locator('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from './fixtures';  \n  \ntest('passes', async ({ database, page, a11y }) => {  \n  // use database and a11y fixtures.  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const { webkit } = require('playwright');  \n  \n(async () => {  \n  const browser = await webkit.launch();  \n  const page = await browser.newPage();  \n  await page.goto('https://playwright.dev/');  \n  await page.screenshot({ path: `example.png` });  \n  await browser.close();  \n})();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/library", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  await assert(response).toBeOK();  \n}).toPass();", "output": "await expect(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  await expect(response).toBeOK();  \n}).toPass();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  expect: {  \n    // Maximum time expect() should wait for the condition to be met.  \n    timeout: 5000,  \n  \n    toHaveScreenshot: {  \n      // An acceptable amount of pixels that could be different, unset by default.  \n      maxDiffPixels: 10,  \n    },  \n  \n    toMatchSnapshot: {  \n      // An acceptable ratio of pixels that are different to the  \n      // total amount of pixels, between 0 and 1.  \n      maxDiffPixelRatio: 0.1,  \n    },  \n  },  \n  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-configuration", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \nimport type { TestOptions } from './my-test';  \n  \nexport default defineConfig<TestOptions>({  \n  projects: [  \n    {  \n      name: 'alice',  \n      use: { person: 'Alice' },  \n    },  \n    {  \n      name: 'bob',  \n      use: { person: 'Bob' },  \n    },  \n  ]  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-parameterize", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Any options accepted by [browserType.launch()](/docs/api/class-browsertype#browser-type-launch) or [browser.newContext()](/docs/api/class-browser#browser-new-context) can be put into `launchOptions` or `contextOptions` respectively in the `use` section. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    launchOptions: {  \n      slowMo: 50,  \n    },  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('context fetch', async ({ page }) => {  \n  const completeness = page.locator('text=Success');  \n  await completeness.waitFor();  \n  expect(await page.screenshot()).toMatchSnapshot('screen.png');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: Filter by not having child/descendant\u200b | We can also filter by **not having** a matching element inside.", "input": "", "output": "await expect(page  \n    .getByRole('listitem')  \n    .filter({ hasNot: page.getByText('Product 2') }))  \n    .toHaveCount(1);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "`#nav-bar :text(\"Home\")` \\- the `:text()` pseudo-class matches the smallest element containing specified text. Matching is case-insensitive, trims whitespace and searches for a substring. | For example, this will find an element with text \"Home\" somewhere inside the `#nav-bar` element:", "output": "await page.locator('#nav-bar :text(\"Home\")').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "navigation"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "my-test.ts", "output": "import { test as base } from '@playwright/test';  \nimport { TodoPage } from './todo-page';  \n  \n// Declare your options to type-check your configuration.  \nexport type MyOptions = {  \n  defaultItem: string;  \n};  \ntype MyFixtures = {  \n  todoPage: TodoPage;  \n};  \n  \n// Specify both option and fixture types.  \nexport const test = base.extend<MyOptions & MyFixtures>({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  defaultItem: ['Something nice', { option: true }],  \n  \n  // Our \"todoPage\" fixture depends on the option.  \n  todoPage: async ({ page, defaultItem }, use) => {  \n    const todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo(defaultItem);  \n    await use(todoPage);  \n    await todoPage.removeAll();  \n  },  \n});  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "fixture"}}
{"instruction": "Generate a Playwright test for the following scenario: Verifying API calls\u200b | Sometimes it is useful to check if the page made all expected APIs calls. You can record all API method invocations and then compare them with golden result. [page.exposeFunction()](/docs/api/class-page#page-expose-function) may come in handy for passing message from the page back to the test code:", "input": "", "output": "test('log battery calls', async ({ page }) => {  \n  const log = [];  \n  // Expose function for pushing messages to the Node.js script.  \n  await page.exposeFunction('logCall', msg => log.push(msg));  \n  await page.addInitScript(() => {  \n    const mockBattery = {  \n      level: 0.75,  \n      charging: true,  \n      chargingTime: 1800,  \n      dischargingTime: Infinity,  \n      // Log addEventListener calls.  \n      addEventListener: (name, cb) => logCall(`addEventListener:${name}`)  \n    };  \n    // Override the method to always return mock battery info.  \n    window.navigator.getBattery = async () => {  \n      logCall('getBattery');  \n      return mockBattery;  \n    };  \n  });  \n  \n  await page.goto('/');  \n  await expect(page.locator('.battery-percentage')).toHaveText('75%');  \n  \n  // Compare actual calls with golden.  \n  expect(log).toEqual([  \n    'getBattery',  \n    'addEventListener:chargingchange',  \n    'addEventListener:levelchange'  \n  ]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock-browser-apis"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    /* Test against branded browsers. */  \n    {  \n      name: 'Google Chrome',  \n      use: { ...devices['Desktop Chrome'], channel: 'chrome' }, // or 'chrome-beta'  \n    },  \n    {  \n      name: 'Microsoft Edge',  \n      use: { ...devices['Desktop Edge'], channel: 'msedge' }, // or \"msedge-beta\" or 'msedge-dev'  \n    },  \n  ],  \n});", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    /* Test against branded browsers. */  \n    {  \n      name: 'Google Chrome',  \n      use: { ...devices['Desktop Chrome'], channel: 'chrome' }, // or 'chrome-beta'  \n    },  \n    {  \n      name: 'Microsoft Edge',  \n      use: { ...devices['Desktop Edge'], channel: 'msedge' }, // or \"msedge-beta\" or 'msedge-dev'  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/browsers", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect(page.locator('x-details')).toContainText('Details');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "New method [frameLocator.owner()](/docs/api/class-framelocator#frame-locator-owner) converts a [FrameLocator](/docs/api/class-framelocator \"FrameLocator\") object to a [Locator](/docs/api/class-locator \"Locator\"). This can be useful when you have a [FrameLocator](/docs/api/class-framelocator \"FrameLocator\") object obtained somewhere, and later on would like to interact with the `iframe` element.", "output": "const frameLocator = page.frameLocator('iframe[name=\"embedded\"]');  \n// ...  \nconst locator = frameLocator.owner();  \nawait expect(locator).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: You can fill the input after locating it by the placeholder text:", "input": "", "output": "await page  \n    .getByPlaceholder('name@example.com')  \n    .fill('playwright@microsoft.com');", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.goto('https://playwright.dev');  \nawait expect(page).toHaveScreenshot({  \n  mask: [page.locator('img')],  \n  maskColor: '#00FF00', // green  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.getByLabel('User Name').fill('John');  \n  \nawait page.getByLabel('Password').fill('secret-password');  \n  \nawait page.getByRole('button', { name: 'Sign in' }).click();  \n  \nawait expect(page.getByText('Welcome, John!')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'], channel: 'chromium' },  \n    },  \n  ],  \n});", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'], channel: 'chromium' },  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Consider the following example:", "input": "", "output": "import { test as base } from '@playwright/test';  \n  \nconst test = base.extend<{  \n  testFixture: string,  \n  autoTestFixture: string,  \n  unusedFixture: string,  \n}, {  \n  workerFixture: string,  \n  autoWorkerFixture: string,  \n}>({  \n  workerFixture: [async ({ browser }) => {  \n    // workerFixture setup...  \n    await use('workerFixture');  \n    // workerFixture teardown...  \n  }, { scope: 'worker' }],  \n  \n  autoWorkerFixture: [async ({ browser }) => {  \n    // autoWorkerFixture setup...  \n    await use('autoWorkerFixture');  \n    // autoWorkerFixture teardown...  \n  }, { scope: 'worker', auto: true }],  \n  \n  testFixture: [async ({ page, workerFixture }) => {  \n    // testFixture setup...  \n    await use('testFixture');  \n    // testFixture teardown...  \n  }, { scope: 'test' }],  \n  \n  autoTestFixture: [async () => {  \n    // autoTestFixture setup...  \n    await use('autoTestFixture');  \n    // autoTestFixture teardown...  \n  }, { scope: 'test', auto: true }],  \n  \n  unusedFixture: [async ({ page }) => {  \n    // unusedFixture setup...  \n    await use('unusedFixture');  \n    // unusedFixture teardown...  \n  }, { scope: 'test' }],  \n});  \n  \ntest.beforeAll(async () => { /* ... */ });  \ntest.beforeEach(async ({ page }) => { /* ... */ });  \ntest('first test', async ({ page }) => { /* ... */ });  \ntest('second test', async ({ testFixture }) => { /* ... */ });  \ntest.afterEach(async () => { /* ... */ });  \ntest.afterAll(async () => { /* ... */ });", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { http, HttpResponse } from 'msw';  \n  \ntest('example test', async ({ mount, router }) => {  \n  await router.use(http.get('/data', async ({ request }) => {  \n    return HttpResponse.json({ value: 'mocked' });  \n  }));  \n  \n  // test as usual, your handler is active  \n  // ...  \n});", "output": "import { http, HttpResponse } from 'msw';  \n  \ntest('example test', async ({ mount, router }) => {  \n  await router.use(http.get('/data', async ({ request }) => {  \n    return HttpResponse.json({ value: 'mocked' });  \n  }));  \n  \n  // test as usual, your handler is active  \n  // ...  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: You can now merge custom expect matchers from multiple files or modules: | fixtures.ts", "input": "", "output": "import { mergeTests, mergeExpects } from '@playwright/test';  \nimport { test as dbTest, expect as dbExpect } from 'database-test-utils';  \nimport { test as a11yTest, expect as a11yExpect } from 'a11y-test-utils';  \n  \nexport const test = mergeTests(dbTest, a11yTest);  \nexport const expect = mergeExpects(dbExpect, a11yExpect);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Navigation\u200b | Most of the tests will start with navigating page to the URL. After that, test will be able to interact with the page elements.", "output": "await page.goto('https://playwright.dev/');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/writing-tests", "type": "navigation"}}
{"instruction": "Generate a Playwright test for the following scenario: Here is an example of reusing your existing MSW handlers in the test.", "input": "", "output": "import { handlers } from '@src/mocks/handlers';  \n  \ntest.beforeEach(async ({ router }) => {  \n  // install common handlers before each test  \n  await router.use(...handlers);  \n});  \n  \ntest('example test', async ({ mount }) => {  \n  // test as usual, your handlers are active  \n  // ...  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: Evaluate in the page\u200b | The code inside [locator.evaluateAll()](/docs/api/class-locator#locator-evaluate-all) runs in the page, you can call any DOM apis there.", "input": "", "output": "const rows = page.getByRole('listitem');  \nconst texts = await rows.evaluateAll(  \n    list => list.map(element => element.textContent));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert(page.getByTitle('Issues count')).toHaveText('25 issues');", "output": "await expect(page.getByTitle('Issues count')).toHaveText('25 issues');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You can now merge custom expect matchers from multiple files or modules: | fixtures.ts", "output": "import { mergeTests, mergeExpects } from '@playwright/test';  \nimport { test as dbTest, expect as dbExpect } from 'database-test-utils';  \nimport { test as a11yTest, expect as a11yExpect } from 'a11y-test-utils';  \n  \nexport const test = mergeTests(dbTest, a11yTest);  \nexport const expect = mergeExpects(dbExpect, a11yExpect);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Limit the number of workers on CI, use default locally  \n  workers: process.env.CI ? 2 : undefined,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Filter tests by glob patterns or regular expressions. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Glob patterns or regular expressions to ignore test files.  \n  testIgnore: '*test-assets',  \n  \n  // Glob patterns or regular expressions that match test files.  \n  testMatch: '*todo-tests/*.spec.ts',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-configuration"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const rows = page.getByRole('listitem');  \nconst texts = await rows.evaluateAll(  \n    list => list.map(element => element.textContent));", "output": "const rows = page.getByRole('listitem');  \nconst texts = await rows.evaluateAll(  \n    list => list.map(element => element.textContent));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/experimental-ct-vue';  \nimport App from './App.vue';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<App />);  \n  await expect(component).toContainText('Learn Vue');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/experimental-ct-react';  \nimport { InputMediaForTest } from './input-media.story.tsx';  \n  \ntest('changes the image', async ({ mount }) => {  \n  let mediaSelected: string | null = null;  \n  \n  const component = await mount(  \n    <InputMediaForTest  \n      onMediaChange={mediaName => {  \n        mediaSelected = mediaName;  \n      }}  \n    />  \n  );  \n  await component  \n    .getByTestId('imageInput')  \n    .setInputFiles('src/assets/logo.png');  \n  \n  await assert(component.getByAltText(/selected image/i)).toBeVisible();  \n  await assert.poll(() => mediaSelected).toBe('logo.png');  \n});", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport { InputMediaForTest } from './input-media.story.tsx';  \n  \ntest('changes the image', async ({ mount }) => {  \n  let mediaSelected: string | null = null;  \n  \n  const component = await mount(  \n    <InputMediaForTest  \n      onMediaChange={mediaName => {  \n        mediaSelected = mediaName;  \n      }}  \n    />  \n  );  \n  await component  \n    .getByTestId('imageInput')  \n    .setInputFiles('src/assets/logo.png');  \n  \n  await expect(component.getByAltText(/selected image/i)).toBeVisible();  \n  await expect.poll(() => mediaSelected).toBe('logo.png');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.locator('#item-to-be-dragged').dragTo(page.locator('#item-to-drop-at'));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  await test.step('Log in', async () => {  \n    // ...  \n  });  \n  await test.step('news feed', async () => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Run your local dev server before starting the tests  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n    stdout: 'pipe',  \n    stderr: 'pipe',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test.describe.parallel('group', () => {  \n  test('runs in parallel 1', async ({ page }) => {  \n  });  \n  test('runs in parallel 2', async ({ page }) => {  \n  });  \n});", "output": "test.describe.parallel('group', () => {  \n  test('runs in parallel 1', async ({ page }) => {  \n  });  \n  test('runs in parallel 2', async ({ page }) => {  \n  });  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "test('should not have any accessibility violations outside of rules with known issues', async ({  \n  page,  \n}) => {  \n  await page.goto('https://your-site.com/page-with-known-issues');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .disableRules(['duplicate-id'])  \n      .analyze();  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(Component);  \n  await component.update({  \n    props: { msg: 'greetings' },  \n    on: { click() {} },  \n    slots: { default: 'Child' }  \n  });  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/experimental-ct-vue';  \nimport type { HooksConfig } from '../playwright';  \nimport Store from './Store.vue';  \n  \ntest('override initialState ', async ({ mount }) => {  \n  const component = await mount<HooksConfig>(Store, {  \n    hooksConfig: {  \n      store: { name: 'override initialState' }  \n    }  \n  });  \n  await expect(component).toContainText('override initialState');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Custom expect message\u200b | You can specify a custom expect message as a second argument to the `expect` function, for example:", "input": "", "output": "await expect(page.getByText('Name'), 'should be logged in').toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Filter by not having child/descendant\u200b | We can also filter by **not having** a matching element inside.", "output": "await expect(page  \n    .getByRole('listitem')  \n    .filter({ hasNot: page.getByText('Product 2') }))  \n    .toHaveCount(1);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "Error: should be logged in  \n  \n    Call log:  \n      - expect.toBeVisible with timeout 5000ms  \n      - waiting for \"getByText('Name')\"  \n  \n  \n      2 |  \n      3 | test('example test', async({ page }) => {  \n    > 4 |   await expect(page.locator('text=Name'), 'should be logged in').toBeVisible();  \n        |                                                                  ^  \n      5 | });  \n      6 |", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "If you don't have input element in hand (it is created dynamically), you can handle the [page.on('filechooser')](/docs/api/class-page#page-event-file-chooser) event or use a corresponding waiting method upon your action:", "output": "// Start waiting for file chooser before clicking. Note no await.  \nconst fileChooserPromise = page.waitForEvent('filechooser');  \nawait page.getByLabel('Upload file').click();  \nconst fileChooser = await fileChooserPromise;  \nawait fileChooser.setFiles(path.join(__dirname, 'myfile.pdf'));", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input", "type": "navigation"}}
{"instruction": "Generate a Playwright test for the following scenario: playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: 'line',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.beforeEach(async ({ page }, testInfo) => {  \n  // Extend timeout for all tests running this hook by 30 seconds.  \n  testInfo.setTimeout(testInfo.timeout + 30_000);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: Vue locator allows finding elements by their component name and property values. The syntax is very similar to [CSS attribute selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors) and supports all CSS attribute selector operators. | In Vue locator, component names are transcribed with **kebab-case**.", "input": "", "output": "await page.locator('_vue=book-item').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Sometimes you want to tag your tests as `@fast` or `@slow`, and then filter by tag in the test report. Or you might want to only run tests that have a certain tag. | To tag a test, either provide an additional details object when declaring a test, or add `@`-token to the test title. Note that tags must start with `@` symbol.", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('test login page', {  \n  tag: '@fast',  \n}, async ({ page }) => {  \n  // ...  \n});  \n  \ntest('test full report @slow', async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You can extend Playwright assertions by providing custom matchers. These matchers will be available on the expect object. | test.spec.ts", "output": "import { expect as baseExpect } from '@playwright/test';  \nexport const expect = baseExpect.extend({  \n  async toHaveAmount(locator: Locator, expected: number, options?: { timeout?: number }) {  \n    // ... see documentation for how to write matchers.  \n  },  \n});  \n  \ntest('pass', async ({ page }) => {  \n  await expect(page.getByTestId('cart')).toHaveAmount(5);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "Now, each test file should import `test` from our fixtures file instead of `@playwright/test`. | tests/example.spec.ts", "output": "// Important: import our fixtures.  \nimport { test, expect } from '../playwright/fixtures';  \n  \ntest('test', async ({ dbUserName }) => {  \n  // Use the user name in the test.  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Generate a Playwright test for the following scenario: First, add fixtures that will load the extension: | fixtures.ts", "input": "", "output": "import { test as base, chromium, type BrowserContext } from '@playwright/test';  \nimport path from 'path';  \n  \nexport const test = base.extend<{  \n  context: BrowserContext;  \n  extensionId: string;  \n}>({  \n  context: async ({ }, use) => {  \n    const pathToExtension = path.join(__dirname, 'my-extension');  \n    const context = await chromium.launchPersistentContext('', {  \n      headless: false,  \n      args: [  \n        `--disable-extensions-except=${pathToExtension}`,  \n        `--load-extension=${pathToExtension}`,  \n      ],  \n    });  \n    await use(context);  \n    await context.close();  \n  },  \n  extensionId: async ({ context }, use) => {  \n    /*  \n    // for manifest v2:  \n    let [background] = context.backgroundPages()  \n    if (!background)  \n      background = await context.waitForEvent('backgroundpage')  \n    */  \n  \n    // for manifest v3:  \n    let [background] = context.serviceWorkers();  \n    if (!background)  \n      background = await context.waitForEvent('serviceworker');  \n  \n    const extensionId = background.url().split('/')[2];  \n    await use(extensionId);  \n  },  \n});  \nexport const expect = test.expect;", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/chrome-extensions"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \nimport AxeBuilder from '@axe-core/playwright'; // 1  \n  \ntest.describe('homepage', () => { // 2  \n  test('should not have any automatically detectable accessibility issues', async ({ page }) => {  \n    await page.goto('https://your-site.com/'); // 3  \n  \n    const accessibilityScanResults = await new AxeBuilder({ page }).analyze(); // 4  \n  \n    expect(accessibilityScanResults.violations).toEqual([]); // 5  \n  });  \n});  \n\n\n\nconst { test, expect } = require('@playwright/test');  \nconst AxeBuilder = require('@axe-core/playwright').default; // 1  \n  \ntest.describe('homepage', () => { // 2  \n  test('should not have any automatically detectable accessibility issues', async ({ page }) => {  \n    await page.goto('https://your-site.com/'); // 3  \n  \n    const accessibilityScanResults = await new AxeBuilder({ page }).analyze(); // 4  \n  \n    expect(accessibilityScanResults.violations).toEqual([]); // 5  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Text input\u200b | Using [locator.fill()](/docs/api/class-locator#locator-fill) is the easiest way to fill out the form fields. It focuses the element and triggers an `input` event with the entered text. It works for `<input>`, `<textarea>` and `[contenteditable]` elements.", "input": "", "output": "// Text input  \nawait page.getByRole('textbox').fill('Peter');  \n  \n// Date input  \nawait page.getByLabel('Birth date').fill('2020-02-02');  \n  \n// Time input  \nawait page.getByLabel('Appointment time').fill('13:15');  \n  \n// Local datetime input  \nawait page.getByLabel('Local time').fill('2020-03-02T05:15');", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: 'orange' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Match with a regular expression:", "output": "await expect(page.getByText(/welcome, [A-Za-z]+$/i)).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.locator('xpath=//button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Use parallelism and sharding\u200b | Playwright runs tests in [parallel](/docs/test-parallel) by default. Tests in a single file are run in order, in the same worker process. If you have many independent tests in a single file, you might want to run them in parallel", "output": "import { test } from '@playwright/test';  \n  \ntest.describe.configure({ mode: 'parallel' });  \n  \ntest('runs in parallel 1', async ({ page }) => { /* ... */ });  \ntest('runs in parallel 2', async ({ page }) => { /* ... */ });", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/best-practices"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "The difference between the [Locator](/docs/api/class-locator \"Locator\") and [ElementHandle](/docs/api/class-elementhandle \"ElementHandle\") is that the latter points to a particular element, while Locator captures the logic of how to retrieve that element. | In the example below, handle points to a particular DOM element on page. If that element changes text or is used by React to render an entirely different component, handle is still pointing to that very stale DOM element. This can lead to unexpected behaviors.", "output": "const handle = await page.$('text=Submit');  \n// ...  \nawait handle.hover();  \nawait handle.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/handles", "type": "navigation"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "Then use these fixtures in a test:", "output": "import { test, expect } from './fixtures';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://example.com');  \n  await expect(page.locator('body')).toHaveText('Changed by my-extension');  \n});  \n  \ntest('popup page', async ({ page, extensionId }) => {  \n  await page.goto(`chrome-extension://${extensionId}/popup.html`);  \n  await expect(page.locator('body')).toHaveText('my-extension popup');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/chrome-extensions"}}
{"instruction": "Generate a Playwright test for the following scenario: The difference between the [Locator](/docs/api/class-locator \"Locator\") and [ElementHandle](/docs/api/class-elementhandle \"ElementHandle\") is that the latter points to a particular element, while Locator captures the logic of how to retrieve that element. | In the example below, handle points to a particular DOM element on page. If that element changes text or is used by React to render an entirely different component, handle is still pointing to that very stale DOM element. This can lead to unexpected behaviors.", "input": "", "output": "const handle = await page.$('text=Submit');  \n// ...  \nawait handle.hover();  \nawait handle.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/handles"}}
{"instruction": "Generate a Playwright test for the following scenario: For certain types of errors Playwright uses specific error classes. These classes are available via `playwright.errors`. | An example of handling a timeout error:", "input": "", "output": "try {  \n  await page.locator('.foo').waitFor();  \n} catch (e) {  \n  if (e instanceof playwright.errors.TimeoutError) {  \n    // Do something if this is a timeout.  \n  }  \n}", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/api/class-playwright"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.getByTestId('orange').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: test.spec.ts", "input": "", "output": "import { test } from './fixtures';  \n  \ntest('passes', async ({ database, page, a11y }) => {  \n  // use database and a11y fixtures.  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/test';  \n  \ntest.describe.configure({ mode: 'parallel' });  \n  \ntest('runs in parallel 1', async ({ page }) => { /* ... */ });  \ntest('runs in parallel 2', async ({ page }) => { /* ... */ });", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/best-practices", "type": "website_test"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "my-test.ts", "output": "import { test as base } from '@playwright/test';  \nimport { TodoPage } from './todo-page';  \nimport { SettingsPage } from './settings-page';  \n  \n// Declare the types of your fixtures.  \ntype MyFixtures = {  \n  todoPage: TodoPage;  \n  settingsPage: SettingsPage;  \n};  \n  \n// Extend base test by providing \"todoPage\" and \"settingsPage\".  \n// This new \"test\" can be used in multiple test files, and each of them will get the fixtures.  \nexport const test = base.extend<MyFixtures>({  \n  todoPage: async ({ page }, use) => {  \n    // Set up the fixture.  \n    const todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo('item1');  \n    await todoPage.addToDo('item2');  \n  \n    // Use the fixture value in the test.  \n    await use(todoPage);  \n  \n    // Clean up the fixture.  \n    await todoPage.removeAll();  \n  },  \n  \n  settingsPage: async ({ page }, use) => {  \n    await use(new SettingsPage(page));  \n  },  \n});  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "fixture"}}
{"instruction": "Generate a Playwright test for the following scenario: Here we compare text content against the reference. | example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  expect(await page.textContent('.hero__title')).toMatchSnapshot('hero.txt');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('context fetch', async ({ page }) => {  \n  const completeness = page.locator('text=Success');  \n  await completeness.waitFor();  \n  expect(await page.screenshot()).toMatchSnapshot('screen.png');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "> New Headless on the other hand is the real Chrome browser, and is thus more authentic, reliable, and offers more features. This makes it more suitable for high-accuracy end-to-end web app testing or browser extension testing. | See [issue #33566](https://github.com/microsoft/playwright/issues/33566) for the list of possible breakages you could encounter and more details on Chromium headless. Please file an issue if you see any problems after opting in.", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'], channel: 'chromium' },  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Use the [code generator](/docs/codegen) to generate a locator, and then edit it as you'd like. | Every time a locator is used for an action, an up-to-date DOM element is located in the page. In the snippet below, the underlying DOM element will be located twice, once prior to every action. This means that if the DOM changes in between the calls due to re-render, the new element corresponding to the locator will be used.", "output": "const locator = page.getByRole('button', { name: 'Sign in' });  \n  \nawait locator.hover();  \nawait locator.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "> New Headless on the other hand is the real Chrome browser, and is thus more authentic, reliable, and offers more features. This makes it more suitable for high-accuracy end-to-end web app testing or browser extension testing. | See [issue #33566](https://github.com/microsoft/playwright/issues/33566) for details.", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'], channel: 'chromium' },  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/browsers"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Use chaining and filtering\u200b | Locators can be [chained](/docs/locators#matching-inside-a-locator) to narrow down the search to a particular part of the page.", "output": "const product = page.getByRole('listitem').filter({ hasText: 'Product 2' });", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/best-practices"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/experimental-ct-vue';  \nimport type { HooksConfig } from '../playwright';  \nimport ProductsPage from './pages/ProductsPage.vue';  \n  \ntest('configure routing through hooks config', async ({ page, mount }) => {  \n  const component = await mount<HooksConfig>(ProductsPage, {  \n    hooksConfig: { enableRouting: true },  \n  });  \n  await expect(component.getByRole('link')).toHaveAttribute('href', '/products/42');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Run your local dev server before starting the tests  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n    stdout: 'ignore',  \n    stderr: 'pipe',  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Run your local dev server before starting the tests  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n    stdout: 'ignore',  \n    stderr: 'pipe',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-webserver", "type": "modification"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "And then import the fixtures in all your tests: | mytest.spec.ts", "output": "import { test } from './fixtures';  \nimport { expect } from '@playwright/test';  \n  \ntest('basic', async ({ }) => {  \n  // ...  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "fixture"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    colorScheme: 'dark',  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    colorScheme: 'dark',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/emulation", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Locate an item by the role of \"listitem\" and then filter by the text of \"orange\" and then click it.", "output": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: 'orange' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const newEmail = page.getByRole('button', { name: 'New email' });  \nconst dialog = page.getByText('Confirm security settings');  \nawait assert(newEmail.or(dialog)).toBeVisible();  \nif (await dialog.isVisible())  \n  await page.getByRole('button', { name: 'Dismiss' }).click();  \nawait newEmail.click();", "output": "const newEmail = page.getByRole('button', { name: 'New email' });  \nconst dialog = page.getByText('Confirm security settings');  \nawait expect(newEmail.or(dialog)).toBeVisible();  \nif (await dialog.isVisible())  \n  await page.getByRole('button', { name: 'Dismiss' }).click();  \nawait newEmail.click();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const base = require('@playwright/test');  \n  \nexports.test = base.test.extend({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  person: ['John', { option: true }],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parameterize", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Emulate the user Locale and Timezone which can be set globally for all tests in the config and then overridden for particular tests. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Emulates the user locale.  \n    locale: 'en-GB',  \n  \n    // Emulates the user timezone.  \n    timezoneId: 'Europe/Paris',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const data = 'some data';  \nconst result = await page.evaluate(() => {  \n  // WRONG: there is no \"data\" in the web page.  \n  window.myApp.use(data);  \n});", "output": "const data = 'some data';  \nconst result = await page.evaluate(() => {  \n  // WRONG: there is no \"data\" in the web page.  \n  window.myApp.use(data);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/evaluating", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You don't have to configure anything to mock network requests. Just define a custom [Route](/docs/api/class-route \"Route\") that mocks network for a browser context. | example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.beforeEach(async ({ context }) => {  \n  // Block any css requests for each test in this file.  \n  await context.route(/.css$/, route => route.abort());  \n});  \n  \ntest('loads page without css', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  // ... test goes here  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    trace: 'retain-on-first-failure',  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    trace: 'retain-on-first-failure',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test('test customer login', {  \n  tag: ['@fast', '@login'],  \n}, async ({ page }) => {  \n  // ...  \n});", "output": "test('test customer login', {  \n  tag: ['@fast', '@login'],  \n}, async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \nimport { PlaywrightDevPage } from './playwright-dev-page';  \n  \ntest('getting started should contain table of contents', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.getStarted();  \n  await expect(playwrightDev.tocList).toHaveText([  \n    `How to install Playwright`,  \n    `What's Installed`,  \n    `How to run the example test`,  \n    `How to open the HTML test report`,  \n    `Write tests using web first assertions, page fixtures and locators`,  \n    `Run single test, multiple tests, headed mode`,  \n    `Generate tests with Codegen`,  \n    `See a trace of your tests`  \n  ]);  \n});  \n  \ntest('should show Page Object Model article', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.pageObjectModel();  \n  await expect(page.locator('article')).toContainText('Page Object Model is a common pattern');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/pom"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Playwright also includes async matchers that will wait until the expected condition is met. Using these matchers allows making the tests non-flaky and resilient. For example, this code will wait until the page gets the title containing \"Playwright\":", "output": "await expect(page).toHaveTitle(/Playwright/);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/writing-tests"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page  \n    .getByPlaceholder('name@example.com')  \n    .fill('playwright@microsoft.com');", "output": "await page  \n    .getByPlaceholder('name@example.com')  \n    .fill('playwright@microsoft.com');", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: The use of [ElementHandle](/docs/api/class-elementhandle \"ElementHandle\") is discouraged, use [Locator](/docs/api/class-locator \"Locator\") objects and web-first assertions instead. | When [ElementHandle](/docs/api/class-elementhandle \"ElementHandle\") is required, it is recommended to fetch it with the [page.waitForSelector()](/docs/api/class-page#page-wait-for-selector) or [frame.waitForSelector()](/docs/api/class-frame#frame-wait-for-selector) methods. These APIs wait for the element to be attached and visible.", "input": "", "output": "// Get the element handle  \nconst elementHandle = page.waitForSelector('#box');  \n  \n// Assert bounding box for the element  \nconst boundingBox = await elementHandle.boundingBox();  \nexpect(boundingBox.width).toBe(100);  \n  \n// Assert attribute for the element  \nconst classNames = await elementHandle.getAttribute('class');  \nexpect(classNames.includes('highlighted')).toBeTruthy();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/handles"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Create a locator.  \nconst getStarted = page.getByRole('link', { name: 'Get started' });  \n  \n// Click it.  \nawait getStarted.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/writing-tests", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Handles as parameters\u200b | Handles can be passed into the [page.evaluate()](/docs/api/class-page#page-evaluate) and similar methods. The following snippet creates a new array in the page, initializes it with data and returns a handle to this array into Playwright. It then uses the handle in subsequent evaluations:", "input": "", "output": "// Create new array in page.  \nconst myArrayHandle = await page.evaluateHandle(() => {  \n  window.myArray = [1];  \n  return myArray;  \n});  \n  \n// Get the length of the array.  \nconst length = await page.evaluate(a => a.length, myArrayHandle);  \n  \n// Add one more element to the array using the handle  \nawait page.evaluate(arg => arg.myArray.push(arg.newElement), {  \n  myArray: myArrayHandle,  \n  newElement: 2  \n});  \n  \n// Release the object when it's no longer needed.  \nawait myArrayHandle.dispose();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/handles"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "axe-test.ts", "output": "import { test as base } from '@playwright/test';  \nimport AxeBuilder from '@axe-core/playwright';  \n  \ntype AxeFixture = {  \n  makeAxeBuilder: () => AxeBuilder;  \n};  \n  \n// Extend base test by providing \"makeAxeBuilder\"  \n//  \n// This new \"test\" can be used in multiple test files, and each of them will get  \n// a consistently configured AxeBuilder instance.  \nexport const test = base.extend<AxeFixture>({  \n  makeAxeBuilder: async ({ page }, use, testInfo) => {  \n    const makeAxeBuilder = () => new AxeBuilder({ page })  \n        .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])  \n        .exclude('#commonly-reused-element-with-known-issue');  \n  \n    await use(makeAxeBuilder);  \n  }  \n});  \nexport { expect } from '@playwright/test';  \n\n\n\n// axe-test.js  \nconst base = require('@playwright/test');  \nconst AxeBuilder = require('@axe-core/playwright').default;  \n  \n// Extend base test by providing \"makeAxeBuilder\"  \n//  \n// This new \"test\" can be used in multiple test files, and each of them will get  \n// a consistently configured AxeBuilder instance.  \nexports.test = base.test.extend({  \n  makeAxeBuilder: async ({ page }, use, testInfo) => {  \n    const makeAxeBuilder = () => new AxeBuilder({ page })  \n        .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])  \n        .exclude('#commonly-reused-element-with-known-issue');  \n  \n    await use(makeAxeBuilder);  \n  }  \n});  \nexports.expect = base.expect;", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/accessibility-testing", "type": "fixture"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'setup',  \n      testMatch: '**/*.setup.ts',  \n    },  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'firefox',  \n      use: { ...devices['Desktop Firefox'] },  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'webkit',  \n      use: { ...devices['Desktop Safari'] },  \n      dependencies: ['setup'],  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-projects", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Use multiple [BrowserContext](/docs/api/class-browsercontext \"BrowserContext\")s and [Page](/docs/api/class-page \"Page\")s with different storage states in the same test. | tests/example.spec.ts", "input": "", "output": "import { test } from '@playwright/test';  \n  \ntest('admin and user', async ({ browser }) => {  \n  // adminContext and all pages inside, including adminPage, are signed in as \"admin\".  \n  const adminContext = await browser.newContext({ storageState: 'playwright/.auth/admin.json' });  \n  const adminPage = await adminContext.newPage();  \n  \n  // userContext and all pages inside, including userPage, are signed in as \"user\".  \n  const userContext = await browser.newContext({ storageState: 'playwright/.auth/user.json' });  \n  const userPage = await userContext.newPage();  \n  \n  // ... interact with both adminPage and userPage ...  \n  \n  await adminContext.close();  \n  await userContext.close();  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Use [testProject.snapshotPathTemplate](/docs/api/class-testproject#test-project-snapshot-path-template) and [testConfig.snapshotPathTemplate](/docs/api/class-testconfig#test-config-snapshot-path-template) to configure a template controlling location of snapshots generated by [expect(page).toHaveScreenshot()](/docs/api/class-pageassertions#page-assertions-to-have-screenshot-1) and [expect(value).toMatchSnapshot()](/docs/api/class-snapshotassertions#snapshot-assertions-to-match-snapshot-1). | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  testDir: './tests',  \n  snapshotPathTemplate: '{testDir}/__screenshots__/{testFilePath}/{arg}{ext}',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test('should inherit use options on context when using built-in browser fixture', async ({  \n  browser,  \n}) => {  \n  const context = await browser.newContext();  \n  const page = await context.newPage();  \n  expect(await page.evaluate(() => navigator.userAgent)).toBe('some custom ua');  \n  expect(await page.evaluate(() => window.innerWidth)).toBe(100);  \n  await context.close();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-use-options", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test.describe(() => {  \n  test.use({ colorScheme: 'dark' });  \n  \n  test('one', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('two', async ({ page }) => {  \n    // ...  \n  });  \n});", "output": "test.describe(() => {  \n  test.use({ colorScheme: 'dark' });  \n  \n  test('one', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('two', async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { expect as baseExpect } from '@playwright/test';  \nimport type { Page, Locator } from '@playwright/test';  \n  \nexport { test } from '@playwright/test';  \n  \nexport const expect = baseExpect.extend({  \n  async toHaveAmount(locator: Locator, expected: number, options?: { timeout?: number }) {  \n    const assertionName = 'toHaveAmount';  \n    let pass: boolean;  \n    let matcherResult: any;  \n    try {  \n      await baseExpect(locator).toHaveAttribute('data-amount', String(expected), options);  \n      pass = true;  \n    } catch (e: any) {  \n      matcherResult = e.matcherResult;  \n      pass = false;  \n    }  \n  \n    const message = pass  \n      ? () => this.utils.matcherHint(assertionName, undefined, undefined, { isNot: this.isNot }) +  \n          '\\n\\n' +  \n          `Locator: ${locator}\\n` +  \n          `Expected: not ${this.utils.printExpected(expected)}\\n` +  \n          (matcherResult ? `Received: ${this.utils.printReceived(matcherResult.actual)}` : '')  \n      : () =>  this.utils.matcherHint(assertionName, undefined, undefined, { isNot: this.isNot }) +  \n          '\\n\\n' +  \n          `Locator: ${locator}\\n` +  \n          `Expected: ${this.utils.printExpected(expected)}\\n` +  \n          (matcherResult ? `Received: ${this.utils.printReceived(matcherResult.actual)}` : '');  \n  \n    return {  \n      message,  \n      pass,  \n      name: assertionName,  \n      expected,  \n      actual: matcherResult?.actual,  \n    };  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "You can also chain two locators together, for example to find a \"Save\" button inside a particular dialog:", "output": "const saveButton = page.getByRole('button', { name: 'Save' });  \n// ...  \nconst dialog = page.getByTestId('settings-dialog');  \nawait dialog.locator(saveButton).click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Use [expect(locator).toHaveText()](/docs/api/class-locatorassertions#locator-assertions-to-have-text) to ensure that the list has the text \"apple\", \"banana\" and \"orange\".", "output": "await expect(page  \n    .getByRole('listitem'))  \n    .toHaveText(['apple', 'banana', 'orange']);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example', async ({ page }) => {  \n  await expect(locator).toHaveText('hello', { timeout: 10_000 });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts", "type": "completion"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "component.spec.ts", "output": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('event', async ({ mount }) => {  \n  const component = await mount(Component, { on: { click() {} } });  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert(page.locator('text=Name'), 'should be logged in').toBeVisible();", "output": "await expect(page.locator('text=Name'), 'should be logged in').toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "Alternatively, in a worker fixture: | playwright/fixtures.ts", "output": "import { test as baseTest, request } from '@playwright/test';  \nimport fs from 'fs';  \nimport path from 'path';  \n  \nexport * from '@playwright/test';  \nexport const test = baseTest.extend<{}, { workerStorageState: string }>({  \n  // Use the same storage state for all tests in this worker.  \n  storageState: ({ workerStorageState }, use) => use(workerStorageState),  \n  \n  // Authenticate once per worker with a worker-scoped fixture.  \n  workerStorageState: [async ({}, use) => {  \n    // Use parallelIndex as a unique identifier for each worker.  \n    const id = test.info().parallelIndex;  \n    const fileName = path.resolve(test.info().project.outputDir, `.auth/${id}.json`);  \n  \n    if (fs.existsSync(fileName)) {  \n      // Reuse existing authentication state if any.  \n      await use(fileName);  \n      return;  \n    }  \n  \n    // Important: make sure we authenticate in a clean environment by unsetting storage state.  \n    const context = await request.newContext({ storageState: undefined });  \n  \n    // Acquire a unique account, for example create a new one.  \n    // Alternatively, you can have a list of precreated accounts for testing.  \n    // Make sure that accounts are unique, so that multiple team members  \n    // can run tests at the same time without interference.  \n    const account = await acquireAccount(id);  \n  \n    // Send authentication request. Replace with your own.  \n    await context.post('https://github.com/login', {  \n      form: {  \n        'user': 'user',  \n        'password': 'password'  \n      }  \n    });  \n  \n    await context.storageState({ path: fileName });  \n    await context.dispose();  \n    await use(fileName);  \n  }, { scope: 'worker' }],  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/auth", "type": "fixture"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "<div id=\"current-time\" data-testid=\"current-time\"></div>  \n<script>  \n  const renderTime = () => {  \n    document.getElementById('current-time').textContent =  \n        new Date().toLocaleString();  \n  };  \n  setInterval(renderTime, 1000);  \n</script>  \n\n\n\nawait page.clock.setFixedTime(new Date('2024-02-02T10:00:00'));  \nawait page.goto('http://localhost:3333');  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \nawait page.clock.setFixedTime(new Date('2024-02-02T10:30:00'));  \n// We know that the page has a timer that updates the time every second.  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:30:00 AM');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/clock", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Whether the meta viewport tag is taken into account and touch events are enabled. | playwright.config.ts", "input": "", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        // It is important to define the `isMobile` property after destructuring `devices`,  \n        // since devices also define the `isMobile` for that device.  \n        isMobile: false,  \n      },  \n    },  \n  ]  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "In this example the 'chromium with db' project depends on the 'setup db' project. We then create a setup test, stored at root level of your project (note that setup and teardown code must be defined as regular tests by calling [test()](/docs/api/class-test#test-call) function): | tests/global.setup.ts", "output": "import { test as setup } from '@playwright/test';  \n  \nsetup('create new database', async ({ }) => {  \n  console.log('creating new database...');  \n  // Initialize the database  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Create a Playwright test that demonstrates the page_object pattern.", "input": "Click to expand the code for the `TodoPage` | todo-page.ts", "output": "import type { Page, Locator } from '@playwright/test';  \n  \nexport class TodoPage {  \n  private readonly inputBox: Locator;  \n  private readonly todoItems: Locator;  \n  \n  constructor(public readonly page: Page) {  \n    this.inputBox = this.page.locator('input.new-todo');  \n    this.todoItems = this.page.getByTestId('todo-item');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://demo.playwright.dev/todomvc/');  \n  }  \n  \n  async addToDo(text: string) {  \n    await this.inputBox.fill(text);  \n    await this.inputBox.press('Enter');  \n  }  \n  \n  async remove(text: string) {  \n    const todo = this.todoItems.filter({ hasText: text });  \n    await todo.hover();  \n    await todo.getByLabel('Delete').click();  \n  }  \n  \n  async removeAll() {  \n    while ((await this.todoItems.count()) > 0) {  \n      await this.todoItems.first().hover();  \n      await this.todoItems.getByLabel('Delete').first().click();  \n    }  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \nimport jimp from 'jimp'; // image processing library  \n  \ntest('response interception', async ({ page }) => {  \n  await page.route('**/*.jpeg', async route => {  \n    const response = await page._request.fetch(route.request());  \n    const image = await jimp.read(await response.body());  \n    await image.blur(5);  \n    await route.fulfill({  \n      response,  \n      body: await image.getBufferAsync('image/jpeg'),  \n    });  \n  });  \n  const response = await page.navigate('https://playwright.dev');  \n  assert(response.status()).toBe(200);  \n});", "output": "import { test, expect } from '@playwright/test';  \nimport jimp from 'jimp'; // image processing library  \n  \ntest('response interception', async ({ page }) => {  \n  await page.route('**/*.jpeg', async route => {  \n    const response = await page._request.fetch(route.request());  \n    const image = await jimp.read(await response.body());  \n    await image.blur(5);  \n    await route.fulfill({  \n      response,  \n      body: await image.getBufferAsync('image/jpeg'),  \n    });  \n  });  \n  const response = await page.goto('https://playwright.dev');  \n  expect(response.status()).toBe(200);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  page: async ({ baseURL, page }, use) => {  \n    await page.navigate(baseURL);  \n    await use(page);  \n  },  \n});", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  page: async ({ baseURL, page }, use) => {  \n    await page.goto(baseURL);  \n    await use(page);  \n  },  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "New method [`expect.configure`](/docs/test-assertions#expectconfigure) to create pre-configured expect instance with its own defaults such as `timeout` and `soft`.", "output": "const slowExpect = expect.configure({ timeout: 10000 });  \nawait slowExpect(locator).toHaveText('Submit');  \n  \n// Always do soft assertions.  \nconst softExpect = expect.configure({ soft: true });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.getByTestId('directions').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: You can also annotate all tests in a group or provide multiple annotations:", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('report tests', {  \n  annotation: { type: 'category', description: 'report' },  \n}, () => {  \n  test('test report header', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('test full report', {  \n    annotation: [  \n      { type: 'issue', description: 'https://github.com/microsoft/playwright/issues/23180' },  \n      { type: 'performance', description: 'very slow test!' },  \n    ],  \n  }, async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations"}}
{"instruction": "Generate a Playwright test for the following scenario: Click to expand the code for the `TodoPage` | todo-page.ts", "input": "", "output": "import type { Page, Locator } from '@playwright/test';  \n  \nexport class TodoPage {  \n  private readonly inputBox: Locator;  \n  private readonly todoItems: Locator;  \n  \n  constructor(public readonly page: Page) {  \n    this.inputBox = this.page.locator('input.new-todo');  \n    this.todoItems = this.page.getByTestId('todo-item');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://demo.playwright.dev/todomvc/');  \n  }  \n  \n  async addToDo(text: string) {  \n    await this.inputBox.fill(text);  \n    await this.inputBox.press('Enter');  \n  }  \n  \n  async remove(text: string) {  \n    const todo = this.todoItems.filter({ hasText: text });  \n    await todo.hover();  \n    await todo.getByLabel('Delete').click();  \n  }  \n  \n  async removeAll() {  \n    while ((await this.todoItems.count()) > 0) {  \n      await this.todoItems.first().hover();  \n      await this.todoItems.getByLabel('Delete').first().click();  \n    }  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const buttons = page.locator('role=button');  \n// ...  \nconst submitButton = buttons.filter({ hasText: 'Submit' });  \nawait submitButton.click();", "output": "const buttons = page.locator('role=button');  \n// ...  \nconst submitButton = buttons.filter({ hasText: 'Submit' });  \nawait submitButton.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    // Setup project  \n    { name: 'setup', testMatch: /.*\\.setup\\.ts/ },  \n  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        // Use prepared auth state.  \n        storageState: 'playwright/.auth/user.json',  \n      },  \n      dependencies: ['setup'],  \n    },  \n  \n    {  \n      name: 'firefox',  \n      use: {  \n        ...devices['Desktop Firefox'],  \n        // Use prepared auth state.  \n        storageState: 'playwright/.auth/user.json',  \n      },  \n      dependencies: ['setup'],  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/auth", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Highlights\u200b | New role selectors that allow selecting elements by their [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) and [accessible name](https://w3c.github.io/accname/#dfn-accessible-name).", "output": "// Click a button with accessible name \"log in\"  \nawait page.locator('role=button[name=\"log in\"]').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.getByLabel('Upload directory').setInputFiles(path.join(__dirname, 'mydir'));", "output": "await page.getByLabel('Upload directory').setInputFiles(path.join(__dirname, 'mydir'));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: XPath and CSS selectors can be tied to the DOM structure or implementation. These selectors can break when the DOM structure changes. Long CSS or XPath chains below are an example of a **bad practice** that leads to unstable tests:", "input": "", "output": "await page.locator(  \n    '#tsf > div:nth-child(2) > div.A8SBwf > div.RNNXgb > div > div.a4bIc > input'  \n).click();  \n  \nawait page  \n    .locator('//*[@id=\"tsf\"]/div[2]/div[1]/div[1]/div/div[2]/input')  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    baseURL: process.env.STAGING === '1' ? 'http://staging.example.test/' : 'http://example.test/',  \n  }  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    baseURL: process.env.STAGING === '1' ? 'http://staging.example.test/' : 'http://example.test/',  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parameterize", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from './fixtures';  \n  \ntest('passes', async ({ database, page, a11y }) => {  \n  // use database and a11y fixtures.  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: UI mode and trace viewer mark network requests handled with [page.route()](/docs/api/class-page#page-route) and [browserContext.route()](/docs/api/class-browsercontext#browser-context-route) handlers, as well as those issued via the [API testing](/docs/api-testing): | New option `maskColor` for methods [page.screenshot()](/docs/api/class-page#page-screenshot), [locator.screenshot()](/docs/api/class-locator#locator-screenshot), [expect(page).toHaveScreenshot()](/docs/api/class-pageassertions#page-assertions-to-have-screenshot-1) and [expect(locator).toHaveScreenshot()](/docs/api/class-locatorassertions#locator-assertions-to-have-screenshot-1) to change default masking color:", "input": "", "output": "await page.goto('https://playwright.dev');  \nawait expect(page).toHaveScreenshot({  \n  mask: [page.locator('img')],  \n  maskColor: '#00FF00', // green  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "page.on('request', request => console.log(`Request sent: ${request.url()}`));  \nconst listener = request => console.log(`Request finished: ${request.url()}`);  \npage.on('requestfinished', listener);  \nawait page.goto('https://wikipedia.org');  \n  \npage.off('requestfinished', listener);  \nawait page.goto('https://www.openstreetmap.org/');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/events", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test('should not have any accessibility violations outside of rules with known issues', async ({  \n  page,  \n}) => {  \n  await page.goto('https://your-site.com/page-with-known-issues');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .disableRules(['duplicate-id'])  \n      .analyze();  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Legacy text locator has a few variations: | `text=Log in` \\- default matching is case-insensitive, trims whitespace and searches for a substring. For example, `text=Log` matches `<button>Log in</button>`.", "output": "await page.locator('text=Log in').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "navigation"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('two tests', () => {  \n  test('one', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('two', async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const data = 'some data';  \n// Pass |data| as a parameter.  \nconst result = await page.evaluate(data => {  \n  window.myApp.use(data);  \n}, data);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/evaluating", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Custom config options are a convenient way to parametrize projects with different values. Learn more in [this guide](/docs/test-parameterize#parameterized-projects). | Previously, any fixture introduced through [test.extend()](/docs/api/class-test#test-extend) could be overridden in the [testProject.use](/docs/api/class-testproject#test-project-use) config section. For example,", "input": "", "output": "// WRONG: THIS SNIPPET DOES NOT WORK SINCE v1.18.  \n  \n// fixtures.js  \nconst test = base.extend({  \n  myParameter: 'default',  \n});  \n  \n// playwright.config.js  \nmodule.exports = {  \n  use: {  \n    myParameter: 'value',  \n  },  \n};", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/test';  \n  \ntest.beforeEach(async ({ context }) => {  \n  // Runs before each test and signs in each page.  \n  await context.grantPermissions(['notifications'], { origin: 'https://skype.com' });  \n});  \n  \ntest('first', async ({ page }) => {  \n  // page has notifications permission for https://skype.com.  \n});  \n\n\n\nawait context.grantPermissions(['notifications'], { origin: 'https://skype.com' });", "output": "import { test } from '@playwright/test';  \n  \ntest.beforeEach(async ({ context }) => {  \n  // Runs before each test and signs in each page.  \n  await context.grantPermissions(['notifications'], { origin: 'https://skype.com' });  \n});  \n  \ntest('first', async ({ page }) => {  \n  // page has notifications permission for https://skype.com.  \n});  \n\n\n\nawait context.grantPermissions(['notifications'], { origin: 'https://skype.com' });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/emulation", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "UI mode and trace viewer mark network requests handled with [page.route()](/docs/api/class-page#page-route) and [browserContext.route()](/docs/api/class-browsercontext#browser-context-route) handlers, as well as those issued via the [API testing](/docs/api-testing): | New option `maskColor` for methods [page.screenshot()](/docs/api/class-page#page-screenshot), [locator.screenshot()](/docs/api/class-locator#locator-screenshot), [expect(page).toHaveScreenshot()](/docs/api/class-pageassertions#page-assertions-to-have-screenshot-1) and [expect(locator).toHaveScreenshot()](/docs/api/class-locatorassertions#locator-assertions-to-have-screenshot-1) to change default masking color:", "output": "await page.goto('https://playwright.dev');  \nawait expect(page).toHaveScreenshot({  \n  mask: [page.locator('img')],  \n  maskColor: '#00FF00', // green  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: Use the `webserver` property in your Playwright config to launch a development web server during the tests. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Run your local dev server before starting the tests  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n    stdout: 'ignore',  \n    stderr: 'pipe',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-webserver"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You can override options for a specific test file by using the `test.use()` method and passing in the options. For example to run tests with the French locale for a specific test:", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({ locale: 'fr-FR' });  \n  \ntest('example', async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-use-options"}}
{"instruction": "Generate a Playwright test for the following scenario: Select options\u200b | Selects one or multiple options in the `<select>` element with [locator.selectOption()](/docs/api/class-locator#locator-select-option). You can specify option `value`, or `label` to select. Multiple options can be selected.", "input": "", "output": "// Single selection matching the value or label  \nawait page.getByLabel('Choose a color').selectOption('blue');  \n  \n// Single selection matching the label  \nawait page.getByLabel('Choose a color').selectOption({ label: 'Blue' });  \n  \n// Multiple selected items  \nawait page.getByLabel('Choose multiple colors').selectOption(['red', 'green', 'blue']);", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Wait for popup window:", "output": "// Start waiting for popup before clicking. Note no await.  \nconst popupPromise = page.waitForEvent('popup');  \nawait page.getByText('open the popup').click();  \nconst popup = await popupPromise;  \nawait popup.goto('https://wikipedia.org');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/events", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['html', { open: 'never' }]],  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['html', { open: 'never' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "// \u2716 WRONG  \nawait expect(page  \n    .getByRole('listitem')  \n    .filter({ has: page.getByRole('list').getByText('Product 2') }))  \n    .toHaveCount(1);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const saveButton = page.getByRole('button', { name: 'Save' });  \n// ...  \nconst dialog = page.getByTestId('settings-dialog');  \nawait dialog.locator(saveButton).click();", "output": "const saveButton = page.getByRole('button', { name: 'Save' });  \n// ...  \nconst dialog = page.getByTestId('settings-dialog');  \nawait dialog.locator(saveButton).click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/test';  \n  \ntest.describe.configure({ mode: 'parallel' });  \n  \ntest('runs in parallel 1', async ({ page }) => { /* ... */ });  \ntest('runs in parallel 2', async ({ page }) => { /* ... */ });", "output": "import { test } from '@playwright/test';  \n  \ntest.describe.configure({ mode: 'parallel' });  \n  \ntest('runs in parallel 1', async ({ page }) => { /* ... */ });  \ntest('runs in parallel 2', async ({ page }) => { /* ... */ });", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/best-practices", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/experimental-ct-vue';  \nimport App from './App.vue';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<App />);  \n  await expect(component).toContainText('Learn Vue');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Select one file  \nawait page.getByLabel('Upload file').setInputFiles(path.join(__dirname, 'myfile.pdf'));  \n  \n// Select multiple files  \nawait page.getByLabel('Upload files').setInputFiles([  \n  path.join(__dirname, 'file1.txt'),  \n  path.join(__dirname, 'file2.txt'),  \n]);  \n  \n// Select a directory  \nawait page.getByLabel('Upload directory').setInputFiles(path.join(__dirname, 'mydir'));  \n  \n// Remove all the selected files  \nawait page.getByLabel('Upload file').setInputFiles([]);  \n  \n// Upload buffer from memory  \nawait page.getByLabel('Upload file').setInputFiles({  \n  name: 'file.txt',  \n  mimeType: 'text/plain',  \n  buffer: Buffer.from('this is test')  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/input", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Filter by text\u200b | Locators can be filtered by text with the [locator.filter()](/docs/api/class-locator#locator-filter) method. It will search for a particular string somewhere inside the element, possibly in a descendant element, case-insensitively. You can also pass a regular expression.", "output": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: 'Product 2' })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "navigation"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "If you would like to annotate your tests with something more substantial than a tag, you can do that when declaring a test. Annotations have a `type` and a `description` for more context and available in reporter API. Playwright's built-in HTML reporter shows all annotations, except those where `type` starts with `_` symbol. | For example, to annotate a test with an issue url:", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('test login page', {  \n  annotation: {  \n    type: 'issue',  \n    description: 'https://github.com/microsoft/playwright/issues/23180',  \n  },  \n}, async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations"}}
{"instruction": "Generate a Playwright test for the following scenario: See [managing browsers](/docs/browsers#managing-browser-binaries) for more options. | Once installed, you can import Playwright in a Node.js script, and launch any of the 3 browsers (`chromium`, `firefox` and `webkit`).", "input": "", "output": "const { chromium } = require('playwright');  \n  \n(async () => {  \n  const browser = await chromium.launch();  \n  // Create pages, interact with UI elements, assert values  \n  await browser.close();  \n})();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/library"}}
{"instruction": "Generate a Playwright test for the following scenario: expect.configure\u200b | You can create your own pre-configured `expect` instance to have its own defaults such as `timeout` and `soft`.", "input": "", "output": "const slowExpect = expect.configure({ timeout: 10000 });  \nawait slowExpect(locator).toHaveText('Submit');  \n  \n// Always do soft assertions.  \nconst softExpect = expect.configure({ soft: true });  \nawait softExpect(locator).toHaveText('Submit');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Filter tests by glob patterns or regular expressions. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Glob patterns or regular expressions to ignore test files.  \n  testIgnore: '*test-assets',  \n  \n  // Glob patterns or regular expressions that match test files.  \n  testMatch: '*todo-tests/*.spec.ts',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-configuration"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    locale: 'en-GB'  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    locale: 'en-GB'  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Note that all other reporters work on GitHub Actions as well, but do not provide annotations. Also, it is not recommended to use this annotation type if running your tests with a matrix strategy as the stack trace failures will multiply and obscure the GitHub file view. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // 'github' for GitHub Actions CI to generate annotations, plus a concise 'dot'  \n  // default 'list' when running locally  \n  reporter: process.env.CI ? 'github' : 'list',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Generate a Playwright test for the following scenario: With Playwright you can emulate a real device such as a mobile phone or tablet. See our [guide on projects](/docs/test-projects) for more info on emulating devices. You can also emulate the `\"geolocation\"`, `\"locale\"` and `\"timezone\"` for all tests or for a specific test as well as set the `\"permissions\"` to show notifications or change the `\"colorScheme\"`. See our [Emulation](/docs/emulation) guide to learn more. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Emulates `'prefers-colors-scheme'` media feature.  \n    colorScheme: 'dark',  \n  \n    // Context geolocation.  \n    geolocation: { longitude: 12.492507, latitude: 41.889938 },  \n  \n    // Emulates the user locale.  \n    locale: 'en-GB',  \n  \n    // Grants specified permissions to the browser context.  \n    permissions: ['geolocation'],  \n  \n    // Emulates the user timezone.  \n    timezoneId: 'Europe/Paris',  \n  \n    // Viewport used for all pages in the context.  \n    viewport: { width: 1280, height: 720 },  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// \u2716 WRONG  \nawait assert(page  \n    .getByRole('listitem')  \n    .filter({ has: page.getByRole('list').getByText('Product 2') }))  \n    .toHaveCount(1);", "output": "// \u2716 WRONG  \nawait expect(page  \n    .getByRole('listitem')  \n    .filter({ has: page.getByRole('list').getByText('Product 2') }))  \n    .toHaveCount(1);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    offline: true  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    offline: true  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/emulation", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "[electronApplication.on('console')](/docs/api/class-electronapplication#electron-application-event-console) event is emitted when Electron main process calls console API methods.", "output": "electronApp.on('console', async msg => {  \n  const values = [];  \n  for (const arg of msg.args())  \n    values.push(await arg.jsonValue());  \n  console.log(...values);  \n});  \nawait electronApp.evaluate(() => console.log('hello', 5, { foo: 'bar' }));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    trace: 'retain-on-first-failure',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "Error: should be logged in  \n  \n    Call log:  \n      - expect.toBeVisible with timeout 5000ms  \n      - waiting for \"getByText('Name')\"  \n  \n  \n      2 |  \n      3 | test('example test', async({ page }) => {  \n    > 4 |   await expect(page.getByText('Name'), 'should be logged in').toBeVisible();  \n        |                                                                  ^  \n      5 | });  \n      6 |", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    proxy: {  \n      server: 'http://myproxy.com:3128',  \n      username: 'usr',  \n      password: 'pwd'  \n    }  \n  }  \n});  \n\n\n\nconst browser = await chromium.launch({  \n  proxy: {  \n    server: 'http://myproxy.com:3128',  \n    username: 'usr',  \n    password: 'pwd'  \n  }  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "[New syntax](/docs/test-annotations#tag-tests) for adding tags to the tests (@-tokens in the test title are still supported):", "output": "test('test customer login', {  \n  tag: ['@fast', '@login'],  \n}, async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: 'dot',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  testDir: './tests',  \n  snapshotPathTemplate: '{testDir}/__screenshots__/{testFilePath}/{arg}{ext}',  \n});", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  testDir: './tests',  \n  snapshotPathTemplate: '{testDir}/__screenshots__/{testFilePath}/{arg}{ext}',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['blob', { outputFile: `./blob-report/report-${os.platform()}.zip` }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "component.spec.ts", "output": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('event', async ({ mount }) => {  \n  const component = await mount(Component, { on: { click() {} } });  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test for the following scenario: Sometimes you want to tag your tests as `@fast` or `@slow`, and then filter by tag in the test report. Or you might want to only run tests that have a certain tag. | To tag a test, either provide an additional details object when declaring a test, or add `@`-token to the test title. Note that tags must start with `@` symbol.", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('test login page', {  \n  tag: '@fast',  \n}, async ({ page }) => {  \n  // ...  \n});  \n  \ntest('test full report @slow', async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "New `caret` option in [page.screenshot()](/docs/api/class-page#page-screenshot) to control text caret. Defaults to `\"hide\"`. | New method `expect.poll` to wait for an arbitrary condition:", "output": "// Poll the method until it returns an expected result.  \nawait expect.poll(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  return response.status();  \n}).toBe(200);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.getByAltText('playwright logo').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: tests/example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  geolocation: { longitude: 41.890221, latitude: 12.492348 },  \n  permissions: ['geolocation'],  \n});  \n  \ntest('my test with geolocation', async ({ page }) => {  \n  // ...  \n});  \n\n\n\nconst context = await browser.newContext({  \n  geolocation: { longitude: 41.890221, latitude: 12.492348 },  \n  permissions: ['geolocation']  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Generate a Playwright test for the following scenario: Network events\u200b | You can monitor all the [Request](/docs/api/class-request \"Request\")s and [Response](/docs/api/class-response \"Response\")s:", "input": "", "output": "// Subscribe to 'request' and 'response' events.  \npage.on('request', request => console.log('>>', request.method(), request.url()));  \npage.on('response', response => console.log('<<', response.status(), response.url()));  \n  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Create a Playwright test that demonstrates the form_interaction pattern.", "input": "Modify responses\u200b | To modify a response use [APIRequestContext](/docs/api/class-apirequestcontext \"APIRequestContext\") to get the original response and then pass the response to [route.fulfill()](/docs/api/class-route#route-fulfill). You can override individual fields on the response via options:", "output": "await page.route('**/title.html', async route => {  \n  // Fetch original response.  \n  const response = await route.fetch();  \n  // Add a prefix to the title.  \n  let body = await response.text();  \n  body = body.replace('<title>', '<title>My prefix:');  \n  await route.fulfill({  \n    // Pass all fields from the response.  \n    response,  \n    // Override response body.  \n    body,  \n    // Force content type to be html.  \n    headers: {  \n      ...response.headers(),  \n      'content-type': 'text/html'  \n    }  \n  });  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect(page.locator('body')).toMatchAriaSnapshot(`  \n  - heading \"title\"  \n`);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/aria-snapshots", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    httpCredentials: {  \n      username: 'bill',  \n      password: 'pa55w0rd',  \n    }  \n  }  \n});  \n\n\n\nconst context = await browser.newContext({  \n  httpCredentials: {  \n    username: 'bill',  \n    password: 'pa55w0rd',  \n  },  \n});  \nconst page = await context.newPage();  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network", "type": "navigation"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "`#nav-bar :text(\"Home\")` \\- the `:text()` pseudo-class matches the smallest element containing specified text. Matching is case-insensitive, trims whitespace and searches for a substring. | For example, this will find an element with text \"Home\" somewhere inside the `#nav-bar` element:", "output": "await page.locator('#nav-bar :text(\"Home\")').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('unmount', async ({ mount }) => {  \n  const component = await mount(<Component/>);  \n  await component.unmount();  \n});", "output": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('unmount', async ({ mount }) => {  \n  const component = await mount(<Component/>);  \n  await component.unmount();  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \nimport path from 'path';  \n  \ntest.beforeEach(async ({ page }) => {  \n  // Add script for every test in the beforeEach hook.  \n  // Make sure to correctly resolve the script path.  \n  await page.addInitScript({ path: path.resolve(__dirname, '../mocks/preload.js') });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/evaluating", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { handlers } from '@src/mocks/handlers';  \n  \ntest.beforeEach(async ({ router }) => {  \n  // install common handlers before each test  \n  await router.use(...handlers);  \n});  \n  \ntest('example test', async ({ mount }) => {  \n  // test as usual, your handlers are active  \n  // ...  \n});", "output": "import { handlers } from '@src/mocks/handlers';  \n  \ntest.beforeEach(async ({ router }) => {  \n  // install common handlers before each test  \n  await router.use(...handlers);  \n});  \n  \ntest('example test', async ({ mount }) => {  \n  // test as usual, your handlers are active  \n  // ...  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Look for test files in the \"tests\" directory, relative to this configuration file.  \n  testDir: 'tests',  \n  \n  // Run all tests in parallel.  \n  fullyParallel: true,  \n  \n  // Fail the build on CI if you accidentally left test.only in the source code.  \n  forbidOnly: !!process.env.CI,  \n  \n  // Retry on CI only.  \n  retries: process.env.CI ? 2 : 0,  \n  \n  // Opt out of parallel tests on CI.  \n  workers: process.env.CI ? 1 : undefined,  \n  \n  // Reporter to use  \n  reporter: 'html',  \n  \n  use: {  \n    // Base URL to use in actions like `await page.goto('/')`.  \n    baseURL: 'http://127.0.0.1:3000',  \n  \n    // Collect trace when retrying the failed test.  \n    trace: 'on-first-retry',  \n  },  \n  // Configure projects for major browsers.  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n    },  \n  ],  \n  // Run your local dev server before starting the tests.  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n  },  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-configuration", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Run tests on different browsers\u200b | Playwright can run your tests in multiple browsers and configurations by setting up **projects** in the config. You can also add [different options](/docs/test-configuration) for each project.", "input": "", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    /* Test against desktop browsers */  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n    },  \n    {  \n      name: 'firefox',  \n      use: { ...devices['Desktop Firefox'] },  \n    },  \n    {  \n      name: 'webkit',  \n      use: { ...devices['Desktop Safari'] },  \n    },  \n    /* Test against mobile viewports. */  \n    {  \n      name: 'Mobile Chrome',  \n      use: { ...devices['Pixel 5'] },  \n    },  \n    {  \n      name: 'Mobile Safari',  \n      use: { ...devices['iPhone 12'] },  \n    },  \n    /* Test against branded browsers. */  \n    {  \n      name: 'Google Chrome',  \n      use: { ...devices['Desktop Chrome'], channel: 'chrome' }, // or 'chrome-beta'  \n    },  \n    {  \n      name: 'Microsoft Edge',  \n      use: { ...devices['Desktop Edge'], channel: 'msedge' }, // or 'msedge-dev'  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/browsers"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "// \ud83d\udc4d  \nawait expect(page.getByText('welcome')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/best-practices", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "This will find both buttons and throw a [strictness](/docs/locators#strictness) violation error:", "output": "await page.locator('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test('test full report', {  \n  annotation: [  \n    { type: 'issue', description: 'https://github.com/microsoft/playwright/issues/23180' },  \n    { type: 'docs', description: 'https://playwright.dev/docs/test-annotations#tag-tests' },  \n  ],  \n}, async ({ page }) => {  \n  // ...  \n});", "output": "test('test full report', {  \n  annotation: [  \n    { type: 'issue', description: 'https://github.com/microsoft/playwright/issues/23180' },  \n    { type: 'docs', description: 'https://playwright.dev/docs/test-annotations#tag-tests' },  \n  ],  \n}, async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "You can opt into the step rendering via passing the following config option: | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['list', { printSteps: true }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/experimental-ct-react';  \nimport type { HooksConfig } from '../playwright';  \nimport { ProductsPage } from './pages/ProductsPage';  \n  \ntest('configure routing through hooks config', async ({ page, mount }) => {  \n  const component = await mount<HooksConfig>(<ProductsPage />, {  \n    hooksConfig: { enableRouting: true },  \n  });  \n  await assert(component.getByRole('link')).toHaveAttribute('href', '/products/42');  \n});", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport type { HooksConfig } from '../playwright';  \nimport { ProductsPage } from './pages/ProductsPage';  \n  \ntest('configure routing through hooks config', async ({ page, mount }) => {  \n  const component = await mount<HooksConfig>(<ProductsPage />, {  \n    hooksConfig: { enableRouting: true },  \n  });  \n  await expect(component.getByRole('link')).toHaveAttribute('href', '/products/42');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: You can set global timeout in the config. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  globalTimeout: 3_600_000,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-timeouts"}}
{"instruction": "Generate a Playwright test for the following scenario: If your tests need to run behind a proxy, you can specify this in the config and the `request` fixture will pick it up automatically: | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    proxy: {  \n      server: 'http://my-proxy:8080',  \n      username: 'user',  \n      password: 'secret'  \n    },  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/api-testing"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    video: 'on-first-retry',  \n  },  \n});  \n\n\n\nconst context = await browser.newContext({ recordVideo: { dir: 'videos/' } });  \n// Make sure to await close, so that videos are saved.  \nawait context.close();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/videos"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['html', { outputFolder: 'my-report' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: You can use multiple reporters at the same time. For example you can use `'list'` for nice terminal output and `'json'` to get a comprehensive json file with the test results. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [  \n    ['list'],  \n    ['json', {  outputFile: 'test-results.json' }]  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.locator('button').click();", "output": "await page.locator('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.getByLabel('User Name').fill('John');  \n  \nawait page.getByLabel('Password').fill('secret-password');  \n  \nawait page.getByRole('button', { name: 'Sign in' }).click();  \n  \nawait assert(page.getByText('Welcome, John!')).toBeVisible();", "output": "await page.getByLabel('User Name').fill('John');  \n  \nawait page.getByLabel('Password').fill('secret-password');  \n  \nawait page.getByRole('button', { name: 'Sign in' }).click();  \n  \nawait expect(page.getByText('Welcome, John!')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest('example', async ({ page }) => {  \n  await assert(locator).toHaveText('hello', { timeout: 10_000 });  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example', async ({ page }) => {  \n  await expect(locator).toHaveText('hello', { timeout: 10_000 });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const product = page.getByRole('listitem').filter({ hasText: 'Product 2' });  \n  \nawait product.getByRole('button', { name: 'Add to cart' }).click();  \n  \nawait expect(product).toHaveCount(1);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "If you'd like to share the default value among all the tests in the project, you can specify it in the playwright config, either globally or per project: | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  expect: {  \n    toHaveScreenshot: { maxDiffPixels: 100 },  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Overriding fixtures\u200b | In addition to creating your own fixtures, you can also override existing fixtures to fit your needs. Consider the following example which overrides the `page` fixture by automatically navigating to some `baseURL`:", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  page: async ({ baseURL, page }, use) => {  \n    await page.goto(baseURL);  \n    await use(page);  \n  },  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Variations\u200b | Wait for [Response](/docs/api/class-response \"Response\")s with [page.waitForResponse()](/docs/api/class-page#page-wait-for-response)", "output": "// Use a RegExp. Note no await.  \nconst responsePromise = page.waitForResponse(/\\.jpeg$/);  \nawait page.getByText('Update').click();  \nconst response = await responsePromise;  \n  \n// Use a predicate taking a Response object. Note no await.  \nconst responsePromise = page.waitForResponse(response => response.url().includes(token));  \nawait page.getByText('Update').click();  \nconst response = await responsePromise;", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as base, chromium, type BrowserContext } from '@playwright/test';  \nimport path from 'path';  \n  \nexport const test = base.extend<{  \n  context: BrowserContext;  \n  extensionId: string;  \n}>({  \n  context: async ({ }, use) => {  \n    const pathToExtension = path.join(__dirname, 'my-extension');  \n    const context = await chromium.launchPersistentContext('', {  \n      headless: false,  \n      args: [  \n        `--disable-extensions-except=${pathToExtension}`,  \n        `--load-extension=${pathToExtension}`,  \n      ],  \n    });  \n    await use(context);  \n    await context.close();  \n  },  \n  extensionId: async ({ context }, use) => {  \n    /*  \n    // for manifest v2:  \n    let [background] = context.backgroundPages()  \n    if (!background)  \n      background = await context.waitForEvent('backgroundpage')  \n    */  \n  \n    // for manifest v3:  \n    let [background] = context.serviceWorkers();  \n    if (!background)  \n      background = await context.waitForEvent('serviceworker');  \n  \n    const extensionId = background.url().split('/')[2];  \n    await use(extensionId);  \n  },  \n});  \nexport const expect = test.expect;", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/chrome-extensions", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.getByRole('button').dispatchEvent('click');", "output": "await page.getByRole('button').dispatchEvent('click');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  retries: 1,  \n  use: {  \n    trace: 'on-first-retry',  \n  },  \n});  \n\n\n\nconst browser = await chromium.launch();  \nconst context = await browser.newContext();  \n  \n// Start tracing before creating / navigating a page.  \nawait context.tracing.start({ screenshots: true, snapshots: true });  \n  \nconst page = await context.newPage();  \nawait page.goto('https://playwright.dev');  \n  \n// Stop tracing and export it into a zip archive.  \nawait context.tracing.stop({ path: 'trace.zip' });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/trace-viewer", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest.use({  \n  geolocation: { longitude: 41.890221, latitude: 12.492348 },  \n  permissions: ['geolocation'],  \n});  \n  \ntest('my test with geolocation', async ({ page }) => {  \n  // ...  \n});  \n\n\n\nconst context = await browser.newContext({  \n  geolocation: { longitude: 41.890221, latitude: 12.492348 },  \n  permissions: ['geolocation']  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  geolocation: { longitude: 41.890221, latitude: 12.492348 },  \n  permissions: ['geolocation'],  \n});  \n  \ntest('my test with geolocation', async ({ page }) => {  \n  // ...  \n});  \n\n\n\nconst context = await browser.newContext({  \n  geolocation: { longitude: 41.890221, latitude: 12.492348 },  \n  permissions: ['geolocation']  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You can put your tests in helper functions in multiple files. Consider the following example where tests are not defined directly in the file, but rather in a wrapper function. | feature-a.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \nexport default function createTests() {  \n  test('feature-a example test', async ({ page }) => {  \n    // ... test goes here  \n  });  \n}", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "// Create a page.  \nconst page = await context.newPage();  \n  \n// Navigate explicitly, similar to entering a URL in the browser.  \nawait page.goto('http://example.com');  \n// Fill an input.  \nawait page.locator('#search').fill('query');  \n  \n// Navigate implicitly by clicking a link.  \nawait page.locator('#submit').click();  \n// Expect a new url.  \nconsole.log(page.url());", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/pages", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: './my-awesome-reporter.ts',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "* disables animations\n* uses CSS scale option\n\n    await page.goto('https://playwright.dev');  \nawait expect(page).toHaveScreenshot();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Start waiting for download before clicking. Note no await.  \nconst downloadPromise = page.waitForEvent('download');  \nawait page.getByText('Download file').click();  \nconst download = await downloadPromise;  \n  \n// Wait for the download process to complete and save the downloaded file somewhere.  \nawait download.saveAs('/path/to/save/at/' + download.suggestedFilename());", "output": "// Start waiting for download before clicking. Note no await.  \nconst downloadPromise = page.waitForEvent('download');  \nawait page.getByText('Download file').click();  \nconst download = await downloadPromise;  \n  \n// Wait for the download process to complete and save the downloaded file somewhere.  \nawait download.saveAs('/path/to/save/at/' + download.suggestedFilename());", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/downloads", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  await page.navigate('/');  \n  // You are signed in!  \n});", "output": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  await page.goto('/');  \n  // You are signed in!  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'setup',  \n      testMatch: /global.setup\\.ts/,  \n      teardown: 'teardown',  \n    },  \n    {  \n      name: 'teardown',  \n      testMatch: /global.teardown\\.ts/,  \n    },  \n    {  \n      name: 'chromium',  \n      use: devices['Desktop Chrome'],  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'firefox',  \n      use: devices['Desktop Firefox'],  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'webkit',  \n      use: devices['Desktop Safari'],  \n      dependencies: ['setup'],  \n    },  \n  ],  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'setup',  \n      testMatch: /global.setup\\.ts/,  \n      teardown: 'teardown',  \n    },  \n    {  \n      name: 'teardown',  \n      testMatch: /global.teardown\\.ts/,  \n    },  \n    {  \n      name: 'chromium',  \n      use: devices['Desktop Chrome'],  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'firefox',  \n      use: devices['Desktop Firefox'],  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'webkit',  \n      use: devices['Desktop Safari'],  \n      dependencies: ['setup'],  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Remove a header from all requests.  \ntest.beforeEach(async ({ page }) => {  \n  await page.route('**/*', async route => {  \n    const headers = await route.request().allHeaders();  \n    delete headers['if-none-match'];  \n    await route.fallback({ headers });  \n  });  \n});  \n  \ntest('should work', async ({ page }) => {  \n  await page.route('**/*', async route => {  \n    if (route.request().resourceType() === 'image')  \n      await route.abort();  \n    else  \n      await route.fallback();  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Most of the time, scripts will need to wait for a particular event to happen. Below are some of the typical event awaiting patterns. | Wait for a request with the specified url using [page.waitForRequest()](/docs/api/class-page#page-wait-for-request):", "input": "", "output": "// Start waiting for request before goto. Note no await.  \nconst requestPromise = page.waitForRequest('**/*logo*.png');  \nawait page.goto('https://wikipedia.org');  \nconst request = await requestPromise;  \nconsole.log(request.url());", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/events"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/experimental-ct-vue';  \nimport App from './App.vue';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<App />);  \n  await assert(component).toContainText('Learn Vue');  \n});", "output": "import { test, expect } from '@playwright/experimental-ct-vue';  \nimport App from './App.vue';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<App />);  \n  await expect(component).toContainText('Learn Vue');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    locale: 'en-GB'  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { mergeTests, mergeExpects } from '@playwright/test';  \nimport { test as dbTest, expect as dbExpect } from 'database-test-utils';  \nimport { test as a11yTest, expect as a11yExpect } from 'a11y-test-utils';  \n  \nexport const expect = mergeExpects(dbExpect, a11yExpect);  \nexport const test = mergeTests(dbTest, a11yTest);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    // All requests we send go to this API endpoint.  \n    baseURL: 'https://api.github.com',  \n    extraHTTPHeaders: {  \n      // We set this header per GitHub guidelines.  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add authorization token to all requests.  \n      // Assuming personal access token available in the environment.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    },  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/api-testing", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Read more in [our documentation](/docs/locators#locate-by-role). | New [locator.filter()](/docs/api/class-locator#locator-filter) API to filter an existing locator", "output": "const buttons = page.locator('role=button');  \n// ...  \nconst submitButton = buttons.filter({ hasText: 'Submit' });  \nawait submitButton.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "At any point during test execution, you can check whether there were any soft assertion failures:", "output": "// Make a few checks that will not stop the test when failed...  \nawait expect.soft(page.getByTestId('status')).toHaveText('Success');  \nawait expect.soft(page.getByTestId('eta')).toHaveText('1 day');  \n  \n// Avoid running further if there were soft assertion failures.  \nexpect(test.info().errors).toHaveLength(0);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const buttons = page.locator('role=button');  \n// ...  \nconst submitButton = buttons.filter({ hasText: 'Submit' });  \nawait submitButton.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the form_interaction pattern.", "input": "You can fill the input after locating it by the label text:", "output": "await page.getByLabel('Password').fill('secret');", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('slow test', async ({ page }) => {  \n  test.slow(); // Easy way to triple the default timeout  \n  // ...  \n});  \n  \ntest('very slow test', async ({ page }) => {  \n  test.setTimeout(120_000);  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  testDir: './tests',  \n  // ...  \n  projects: [  \n    {  \n      name: 'setup db',  \n      testMatch: /global\\.setup\\.ts/,  \n    },  \n    {  \n      name: 'chromium with db',  \n      use: { ...devices['Desktop Chrome'] },  \n      dependencies: ['setup db'],  \n    },  \n  ]  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Variations\u200b | Set up route on the entire browser context with [browserContext.route()](/docs/api/class-browsercontext#browser-context-route) or page with [page.route()](/docs/api/class-page#page-route). It will apply to popup windows and opened links.", "input": "", "output": "await browserContext.route('**/api/login', route => route.fulfill({  \n  status: 200,  \n  body: 'accept',  \n}));  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Generate a Playwright test for the following scenario: You can opt into the step rendering via passing the following config option: | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['list', { printSteps: true }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Configure mock API before each test.  \ntest.beforeEach(async ({ page }) => {  \n  await page.addInitScript(() => {  \n    const mockBattery = {  \n      level: 0.90,  \n      charging: true,  \n      chargingTime: 1800, // seconds  \n      dischargingTime: Infinity,  \n      addEventListener: () => { }  \n    };  \n    // Override the method to always return mock battery info.  \n    window.navigator.getBattery = async () => mockBattery;  \n  });  \n});  \n  \ntest('show battery status', async ({ page }) => {  \n  await page.goto('/');  \n  await expect(page.locator('.battery-percentage')).toHaveText('90%');  \n  await expect(page.locator('.battery-status')).toHaveText('Adapter');  \n  await expect(page.locator('.battery-fully')).toHaveText('00:30');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock-browser-apis", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest('basic test', async ({ page }) => {  \n  await page.navigate('https://playwright.dev/');  \n  \n  await assert(page).toHaveTitle(/Playwright/);  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('basic test', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  \n  await expect(page).toHaveTitle(/Playwright/);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: At any point during test execution, you can check whether there were any soft assertion failures:", "input": "", "output": "// Make a few checks that will not stop the test when failed...  \nawait expect.soft(page.getByTestId('status')).toHaveText('Success');  \nawait expect.soft(page.getByTestId('eta')).toHaveText('1 day');  \n  \n// Avoid running further if there were soft assertion failures.  \nexpect(test.info().errors).toHaveLength(0);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "test(\"mocks a fruit and doesn't call api\", async ({ page }) => {  \n  // Mock the api call before navigating  \n  await page.route('*/**/api/v1/fruits', async route => {  \n    const json = [{ name: 'Strawberry', id: 21 }];  \n    await route.fulfill({ json });  \n  });  \n  // Go to the page  \n  await page.goto('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the Strawberry fruit is visible  \n  await expect(page.getByText('Strawberry')).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: Mock WebSockets\u200b | The following code will intercept WebSocket connections and mock entire communcation over the WebSocket, instead of connecting to the server. This example responds to a `\"request\"` with a `\"response\"`.", "input": "", "output": "await page.routeWebSocket('wss://example.com/ws', ws => {  \n  ws.onMessage(message => {  \n    if (message === 'request')  \n      ws.send('response');  \n  });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/mock"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('callback', async ({ mount }) => {  \n  const component = await mount(<Component onClick={() => {}} />);  \n});", "output": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('callback', async ({ mount }) => {  \n  const component = await mount(<Component onClick={() => {}} />);  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: [APIRequestContext](/docs/api/class-apirequestcontext \"APIRequestContext\") now accepts [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) and `string` as query parameters\u200b | You can now pass [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) and `string` as query parameters to [APIRequestContext](/docs/api/class-apirequestcontext \"APIRequestContext\"):", "input": "", "output": "test('query params', async ({ request }) => {  \n  const searchParams = new URLSearchParams();  \n  searchParams.set('userId', 1);  \n  const response = await request.get(  \n      'https://jsonplaceholder.typicode.com/posts',  \n      {  \n        params: searchParams // or as a string: 'userId=1'  \n      }  \n  );  \n  // ...  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Here is an example that defines a common timeout and two projects. The \"Smoke\" project runs a small subset of tests without retries, and \"Default\" project runs all other tests with retries. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  timeout: 60000, // Timeout is shared between all tests.  \n  projects: [  \n    {  \n      name: 'Smoke',  \n      testMatch: /.*smoke.spec.ts/,  \n      retries: 0,  \n    },  \n    {  \n      name: 'Default',  \n      testIgnore: /.*smoke.spec.ts/,  \n      retries: 2,  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-projects"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test('skip this test', async ({ page, browserName }) => {  \n  test.skip(browserName === 'firefox', 'Still working on it');  \n});", "output": "test('skip this test', async ({ page, browserName }) => {  \n  test.skip(browserName === 'firefox', 'Still working on it');  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-annotations", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as base, assert } from '@playwright/test';  \n  \nconst test = base.extend<{ slowFixture: string }>({  \n  slowFixture: [async ({}, use) => {  \n    // ... perform a slow operation ...  \n    await use('hello');  \n  }, { timeout: 60000 }]  \n});  \n  \ntest('example test', async ({ slowFixture }) => {  \n  // ...  \n});", "output": "import { test as base, expect } from '@playwright/test';  \n  \nconst test = base.extend<{ slowFixture: string }>({  \n  slowFixture: [async ({}, use) => {  \n    // ... perform a slow operation ...  \n    await use('hello');  \n  }, { timeout: 60000 }]  \n});  \n  \ntest('example test', async ({ slowFixture }) => {  \n  // ...  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "page.on('dialog', dialog => console.log(dialog.message()));  \nawait page.getByRole('button').click(); // Will hang here", "output": "page.on('dialog', dialog => console.log(dialog.message()));  \nawait page.getByRole('button').click(); // Will hang here", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/dialogs", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import type { Page } from '@playwright/test';  \n  \nexport class SettingsPage {  \n  constructor(public readonly page: Page) {  \n  }  \n  \n  async switchToDarkMode() {  \n    // ...  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('menu', async ({ page }) => {  \n  // Your test that depends on the database  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: [`visible`](/docs/other-locators#css-matching-only-visible-elements) selector engine is equivalent to the `:visible` pseudo class, but could be combined with other selector engines.", "input": "", "output": "// select the first button among all buttons  \nawait button.click('button >> nth=0');  \n// or if you are using locators, you can use first(), nth() and last()  \nawait page.locator('button').first().click();  \n  \n// click a visible button  \nawait button.click('button >> visible=true');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "tests/example.spec.ts", "output": "// Import test with our new fixtures.  \nimport { test, expect } from '../playwright/fixtures';  \n  \n// Use adminPage and userPage fixtures in the test.  \ntest('admin and user', async ({ adminPage, userPage }) => {  \n  // ... interact with both adminPage and userPage ...  \n  await expect(adminPage.greeting).toHaveText('Welcome, Admin');  \n  await expect(userPage.greeting).toHaveText('Welcome, User');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/auth", "type": "fixture"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "To include _all_ of the scan results as part of your test results for debugging purposes, you can add the scan results as a test attachment with [`testInfo.attach()`](/docs/api/class-testinfo#test-info-attach). [Reporters](/docs/test-reporters) can then embed or link the full results as part of your test output. | The following example demonstrates attaching scan results to a test:", "output": "test('example with attachment', async ({ page }, testInfo) => {  \n  await page.goto('https://your-site.com/');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page }).analyze();  \n  \n  await testInfo.attach('accessibility-scan-results', {  \n    body: JSON.stringify(accessibilityScanResults, null, 2),  \n    contentType: 'application/json'  \n  });  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect(page.getByText('Welcome, John')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "// Setup the handler.  \nawait page.addLocatorHandler(  \n    page.getByRole('heading', { name: 'Hej! You are in control of your cookies.' }),  \n    async () => {  \n      await page.getByRole('button', { name: 'Accept all' }).click();  \n    });  \n// Write the test as usual.  \nawait page.goto('https://www.ikea.com/');  \nawait page.getByRole('link', { name: 'Collection of blue and white' }).click();  \nawait expect(page.getByRole('heading', { name: 'Light and easy' })).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: Playwright now allows you to supply client-side certificates, so that server can verify them, as specified by TLS Client Authentication. | The following snippet sets up a client certificate for `https://example.com`:", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // ...  \n  use: {  \n    clientCertificates: [{  \n      origin: 'https://example.com',  \n      certPath: './cert.pem',  \n      keyPath: './key.pem',  \n      passphrase: 'mysecretpassword',  \n    }],  \n  },  \n  // ...  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: Below we'll create an `account` fixture that will be shared by all tests in the same worker, and override the `page` fixture to login into this account for each test. To generate unique accounts, we'll use the [workerInfo.workerIndex](/docs/api/class-workerinfo#worker-info-worker-index) that is available to any test or fixture. Note the tuple-like syntax for the worker fixture - we have to pass `{scope: 'worker'}` so that test runner sets up this fixture once per worker. | my-test.ts", "input": "", "output": "import { test as base } from '@playwright/test';  \n  \ntype Account = {  \n  username: string;  \n  password: string;  \n};  \n  \n// Note that we pass worker fixture types as a second template parameter.  \nexport const test = base.extend<{}, { account: Account }>({  \n  account: [async ({ browser }, use, workerInfo) => {  \n    // Unique username.  \n    const username = 'user' + workerInfo.workerIndex;  \n    const password = 'verysecure';  \n  \n    // Create the account with Playwright.  \n    const page = await browser.newPage();  \n    await page.goto('/signup');  \n    await page.getByLabel('User Name').fill(username);  \n    await page.getByLabel('Password').fill(password);  \n    await page.getByText('Sign up').click();  \n    // Make sure everything is ok.  \n    await expect(page.getByTestId('result')).toHaveText('Success');  \n    // Do not forget to cleanup.  \n    await page.close();  \n  \n    // Use the account value.  \n    await use({ username, password });  \n  }, { scope: 'worker' }],  \n  \n  page: async ({ page, account }, use) => {  \n    // Sign in with our account.  \n    const { username, password } = account;  \n    await page.goto('/signin');  \n    await page.getByLabel('User Name').fill(username);  \n    await page.getByLabel('Password').fill(password);  \n    await page.getByText('Sign in').click();  \n    await expect(page.getByTestId('userinfo')).toHaveText(username);  \n  \n    // Use signed-in page in the test.  \n    await use(page);  \n  },  \n});  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const product = page.getByRole('listitem').filter({ hasText: 'Product 2' });", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/best-practices", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/experimental-ct-svelte';  \nimport App from './App.svelte';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(App);  \n  await expect(component).toContainText('Learn Svelte');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the form_interaction pattern.", "input": "**Array as an option value** | If the value of your option is an array, for example `[{ name: 'Alice' }, { name: 'Bob' }]`, you'll need to wrap it into an extra array when providing the value. This is best illustrated with an example.", "output": "type Person = { name: string };  \nconst test = base.extend<{ persons: Person[] }>({  \n  // Declare the option, default value is an empty array.  \n  persons: [[], { option: true }],  \n});  \n  \n// Option value is an array of persons.  \nconst actualPersons = [{ name: 'Alice' }, { name: 'Bob' }];  \ntest.use({  \n  // CORRECT: Wrap the value into an array and pass the scope.  \n  persons: [actualPersons, { scope: 'test' }],  \n});  \n  \ntest.use({  \n  // WRONG: passing an array value directly will not work.  \n  persons: actualPersons,  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "For more control, you can specify reporters programmatically in the [configuration file](/docs/test-configuration). | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: 'line',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n    },  \n    {  \n      name: 'firefox',  \n      use: { ...devices['Desktop Firefox'] },  \n    },  \n    {  \n      name: 'webkit',  \n      use: { ...devices['Desktop Safari'] },  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/best-practices", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Instead, create a _fingerprint_ of the violation(s) in question that contains only enough information to uniquely identify the issue, and use a snapshot of the fingerprint:", "input": "", "output": "// This is less fragile than snapshotting the entire violations array.  \nexpect(violationFingerprints(accessibilityScanResults)).toMatchSnapshot();  \n  \n// my-test-utils.js  \nfunction violationFingerprints(accessibilityScanResults) {  \n  const violationFingerprints = accessibilityScanResults.violations.map(violation => ({  \n    rule: violation.id,  \n    // These are CSS selectors which uniquely identify each element with  \n    // a violation of the rule in question.  \n    targets: violation.nodes.map(node => node.target),  \n  }));  \n  \n  return JSON.stringify(violationFingerprints, null, 2);  \n}", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const banana = await page.getByRole('listitem').nth(1);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Simple version produces a single character. This character is case-sensitive, so `\"a\"` and `\"A\"` will produce different results.", "input": "", "output": "// <input id=name>  \nawait page.locator('#name').press('Shift+A');  \n  \n// <input id=name>  \nawait page.locator('#name').press('Shift+ArrowLeft');", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Generate a Playwright test for the following scenario: By default, tests in a single file are run in order. If you have many independent tests in a single file, you might want to run them in parallel with [test.describe.configure()](/docs/api/class-test#test-describe-configure). | Note that parallel tests are executed in separate worker processes and cannot share any state or global variables. Each test executes all relevant hooks just for itself, including `beforeAll` and `afterAll`.", "input": "", "output": "import { test } from '@playwright/test';  \n  \ntest.describe.configure({ mode: 'parallel' });  \n  \ntest('runs in parallel 1', async ({ page }) => { /* ... */ });  \ntest('runs in parallel 2', async ({ page }) => { /* ... */ });", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Generate a Playwright test for the following scenario: New method [frameLocator.owner()](/docs/api/class-framelocator#frame-locator-owner) converts a [FrameLocator](/docs/api/class-framelocator \"FrameLocator\") object to a [Locator](/docs/api/class-locator \"Locator\"). This can be useful when you have a [FrameLocator](/docs/api/class-framelocator \"FrameLocator\") object obtained somewhere, and later on would like to interact with the `iframe` element.", "input": "", "output": "const frameLocator = page.frameLocator('iframe[name=\"embedded\"]');  \n// ...  \nconst locator = frameLocator.owner();  \nawait expect(locator).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "First we add the [testProject.teardown](/docs/api/class-testproject#test-project-teardown) property to our setup project with the name 'cleanup db' which is the name we gave to our teardown project in the previous step: | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  testDir: './tests',  \n  // ...  \n  projects: [  \n    {  \n      name: 'setup db',  \n      testMatch: /global\\.setup\\.ts/,  \n      teardown: 'cleanup db',  \n    },  \n    {  \n      name: 'cleanup db',  \n      testMatch: /global\\.teardown\\.ts/,  \n    },  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n      dependencies: ['setup db'],  \n    },  \n  ]  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "New method [page.addLocatorHandler()](/docs/api/class-page#page-add-locator-handler) registers a callback that will be invoked when specified element becomes visible and may block Playwright actions. The callback can get rid of the overlay. Here is an example that closes a cookie dialog when it appears:", "output": "// Setup the handler.  \nawait page.addLocatorHandler(  \n    page.getByRole('heading', { name: 'Hej! You are in control of your cookies.' }),  \n    async () => {  \n      await page.getByRole('button', { name: 'Accept all' }).click();  \n    });  \n// Write the test as usual.  \nawait page.goto('https://www.ikea.com/');  \nawait page.getByRole('link', { name: 'Collection of blue and white' }).click();  \nawait expect(page.getByRole('heading', { name: 'Light and easy' })).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: Selector ambiguity is a common problem in automation testing. **\"strict\" mode** ensures that your selector points to a single element and throws otherwise. | Pass `strict: true` into your action calls to opt in.", "input": "", "output": "// This will throw if you have more than one button!  \nawait page.click('button', { strict: true });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "To avoid running `beforeEach` hooks, you can put annotations in the hook itself. | example.spec.ts", "output": "test.beforeEach(async ({ page, isMobile }) => {  \n  test.fixme(isMobile, 'Settings page does not work in mobile yet');  \n  \n  await page.goto('http://localhost:3000/settings');  \n});  \n  \ntest('user profile', async ({ page }) => {  \n  await page.getByText('My Profile').click();  \n  // ...  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-annotations", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Click first button  \nawait page.locator('button').locator('nth=0').click();  \n  \n// Click last button  \nawait page.locator('button').locator('nth=-1').click();", "output": "// Click first button  \nawait page.locator('button').locator('nth=0').click();  \n  \n// Click last button  \nawait page.locator('button').locator('nth=-1').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const { chromium, firefox, webkit } = require('playwright');  \n  \n(async () => {  \n  const browser = await chromium.launch();  // Or 'firefox' or 'webkit'.  \n  const page = await browser.newPage();  \n  await page.goto('http://example.com');  \n  // other actions...  \n  await browser.close();  \n})();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/api/class-playwright", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: An example of registering selector engine that queries elements based on a tag name: | baseTest.ts", "input": "", "output": "import { test as base } from '@playwright/test';  \n  \nexport { expect } from '@playwright/test';  \n  \n// Must be a function that evaluates to a selector engine instance.  \nconst createTagNameEngine = () => ({  \n  // Returns the first element matching given selector in the root's subtree.  \n  query(root, selector) {  \n    return root.querySelector(selector);  \n  },  \n  \n  // Returns all elements matching given selector in the root's subtree.  \n  queryAll(root, selector) {  \n    return Array.from(root.querySelectorAll(selector));  \n  }  \n});  \n  \nexport const test = base.extend<{}, { selectorRegistration: void }>({  \n  // Register selectors once per worker.  \n  selectorRegistration: [async ({ playwright }, use) => {  \n    // Register the engine. Selectors will be prefixed with \"tag=\".  \n    await playwright.selectors.register('tag', createTagNameEngine);  \n    await use();  \n  }, { scope: 'worker', auto: true }],  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/extensibility"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.screenshot({ path: 'screenshot.png' });", "output": "await page.screenshot({ path: 'screenshot.png' });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/screenshots", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Start waiting for new page before clicking. Note no await.  \nconst pagePromise = context.waitForEvent('page');  \nawait page.getByText('open new tab').click();  \nconst newPage = await pagePromise;  \n// Interact with the new page normally.  \nawait newPage.getByRole('button').click();  \nconsole.log(await newPage.title());", "output": "// Start waiting for new page before clicking. Note no await.  \nconst pagePromise = context.waitForEvent('page');  \nawait page.getByText('open new tab').click();  \nconst newPage = await pagePromise;  \n// Interact with the new page normally.  \nawait newPage.getByRole('button').click();  \nconsole.log(await newPage.title());", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/pages", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: You can also introduce a one-off handler for a specific test.", "input": "", "output": "import { http, HttpResponse } from 'msw';  \n  \ntest('example test', async ({ mount, router }) => {  \n  await router.use(http.get('/data', async ({ request }) => {  \n    return HttpResponse.json({ value: 'mocked' });  \n  }));  \n  \n  // test as usual, your handler is active  \n  // ...  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from './fixtures';  \n  \ntest('passes', async ({ database, page, a11y }) => {  \n  // use database and a11y fixtures.  \n});", "output": "import { test } from './fixtures';  \n  \ntest('passes', async ({ database, page, a11y }) => {  \n  // use database and a11y fixtures.  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the form_interaction pattern.", "input": "Note: **component tests only** , does not affect end-to-end tests. | `playwright-ct.config` configuration file for [component testing](/docs/test-components) now requires calling `defineConfig`.", "output": "// Before  \n  \nimport { type PlaywrightTestConfig, devices } from '@playwright/experimental-ct-react';  \nconst config: PlaywrightTestConfig = {  \n  // ... config goes here ...  \n};  \nexport default config;", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from './fixtures';  \nimport { assert } from '@playwright/test';  \n  \ntest('basic', async ({ page }) => {  \n  assert(page).toHaveURL('http://localhost:8000');  \n  await page.navigate('https://playwright.dev');  \n});", "output": "import { test } from './fixtures';  \nimport { expect } from '@playwright/test';  \n  \ntest('basic', async ({ page }) => {  \n  expect(page).toHaveURL('http://localhost:8000');  \n  await page.goto('https://playwright.dev');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    video: {  \n      mode: 'on-first-retry',  \n      size: { width: 640, height: 480 }  \n    }  \n  },  \n});  \n\n\n\nconst context = await browser.newContext({  \n  recordVideo: {  \n    dir: 'videos/',  \n    size: { width: 640, height: 480 },  \n  }  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/videos", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Mock WebSockets\u200b | The following code will intercept WebSocket connections and mock entire communcation over the WebSocket, instead of connecting to the server. This example responds to a `\"request\"` with a `\"response\"`.", "output": "await page.routeWebSocket('wss://example.com/ws', ws => {  \n  ws.onMessage(message => {  \n    if (message === 'request')  \n      ws.send('response');  \n  });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/mock"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.getByLabel('Upload directory').setInputFiles(path.join(__dirname, 'mydir'));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const locator = page.locator('button');  \nawait locator.click();", "output": "const locator = page.locator('button');  \nawait locator.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: In configuration file, pass options directly: | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['html', { outputFolder: 'my-report' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "const newEmail = page.getByRole('button', { name: 'New email' });  \nconst dialog = page.getByText('Confirm security settings');  \nawait expect(newEmail.or(dialog)).toBeVisible();  \nif (await dialog.isVisible())  \n  await page.getByRole('button', { name: 'Dismiss' }).click();  \nawait newEmail.click();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Setting in the configuration file: | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Limit the number of failures on CI to save resources  \n  maxFailures: process.env.CI ? 10 : undefined,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "app.spec.tsx", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport App from './App';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<App />);  \n  await expect(component).toContainText('Learn React');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { expect as baseExpect } from '@playwright/test';  \nexport const expect = baseExpect.extend({  \n  async toHaveAmount(locator: Locator, expected: number, options?: { timeout?: number }) {  \n    // ... see documentation for how to write matchers.  \n  },  \n});  \n  \ntest('pass', async ({ page }) => {  \n  await expect(page.getByTestId('cart')).toHaveAmount(5);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/test';  \n  \ntest.describe.configure({ mode: 'parallel' });  \n  \ntest('runs in parallel 1', async ({ page }) => { /* ... */ });  \ntest('runs in parallel 2', async ({ page }) => { /* ... */ });", "output": "import { test } from '@playwright/test';  \n  \ntest.describe.configure({ mode: 'parallel' });  \n  \ntest('runs in parallel 1', async ({ page }) => { /* ... */ });  \ntest('runs in parallel 2', async ({ page }) => { /* ... */ });", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Traces are recorded using the new [browserContext.tracing](/docs/api/class-browsercontext#browser-context-tracing) API:", "output": "const browser = await chromium.launch();  \nconst context = await browser.newContext();  \n  \n// Start tracing before creating / navigating a page.  \nawait context.tracing.start({ screenshots: true, snapshots: true });  \n  \nconst page = await context.newPage();  \nawait page.goto('https://playwright.dev');  \n  \n// Stop tracing and export it into a zip archive.  \nawait context.tracing.stop({ path: 'trace.zip' });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "navigation"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "If you'd like to share the default value among all the tests in the project, you can specify it in the playwright config, either globally or per project: | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  expect: {  \n    toHaveScreenshot: {  \n      stylePath: './screenshot.css'  \n    },  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "The new assertions has screenshot-specific defaults, such as:", "output": "* disables animations\n* uses CSS scale option\n\n    await page.goto('https://playwright.dev');  \nawait expect(page).toHaveScreenshot();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.addInitScript(() => {  \n  const mockBattery = {  \n    level: 0.75,  \n    charging: true,  \n    chargingTime: 1800,  \n    dischargingTime: Infinity,  \n    addEventListener: () => { }  \n  };  \n  // Override the method to always return mock battery info.  \n  window.navigator.getBattery = async () => mockBattery;  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/mock-browser-apis", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "test('example with attachment', async ({ page }, testInfo) => {  \n  await page.goto('https://your-site.com/');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page }).analyze();  \n  \n  await testInfo.attach('accessibility-scan-results', {  \n    body: JSON.stringify(accessibilityScanResults, null, 2),  \n    contentType: 'application/json'  \n  });  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as base } from '@playwright/test';  \n  \nexport type TestOptions = {  \n  person: string;  \n};  \n  \nexport const test = base.extend<TestOptions>({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  person: ['John', { option: true }],  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-parameterize", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  retries: 1,  \n  use: {  \n    trace: 'on-first-retry',  \n  },  \n});  \n\n\n\nconst browser = await chromium.launch();  \nconst context = await browser.newContext();  \n  \n// Start tracing before creating / navigating a page.  \nawait context.tracing.start({ screenshots: true, snapshots: true });  \n  \nconst page = await context.newPage();  \nawait page.goto('https://playwright.dev');  \n  \n// Stop tracing and export it into a zip archive.  \nawait context.tracing.stop({ path: 'trace.zip' });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/trace-viewer"}}
{"instruction": "Generate a Playwright test for the following scenario: Highlights\u200b | New role selectors that allow selecting elements by their [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) and [accessible name](https://w3c.github.io/accname/#dfn-accessible-name).", "input": "", "output": "// Click a button with accessible name \"log in\"  \nawait page.locator('role=button[name=\"log in\"]').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: To take a screenshot of the row with \"Mary\" and \"Say goodbye\":", "input": "", "output": "const rowLocator = page.getByRole('listitem');  \n  \nawait rowLocator  \n    .filter({ hasText: 'Mary' })  \n    .filter({ has: page.getByRole('button', { name: 'Say goodbye' }) })  \n    .screenshot({ path: 'screenshot.png' });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test for the following scenario: component.spec.ts", "input": "", "output": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('props', async ({ mount }) => {  \n  const component = await mount(Component, { props: { msg: 'greetings' } });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test for the following scenario: This will only find a second button, because it is visible, and then click it.", "input": "", "output": "await page.locator('button:visible').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "// Make a few checks that will not stop the test when failed...  \nawait expect.soft(page.getByTestId('status')).toHaveText('Success');  \nawait expect.soft(page.getByTestId('eta')).toHaveText('1 day');  \n  \n// Avoid running further if there were soft assertion failures.  \nexpect(test.info().errors).toHaveLength(0);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "This will find both buttons and throw a [strictness](/docs/locators#strictness) violation error:", "output": "await page.locator('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "Consider the following example:", "output": "import { test as base } from '@playwright/test';  \n  \nconst test = base.extend<{  \n  testFixture: string,  \n  autoTestFixture: string,  \n  unusedFixture: string,  \n}, {  \n  workerFixture: string,  \n  autoWorkerFixture: string,  \n}>({  \n  workerFixture: [async ({ browser }) => {  \n    // workerFixture setup...  \n    await use('workerFixture');  \n    // workerFixture teardown...  \n  }, { scope: 'worker' }],  \n  \n  autoWorkerFixture: [async ({ browser }) => {  \n    // autoWorkerFixture setup...  \n    await use('autoWorkerFixture');  \n    // autoWorkerFixture teardown...  \n  }, { scope: 'worker', auto: true }],  \n  \n  testFixture: [async ({ page, workerFixture }) => {  \n    // testFixture setup...  \n    await use('testFixture');  \n    // testFixture teardown...  \n  }, { scope: 'test' }],  \n  \n  autoTestFixture: [async () => {  \n    // autoTestFixture setup...  \n    await use('autoTestFixture');  \n    // autoTestFixture teardown...  \n  }, { scope: 'test', auto: true }],  \n  \n  unusedFixture: [async ({ page }) => {  \n    // unusedFixture setup...  \n    await use('unusedFixture');  \n    // unusedFixture teardown...  \n  }, { scope: 'test' }],  \n});  \n  \ntest.beforeAll(async () => { /* ... */ });  \ntest.beforeEach(async ({ page }) => { /* ... */ });  \ntest('first test', async ({ page }) => { /* ... */ });  \ntest('second test', async ({ testFixture }) => { /* ... */ });  \ntest.afterEach(async () => { /* ... */ });  \ntest.afterAll(async () => { /* ... */ });", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "fixture"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig, devices } from '@playwright/test'; // import devices  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n      },  \n    },  \n    {  \n      name: 'Mobile Safari',  \n      use: {  \n        ...devices['iPhone 13'],  \n      },  \n    },  \n  ],  \n});  \n\n\n\nconst { chromium, devices } = require('playwright');  \nconst browser = await chromium.launch();  \n  \nconst iphone13 = devices['iPhone 13'];  \nconst context = await browser.newContext({  \n  ...iphone13,  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/emulation", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['junit', { outputFile: 'results.xml' }]],  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['junit', { outputFile: 'results.xml' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Fill an input to the right of \"Username\".  \nawait page.locator('input:right-of(:text(\"Username\"))').fill('value');  \n  \n// Click a button near the promo card.  \nawait page.locator('button:near(.promo-card)').click();  \n  \n// Click the radio input in the list closest to the \"Label 3\".  \nawait page.locator('[type=radio]:left-of(:text(\"Label 3\"))').first().click();", "output": "// Fill an input to the right of \"Username\".  \nawait page.locator('input:right-of(:text(\"Username\"))').fill('value');  \n  \n// Click a button near the promo card.  \nawait page.locator('button:near(.promo-card)').click();  \n  \n// Click the radio input in the list closest to the \"Label 3\".  \nawait page.locator('[type=radio]:left-of(:text(\"Label 3\"))').first().click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Alternatively, you can use [page.route()](/docs/api/class-page#page-route) to mock network in a single page. | example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('loads page without images', async ({ page }) => {  \n  // Block png and jpeg images.  \n  await page.route(/(png|jpeg)$/, route => route.abort());  \n  \n  await page.goto('https://playwright.dev');  \n  // ... test goes here  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "test('navigation menu should not have automatically detectable accessibility violations', async ({  \n  page,  \n}) => {  \n  await page.goto('https://your-site.com/');  \n  \n  await page.getByRole('button', { name: 'Navigation Menu' }).click();  \n  \n  // It is important to waitFor() the page to be in the desired  \n  // state *before* running analyze(). Otherwise, axe might not  \n  // find all the elements your test expects it to scan.  \n  await page.locator('#navigation-menu-flyout').waitFor();  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .include('#navigation-menu-flyout')  \n      .analyze();  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing", "type": "completion"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "const { chromium } = require('playwright');  \n  \n(async () => {  \n  const browser = await chromium.launch();  \n  // Create pages, interact with UI elements, assert values  \n  await browser.close();  \n})();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/library", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: Empty template for snapshot generation\u200b | Passing an empty string as the template in an assertion generates a snapshot on-the-fly:", "input": "", "output": "await expect(locator).toMatchAriaSnapshot('');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/aria-snapshots"}}
{"instruction": "Generate a Playwright test for the following scenario: However, in rare cases you might need to manually scroll. For example, you might want to force an \"infinite list\" to load more elements, or position the page for a specific screenshot. In such a case, the most reliable way is to find an element that you want to make visible at the bottom, and scroll it into view.", "input": "", "output": "// Scroll the footer into view, forcing an \"infinite list\" to load more content  \nawait page.getByText('Footer text').scrollIntoViewIfNeeded();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  expect: {  \n    toHaveScreenshot: {  \n      stylePath: './screenshot.css'  \n    },  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const data = 'some data';  \nconst result = await page.evaluate(() => {  \n  // WRONG: there is no \"data\" in the web page.  \n  window.myApp.use(data);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/evaluating", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Downloaded files are deleted when the browser context that produced them is closed. | Here is the simplest way to handle the file download:", "output": "// Start waiting for download before clicking. Note no await.  \nconst downloadPromise = page.waitForEvent('download');  \nawait page.getByText('Download file').click();  \nconst download = await downloadPromise;  \n  \n// Wait for the download process to complete and save the downloaded file somewhere.  \nawait download.saveAs('/path/to/save/at/' + download.suggestedFilename());", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/downloads", "type": "navigation"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "src/pinia.spec.ts", "output": "import { test, expect } from '@playwright/experimental-ct-vue';  \nimport type { HooksConfig } from '../playwright';  \nimport Store from './Store.vue';  \n  \ntest('override initialState ', async ({ mount }) => {  \n  const component = await mount<HooksConfig>(Store, {  \n    hooksConfig: {  \n      store: { name: 'override initialState' }  \n    }  \n  });  \n  await expect(component).toContainText('override initialState');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test for the following scenario: Click to expand the code for the `TodoPage` | todo-page.ts", "input": "", "output": "import type { Page, Locator } from '@playwright/test';  \n  \nexport class TodoPage {  \n  private readonly inputBox: Locator;  \n  private readonly todoItems: Locator;  \n  \n  constructor(public readonly page: Page) {  \n    this.inputBox = this.page.locator('input.new-todo');  \n    this.todoItems = this.page.getByTestId('todo-item');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://demo.playwright.dev/todomvc/');  \n  }  \n  \n  async addToDo(text: string) {  \n    await this.inputBox.fill(text);  \n    await this.inputBox.press('Enter');  \n  }  \n  \n  async remove(text: string) {  \n    const todo = this.todoItems.filter({ hasText: text });  \n    await todo.hover();  \n    await todo.getByLabel('Delete').click();  \n  }  \n  \n  async removeAll() {  \n    while ((await this.todoItems.count()) > 0) {  \n      await this.todoItems.first().hover();  \n      await this.todoItems.getByLabel('Delete').first().click();  \n    }  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Release left mouse button.", "output": "await page.locator('#item-to-be-dragged').dragTo(page.locator('#item-to-drop-at'));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Generate a Playwright test for the following scenario: The error would look like this:", "input": "", "output": "Error: should be logged in  \n  \n    Call log:  \n      - expect.toBeVisible with timeout 5000ms  \n      - waiting for \"getByText('Name')\"  \n  \n  \n      2 |  \n      3 | test('example test', async({ page }) => {  \n    > 4 |   await expect(page.locator('text=Name'), 'should be logged in').toBeVisible();  \n        |                                                                  ^  \n      5 | });  \n      6 |", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Click first button  \nawait page.locator('button').locator('nth=0').click();  \n  \n// Click last button  \nawait page.locator('button').locator('nth=-1').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \nimport type { TestOptions } from './my-test';  \n  \nexport default defineConfig<TestOptions>({  \n  projects: [  \n    {  \n      name: 'alice',  \n      use: { person: 'Alice' },  \n    },  \n    {  \n      name: 'bob',  \n      use: { person: 'Bob' },  \n    },  \n  ]  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.routeWebSocket('wss://example.com/ws', ws => {  \n  const server = ws.connectToServer();  \n  ws.onMessage(message => {  \n    if (message === 'request')  \n      server.send('request2');  \n    else  \n      server.send(message);  \n  });  \n});", "output": "await page.routeWebSocket('wss://example.com/ws', ws => {  \n  const server = ws.connectToServer();  \n  ws.onMessage(message => {  \n    if (message === 'request')  \n      server.send('request2');  \n    else  \n      server.send(message);  \n  });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/mock", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Waits for either confirmation dialog or load spinner.  \nawait page.locator(  \n    `//span[contains(@class, 'spinner__loading')]|//div[@id='confirmation']`  \n).waitFor();", "output": "// Waits for either confirmation dialog or load spinner.  \nawait page.locator(  \n    `//span[contains(@class, 'spinner__loading')]|//div[@id='confirmation']`  \n).waitFor();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "<ul>  \n  <li>  \n    <h3>Product 1</h3>  \n    <button>Add to cart</button>  \n  </li>  \n  <li>  \n    <h3>Product 2</h3>  \n    <button>Add to cart</button>  \n  </li>  \n</ul>  \n\n\n\nawait page  \n    .getByRole('listitem')  \n    .filter({ has: page.getByRole('heading', { name: 'Product 2' }) })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "output": "<ul>  \n  <li>  \n    <h3>Product 1</h3>  \n    <button>Add to cart</button>  \n  </li>  \n  <li>  \n    <h3>Product 2</h3>  \n    <button>Add to cart</button>  \n  </li>  \n</ul>  \n\n\n\nawait page  \n    .getByRole('listitem')  \n    .filter({ has: page.getByRole('heading', { name: 'Product 2' }) })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: 'list',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Vue", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport HelloWorld from './HelloWorld';  \n  \ntest.use({ viewport: { width: 500, height: 500 } });  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<HelloWorld msg=\"greetings\" />);  \n  await expect(component).toContainText('Greetings');  \n});  \n\n\n\nimport { test, expect } from '@playwright/experimental-ct-vue';  \nimport HelloWorld from './HelloWorld.vue';  \n  \ntest.use({ viewport: { width: 500, height: 500 } });  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(HelloWorld, {  \n    props: {  \n      msg: 'Greetings',  \n    },  \n  });  \n  await expect(component).toContainText('Greetings');  \n});  \n\n\n\nimport { test, expect } from '@playwright/experimental-ct-svelte';  \nimport HelloWorld from './HelloWorld.svelte';  \n  \ntest.use({ viewport: { width: 500, height: 500 } });  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(HelloWorld, {  \n    props: {  \n      msg: 'Greetings',  \n    },  \n  });  \n  await expect(component).toContainText('Greetings');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "* [page.waitForURL()](/docs/api/class-page#page-wait-for-url) to await navigations to URL\n* [video.delete()](/docs/api/class-video#video-delete) and [video.saveAs()](/docs/api/class-video#video-save-as) to manage screen recording", "output": "* [page.waitForURL()](/docs/api/class-page#page-wait-for-url) to await navigations to URL\n* [video.delete()](/docs/api/class-video#video-delete) and [video.saveAs()](/docs/api/class-video#video-save-as) to manage screen recording", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('two tests', () => {  \n  test('one', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('two', async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Use a RegExp. Note no await.  \nconst responsePromise = page.waitForResponse(/\\.jpeg$/);  \nawait page.getByText('Update').click();  \nconst response = await responsePromise;  \n  \n// Use a predicate taking a Response object. Note no await.  \nconst responsePromise = page.waitForResponse(response => response.url().includes(token));  \nawait page.getByText('Update').click();  \nconst response = await responsePromise;", "output": "// Use a RegExp. Note no await.  \nconst responsePromise = page.waitForResponse(/\\.jpeg$/);  \nawait page.getByText('Update').click();  \nconst response = await responsePromise;  \n  \n// Use a predicate taking a Response object. Note no await.  \nconst responsePromise = page.waitForResponse(response => response.url().includes(token));  \nawait page.getByText('Update').click();  \nconst response = await responsePromise;", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as base } from '@playwright/test';  \n  \nexport { expect } from '@playwright/test';  \n  \n// Must be a function that evaluates to a selector engine instance.  \nconst createTagNameEngine = () => ({  \n  // Returns the first element matching given selector in the root's subtree.  \n  query(root, selector) {  \n    return root.querySelector(selector);  \n  },  \n  \n  // Returns all elements matching given selector in the root's subtree.  \n  queryAll(root, selector) {  \n    return Array.from(root.querySelectorAll(selector));  \n  }  \n});  \n  \nexport const test = base.extend<{}, { selectorRegistration: void }>({  \n  // Register selectors once per worker.  \n  selectorRegistration: [async ({ playwright }, use) => {  \n    // Register the engine. Selectors will be prefixed with \"tag=\".  \n    await playwright.selectors.register('tag', createTagNameEngine);  \n    await use();  \n  }, { scope: 'worker', auto: true }],  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/extensibility", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('props', async ({ mount }) => {  \n  const component = await mount(<Component msg=\"greetings\" />);  \n});", "output": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('props', async ({ mount }) => {  \n  const component = await mount(<Component msg=\"greetings\" />);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Creating mocks\u200b | Since the page may be calling the API very early while loading it's important to setup all the mocks before the page started loading. The easiest way to achieve that is to call [page.addInitScript()](/docs/api/class-page#page-add-init-script):", "input": "", "output": "await page.addInitScript(() => {  \n  const mockBattery = {  \n    level: 0.75,  \n    charging: true,  \n    chargingTime: 1800,  \n    dischargingTime: Infinity,  \n    addEventListener: () => { }  \n  };  \n  // Override the method to always return mock battery info.  \n  window.navigator.getBattery = async () => mockBattery;  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/mock-browser-apis"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "component.spec.ts", "output": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(Component);  \n  await component.update({  \n    props: { msg: 'greetings' },  \n    on: { click() {} },  \n    slots: { default: 'Child' }  \n  });  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('context fetch', async ({ request }) => {  \n  // Do a GET request on behalf of page  \n  const response = await request.get('http://example.com/foo.json');  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "And then import the fixtures in all your tests: | mytest.spec.ts", "output": "import { test } from './fixtures';  \nimport { expect } from '@playwright/test';  \n  \ntest('basic', async ({ page }) => {  \n  expect(page).toHaveURL('http://localhost:8000');  \n  await page.goto('https://playwright.dev');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "If you'd like to target the parent `<li>` of a label with text `\"Hello\"`, using [locator.filter()](/docs/api/class-locator#locator-filter) works best:", "output": "const child = page.getByText('Hello');  \nconst parent = page.getByRole('listitem').filter({ has: child });", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    proxy: {  \n      server: 'http://my-proxy:8080',  \n      username: 'user',  \n      password: 'secret'  \n    },  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/api-testing", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: In configuration file, pass options directly: | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['json', { outputFile: 'results.json' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const newEmail = page.getByRole('button', { name: 'New email' });  \nconst dialog = page.getByText('Confirm security settings');  \nawait expect(newEmail.or(dialog)).toBeVisible();  \nif (await dialog.isVisible())  \n  await page.getByRole('button', { name: 'Dismiss' }).click();  \nawait newEmail.click();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert(page.getByText(/welcome, [A-Za-z]+$/i)).toBeVisible();", "output": "await expect(page.getByText(/welcome, [A-Za-z]+$/i)).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.route('**/api/settings', async route => {  \n  // Fetch original settings.  \n  const response = await route.fetch();  \n  \n  // Force settings theme to a predefined value.  \n  const json = await response.json();  \n  json.theme = 'Solorized';  \n  \n  // Fulfill with modified data.  \n  await route.fulfill({ json });  \n});", "output": "await page.route('**/api/settings', async route => {  \n  // Fetch original settings.  \n  const response = await route.fetch();  \n  \n  // Force settings theme to a predefined value.  \n  const json = await response.json();  \n  json.theme = 'Solorized';  \n  \n  // Fulfill with modified data.  \n  await route.fulfill({ json });  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: For example, `article:has-text(\"Playwright\")` matches `<article><div>Playwright</div></article>`. | Note that `:has-text()` should be used together with other CSS specifiers, otherwise it will match all the elements containing specified text, including the `<body>`.", "input": "", "output": "// Wrong, will match many elements including <body>  \nawait page.locator(':has-text(\"Playwright\")').click();  \n// Correct, only matches the <article> element  \nawait page.locator('article:has-text(\"Playwright\")').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "New `maxDiffPixels` and `maxDiffPixelRatio` options for fine-grained screenshot comparison using `expect().toMatchSnapshot()`:", "output": "expect(await page.screenshot()).toMatchSnapshot({  \n  maxDiffPixels: 27, // allow no more than 27 different pixels.  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('basic test', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  const name = await page.innerText('.navbar__title');  \n  expect(name).toBe('Playwright');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Session storage\u200b | Reusing authenticated state covers [cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies) and [local storage](https://developer.mozilla.org/en-US/docs/Web/API/Storage) based authentication. Rarely, [session storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage) is used for storing information associated with the signed-in state. Session storage is specific to a particular domain and is not persisted across page loads. Playwright does not provide API to persist session storage, but the following snippet can be used to save/load session storage.", "output": "// Get session storage and store as env variable  \nconst sessionStorage = await page.evaluate(() => JSON.stringify(sessionStorage));  \nfs.writeFileSync('playwright/.auth/session.json', sessionStorage, 'utf-8');  \n  \n// Set session storage in a new context  \nconst sessionStorage = JSON.parse(fs.readFileSync('playwright/.auth/session.json', 'utf-8'));  \nawait context.addInitScript(storage => {  \n  if (window.location.hostname === 'example.com') {  \n    for (const [key, value] of Object.entries(storage))  \n      window.sessionStorage.setItem(key, value);  \n  }  \n}, sessionStorage);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.navigate('https://playwright.dev');  \n  await assert(page).toHaveScreenshot({ maxDiffPixels: 100 });  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  await expect(page).toHaveScreenshot({ maxDiffPixels: 100 });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots", "type": "modification"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \nimport { PlaywrightDevPage } from './playwright-dev-page';  \n  \ntest('getting started should contain table of contents', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.getStarted();  \n  await expect(playwrightDev.tocList).toHaveText([  \n    `How to install Playwright`,  \n    `What's Installed`,  \n    `How to run the example test`,  \n    `How to open the HTML test report`,  \n    `Write tests using web first assertions, page fixtures and locators`,  \n    `Run single test, multiple tests, headed mode`,  \n    `Generate tests with Codegen`,  \n    `See a trace of your tests`  \n  ]);  \n});  \n  \ntest('should show Page Object Model article', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.pageObjectModel();  \n  await expect(page.locator('article')).toContainText('Page Object Model is a common pattern');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/pom", "type": "fixture"}}
{"instruction": "Generate a Playwright test for the following scenario: New mode `retain-on-first-failure` for [testOptions.trace](/docs/api/class-testoptions#test-options-trace). In this mode, trace is recorded for the first run of each test, but not for retires. When test run fails, the trace file is retained, otherwise it is removed.", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    trace: 'retain-on-first-failure',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Fill an input with the id \"username\"  \nawait page.locator('id=username').fill('value');  \n  \n// Click an element with data-test-id \"submit\"  \nawait page.locator('data-test-id=submit').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from './fixtures';  \n  \ntest('passes', async ({ page, database }) => {  \n  await expect(database).toHaveDatabaseUser('admin');  \n  await expect(page).toPassA11yAudit();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "feature-b.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \nexport default function createTests() {  \n  test.use({ viewport: { width: 500, height: 500 } });  \n  \n  test('feature-b example test', async ({ page }) => {  \n    // ... test goes here  \n  });  \n}", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const { chromium } = require('playwright');  \n  \n(async () => {  \n  const pathToExtension = require('path').join(__dirname, 'my-extension');  \n  const userDataDir = '/tmp/test-user-data-dir';  \n  const browserContext = await chromium.launchPersistentContext(userDataDir, {  \n    headless: false,  \n    args: [  \n      `--disable-extensions-except=${pathToExtension}`,  \n      `--load-extension=${pathToExtension}`  \n    ]  \n  });  \n  let [backgroundPage] = browserContext.backgroundPages();  \n  if (!backgroundPage)  \n    backgroundPage = await browserContext.waitForEvent('backgroundpage');  \n  \n  // Test the background page as you would any other page.  \n  await browserContext.close();  \n})();", "output": "const { chromium } = require('playwright');  \n  \n(async () => {  \n  const pathToExtension = require('path').join(__dirname, 'my-extension');  \n  const userDataDir = '/tmp/test-user-data-dir';  \n  const browserContext = await chromium.launchPersistentContext(userDataDir, {  \n    headless: false,  \n    args: [  \n      `--disable-extensions-except=${pathToExtension}`,  \n      `--load-extension=${pathToExtension}`  \n    ]  \n  });  \n  let [backgroundPage] = browserContext.backgroundPages();  \n  if (!backgroundPage)  \n    backgroundPage = await browserContext.waitForEvent('backgroundpage');  \n  \n  // Test the background page as you would any other page.  \n  await browserContext.close();  \n})();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/chrome-extensions", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Automatically capture **full page screenshot** on test failure: | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    screenshot: {  \n      mode: 'only-on-failure',  \n      fullPage: true,  \n    }  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.getByText('orange').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Built-in fixtures\u200b | You have already used test fixtures in your first test.", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('basic test', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  \n  await expect(page).toHaveTitle(/Playwright/);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test('context request will share cookie storage with its browser context', async ({  \n  page,  \n  context,  \n}) => {  \n  await context.route('https://www.github.com/', async route => {  \n    // Send an API request that shares cookie storage with the browser context.  \n    const response = await context.request.fetch(route.request());  \n    const responseHeaders = response.headers();  \n  \n    // The response will have 'Set-Cookie' header.  \n    const responseCookies = new Map(responseHeaders['set-cookie']  \n        .split('\\n')  \n        .map(c => c.split(';', 2)[0].split('=')));  \n    // The response will have 3 cookies in 'Set-Cookie' header.  \n    expect(responseCookies.size).toBe(3);  \n    const contextCookies = await context.cookies();  \n    // The browser context will already contain all the cookies from the API response.  \n    expect(new Map(contextCookies.map(({ name, value }) =>  \n      [name, value])  \n    )).toEqual(responseCookies);  \n  \n    await route.fulfill({  \n      response,  \n      headers: { ...responseHeaders, foo: 'bar' },  \n    });  \n  });  \n  await page.goto('https://www.github.com/');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/api-testing", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Most of the time you should put `beforeEach`, `beforeAll`, `afterEach` and `afterAll` hooks outside of `forEach`, so that hooks are executed just once: | example.spec.ts", "output": "test.beforeEach(async ({ page }) => {  \n  // ...  \n});  \n  \ntest.afterEach(async ({ page }) => {  \n  // ...  \n});  \n  \n[  \n  { name: 'Alice', expected: 'Hello, Alice!' },  \n  { name: 'Bob', expected: 'Hello, Bob!' },  \n  { name: 'Charlie', expected: 'Hello, Charlie!' },  \n].forEach(({ name, expected }) => {  \n  test(`testing with ${name}`, async ({ page }) => {  \n    await page.goto(`https://example.com/greet?name=${name}`);  \n    await expect(page.getByRole('heading')).toHaveText(expected);  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const locator = page.getByRole('button');  \nawait expect(locator).toHaveAccessibleDescription('Upload a photo');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Create `tests/auth.setup.ts` that will prepare authenticated browser state for all other tests. | tests/auth.setup.ts", "output": "import { test as setup, expect } from '@playwright/test';  \nimport path from 'path';  \n  \nconst authFile = path.join(__dirname, '../playwright/.auth/user.json');  \n  \nsetup('authenticate', async ({ page }) => {  \n  // Perform authentication steps. Replace these actions with your own.  \n  await page.goto('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('username');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n  // Wait until the page receives the cookies.  \n  //  \n  // Sometimes login flow sets cookies in the process of several redirects.  \n  // Wait for the final URL to ensure that the cookies are actually set.  \n  await page.waitForURL('https://github.com/');  \n  // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n  await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n  // End of authentication steps.  \n  \n  await page.context().storageState({ path: authFile });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "To click `<x-details>`:", "output": "await page.locator('x-details', { hasText: 'Details' }).click();  \n\n\n\n<x-details role=button aria-expanded=true aria-controls=inner-details>  \n  <div>Title</div>  \n  #shadow-root  \n    <div id=inner-details>Details</div>  \n</x-details>", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test for the following scenario: test.spec.ts", "input": "", "output": "import { test } from './fixtures';  \n  \ntest('passes', async ({ database, page, a11y }) => {  \n  // use database and a11y fixtures.  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport HelloWorld from './HelloWorld';  \n  \ntest.use({ viewport: { width: 500, height: 500 } });  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<HelloWorld msg=\"greetings\" />);  \n  await expect(component).toContainText('Greetings');  \n});  \n\n\n\nimport { test, expect } from '@playwright/experimental-ct-vue';  \nimport HelloWorld from './HelloWorld.vue';  \n  \ntest.use({ viewport: { width: 500, height: 500 } });  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(HelloWorld, {  \n    props: {  \n      msg: 'Greetings',  \n    },  \n  });  \n  await expect(component).toContainText('Greetings');  \n});  \n\n\n\nimport { test, expect } from '@playwright/experimental-ct-svelte';  \nimport HelloWorld from './HelloWorld.svelte';  \n  \ntest.use({ viewport: { width: 500, height: 500 } });  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(HelloWorld, {  \n    props: {  \n      msg: 'Greetings',  \n    },  \n  });  \n  await expect(component).toContainText('Greetings');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const base = require('@playwright/test');  \n  \nexports.test = base.test.extend({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  person: ['John', { option: true }],  \n  \n  // Override default \"page\" fixture.  \n  page: async ({ page, person }, use) => {  \n    await page.goto('/chat');  \n    // We use \"person\" parameter as a \"name\" for the chat room.  \n    await page.getByLabel('User Name').fill(person);  \n    await page.getByText('Enter chat room').click();  \n    // Each test will get a \"page\" that already has the person name.  \n    await use(page);  \n  },  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-parameterize", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.getByRole('button').count();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as setup, assert } from '@playwright/test';  \n  \nconst adminFile = 'playwright/.auth/admin.json';  \n  \nsetup('authenticate as admin', async ({ page }) => {  \n  // Perform authentication steps. Replace these actions with your own.  \n  await page.navigate('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('admin');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n  // Wait until the page receives the cookies.  \n  //  \n  // Sometimes login flow sets cookies in the process of several redirects.  \n  // Wait for the final URL to ensure that the cookies are actually set.  \n  await page.waitForURL('https://github.com/');  \n  // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n  await assert(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n  // End of authentication steps.  \n  \n  await page.context().storageState({ path: adminFile });  \n});  \n  \nconst userFile = 'playwright/.auth/user.json';  \n  \nsetup('authenticate as user', async ({ page }) => {  \n  // Perform authentication steps. Replace these actions with your own.  \n  await page.navigate('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('user');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n  // Wait until the page receives the cookies.  \n  //  \n  // Sometimes login flow sets cookies in the process of several redirects.  \n  // Wait for the final URL to ensure that the cookies are actually set.  \n  await page.waitForURL('https://github.com/');  \n  // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n  await assert(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n  // End of authentication steps.  \n  \n  await page.context().storageState({ path: userFile });  \n});", "output": "import { test as setup, expect } from '@playwright/test';  \n  \nconst adminFile = 'playwright/.auth/admin.json';  \n  \nsetup('authenticate as admin', async ({ page }) => {  \n  // Perform authentication steps. Replace these actions with your own.  \n  await page.goto('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('admin');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n  // Wait until the page receives the cookies.  \n  //  \n  // Sometimes login flow sets cookies in the process of several redirects.  \n  // Wait for the final URL to ensure that the cookies are actually set.  \n  await page.waitForURL('https://github.com/');  \n  // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n  await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n  // End of authentication steps.  \n  \n  await page.context().storageState({ path: adminFile });  \n});  \n  \nconst userFile = 'playwright/.auth/user.json';  \n  \nsetup('authenticate as user', async ({ page }) => {  \n  // Perform authentication steps. Replace these actions with your own.  \n  await page.goto('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('user');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n  // Wait until the page receives the cookies.  \n  //  \n  // Sometimes login flow sets cookies in the process of several redirects.  \n  // Wait for the final URL to ensure that the cookies are actually set.  \n  await page.waitForURL('https://github.com/');  \n  // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n  await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n  // End of authentication steps.  \n  \n  await page.context().storageState({ path: userFile });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/auth", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Playwright makes it easy to test your site across all [browsers](/docs/test-projects#configure-projects-for-multiple-browsers) no matter what platform you are on. Testing across all browsers ensures your app works for all users. In your config file you can set up projects adding the name and which browser or device to use. | playwright.config.ts", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n    },  \n    {  \n      name: 'firefox',  \n      use: { ...devices['Desktop Firefox'] },  \n    },  \n    {  \n      name: 'webkit',  \n      use: { ...devices['Desktop Safari'] },  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/best-practices"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Vue locator allows finding elements by their component name and property values. The syntax is very similar to [CSS attribute selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors) and supports all CSS attribute selector operators. | In Vue locator, component names are transcribed with **kebab-case**.", "output": "await page.locator('_vue=book-item').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.locator('css=button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert(page).toHaveScreenshot('landing.png');", "output": "await expect(page).toHaveScreenshot('landing.png');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/experimental-ct-react';  \nimport { Component } from './mycomponent';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<Component></Component>, {  \n    // Pass mock value from test into `beforeMount`.  \n    hooksConfig: {  \n      router: {  \n        query: { page: 1, per_page: 10 },  \n        asPath: '/posts'  \n      }  \n    }  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Session storage\u200b | Reusing authenticated state covers [cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies) and [local storage](https://developer.mozilla.org/en-US/docs/Web/API/Storage) based authentication. Rarely, [session storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage) is used for storing information associated with the signed-in state. Session storage is specific to a particular domain and is not persisted across page loads. Playwright does not provide API to persist session storage, but the following snippet can be used to save/load session storage.", "input": "", "output": "// Get session storage and store as env variable  \nconst sessionStorage = await page.evaluate(() => JSON.stringify(sessionStorage));  \nfs.writeFileSync('playwright/.auth/session.json', sessionStorage, 'utf-8');  \n  \n// Set session storage in a new context  \nconst sessionStorage = JSON.parse(fs.readFileSync('playwright/.auth/session.json', 'utf-8'));  \nawait context.addInitScript(storage => {  \n  if (window.location.hostname === 'example.com') {  \n    for (const [key, value] of Object.entries(storage))  \n      window.sessionStorage.setItem(key, value);  \n  }  \n}, sessionStorage);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "expect(await page.screenshot()).toMatchSnapshot({  \n  maxDiffPixels: 27, // allow no more than 27 different pixels.  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest.beforeEach(async ({ page }, testInfo) => {  \n  // Extend timeout for all tests running this hook by 30 seconds.  \n  testInfo.setTimeout(testInfo.timeout + 30_000);  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.beforeEach(async ({ page }, testInfo) => {  \n  // Extend timeout for all tests running this hook by 30 seconds.  \n  testInfo.setTimeout(testInfo.timeout + 30_000);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest.describe(() => {  \n  // All tests in this describe group will get 2 retry attempts.  \n  test.describe.configure({ retries: 2 });  \n  \n  test('test 1', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('test 2', async ({ page }) => {  \n    // ...  \n  });  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe(() => {  \n  // All tests in this describe group will get 2 retry attempts.  \n  test.describe.configure({ retries: 2 });  \n  \n  test('test 1', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('test 2', async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-retries", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "component.spec.ts", "output": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('event', async ({ mount }) => {  \n  const component = await mount(Component, { on: { click() {} } });  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  retries: 1,  \n  use: {  \n    trace: 'on-first-retry',  \n  },  \n});  \n\n\n\nconst browser = await chromium.launch();  \nconst context = await browser.newContext();  \n  \n// Start tracing before creating / navigating a page.  \nawait context.tracing.start({ screenshots: true, snapshots: true });  \n  \nconst page = await context.newPage();  \nawait page.navigate('https://playwright.dev');  \n  \n// Stop tracing and export it into a zip archive.  \nawait context.tracing.stop({ path: 'trace.zip' });", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  retries: 1,  \n  use: {  \n    trace: 'on-first-retry',  \n  },  \n});  \n\n\n\nconst browser = await chromium.launch();  \nconst context = await browser.newContext();  \n  \n// Start tracing before creating / navigating a page.  \nawait context.tracing.start({ screenshots: true, snapshots: true });  \n  \nconst page = await context.newPage();  \nawait page.goto('https://playwright.dev');  \n  \n// Stop tracing and export it into a zip archive.  \nawait context.tracing.stop({ path: 'trace.zip' });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/trace-viewer", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "Fixture timeout\u200b | By default, fixture shares timeout with the test. However, for slow fixtures, especially worker-scoped ones, it is convenient to have a separate timeout. This way you can keep the overall test timeout small, and give the slow fixture more time.", "output": "import { test as base, expect } from '@playwright/test';  \n  \nconst test = base.extend<{ slowFixture: string }>({  \n  slowFixture: [async ({}, use) => {  \n    // ... perform a slow operation ...  \n    await use('hello');  \n  }, { timeout: 60000 }]  \n});  \n  \ntest('example test', async ({ slowFixture }) => {  \n  // ...  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Alternatively, you can opt-in all tests into this fully-parallel mode in the configuration file: | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  fullyParallel: true,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as setup, assert } from '@playwright/test';  \nimport path from 'path';  \n  \nconst authFile = path.join(__dirname, '../playwright/.auth/user.json');  \n  \nsetup('authenticate', async ({ page }) => {  \n  // Perform authentication steps. Replace these actions with your own.  \n  await page.navigate('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('username');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n  // Wait until the page receives the cookies.  \n  //  \n  // Sometimes login flow sets cookies in the process of several redirects.  \n  // Wait for the final URL to ensure that the cookies are actually set.  \n  await page.waitForURL('https://github.com/');  \n  // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n  await assert(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n  // End of authentication steps.  \n  \n  await page.context().storageState({ path: authFile });  \n});", "output": "import { test as setup, expect } from '@playwright/test';  \nimport path from 'path';  \n  \nconst authFile = path.join(__dirname, '../playwright/.auth/user.json');  \n  \nsetup('authenticate', async ({ page }) => {  \n  // Perform authentication steps. Replace these actions with your own.  \n  await page.goto('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('username');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n  // Wait until the page receives the cookies.  \n  //  \n  // Sometimes login flow sets cookies in the process of several redirects.  \n  // Wait for the final URL to ensure that the cookies are actually set.  \n  await page.waitForURL('https://github.com/');  \n  // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n  await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n  // End of authentication steps.  \n  \n  await page.context().storageState({ path: authFile });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/auth", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect(page  \n    .getByRole('listitem'))  \n    .toHaveText(['apple', 'banana', 'orange']);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('test login page', {  \n  tag: '@fast',  \n}, async ({ page }) => {  \n  // ...  \n});  \n  \ntest('test full report @slow', async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test('navigation menu should not have automatically detectable accessibility violations', async ({  \n  page,  \n}) => {  \n  await page.goto('https://your-site.com/');  \n  \n  await page.getByRole('button', { name: 'Navigation Menu' }).click();  \n  \n  // It is important to waitFor() the page to be in the desired  \n  // state *before* running analyze(). Otherwise, axe might not  \n  // find all the elements your test expects it to scan.  \n  await page.locator('#navigation-menu-flyout').waitFor();  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .include('#navigation-menu-flyout')  \n      .analyze();  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Abort requests\u200b | You can abort requests using [page.route()](/docs/api/class-page#page-route) and [route.abort()](/docs/api/class-route#route-abort).", "input": "", "output": "await page.route('**/*.{png,jpg,jpeg}', route => route.abort());  \n  \n// Abort based on the request type  \nawait page.route('**/*', route => {  \n  return route.request().resourceType() === 'image' ? route.abort() : route.continue();  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.getByText('Click me').click();  \nawait page.waitForURL('**/login');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/navigations", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "expect(value).not.toEqual(0);  \nawait expect(locator).not.toContainText('some text');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(Component);  \n  await component.update({  \n    props: { msg: 'greetings' },  \n    on: { click() {} },  \n    slots: { default: 'Child' }  \n  });  \n});", "output": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(Component);  \n  await component.update({  \n    props: { msg: 'greetings' },  \n    on: { click() {} },  \n    slots: { default: 'Child' }  \n  });  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "Custom config options are a convenient way to parametrize projects with different values. Learn more in [this guide](/docs/test-parameterize#parameterized-projects). | Previously, any fixture introduced through [test.extend()](/docs/api/class-test#test-extend) could be overridden in the [testProject.use](/docs/api/class-testproject#test-project-use) config section. For example,", "output": "// WRONG: THIS SNIPPET DOES NOT WORK SINCE v1.18.  \n  \n// fixtures.js  \nconst test = base.extend({  \n  myParameter: 'default',  \n});  \n  \n// playwright.config.js  \nmodule.exports = {  \n  use: {  \n    myParameter: 'value',  \n  },  \n};", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/release-notes", "type": "fixture"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test(`example test`, async ({ page }) => {  \n  // ...  \n  await page.getByLabel('User Name').fill(process.env.USER_NAME);  \n  await page.getByLabel('Password').fill(process.env.PASSWORD);  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-parameterize", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "You can now merge test fixtures from multiple files or modules: | fixtures.ts", "output": "import { mergeTests } from '@playwright/test';  \nimport { test as dbTest } from 'database-test-utils';  \nimport { test as a11yTest } from 'a11y-test-utils';  \n  \nexport const test = mergeTests(dbTest, a11yTest);", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "[test.beforeEach()](/docs/api/class-test#test-before-each) and [test.afterEach()](/docs/api/class-test#test-after-each) hooks run before/after each test declared in the same file and same [test.describe()](/docs/api/class-test#test-describe) block (if any). If you want to declare hooks that run before/after each test globally, you can declare them as auto fixtures like this: | fixtures.ts", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend<{ forEachTest: void }>({  \n  forEachTest: [async ({ page }, use) => {  \n    // This code runs before every test.  \n    await page.goto('http://localhost:8000');  \n    await use();  \n    // This code runs after every test.  \n    console.log('Last URL:', page.url());  \n  }, { auto: true }],  // automatically starts for every test.  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-fixtures", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const context = await browser.newContext({  \n  recordHar: { path: 'github.har.zip' }  \n});  \n// ... do stuff ...  \nawait context.close();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Here is an example of a generated test with assertions:", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  await page.getByRole('link', { name: 'Get started' }).click();  \n  await expect(page.getByLabel('Breadcrumbs').getByRole('list')).toContainText('Installation');  \n  await expect(page.getByLabel('Search')).toBeVisible();  \n  await page.getByLabel('Search').click();  \n  await page.getByPlaceholder('Search docs').fill('locator');  \n  await expect(page.getByPlaceholder('Search docs')).toHaveValue('locator');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  assert(response.status()).toBe(200);  \n}).toPass();", "output": "await expect(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  expect(response.status()).toBe(200);  \n}).toPass();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Rest of your config...  \n  \n  // Run your local dev server before starting the tests  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n    timeout: 120 * 1000,  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-webserver", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect(page.getByText('Name'), 'should be logged in').toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "To do a request on behalf of Playwright's Page, use **new[page.request](/docs/api/class-page#page-request) API**:", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('context fetch', async ({ page }) => {  \n  // Do a GET request on behalf of page  \n  const response = await page.request.get('http://example.com/foo.json');  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Behavior Changes\u200b | [expect(locator).toHaveAttribute()](/docs/api/class-locatorassertions#locator-assertions-to-have-attribute) with an empty value does not match missing attribute anymore. For example, the following snippet will succeed when `button` **does not** have a `disabled` attribute.", "output": "await expect(page.getByRole('button')).toHaveAttribute('disabled', '');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "XPath and CSS selectors can be tied to the DOM structure or implementation. These selectors can break when the DOM structure changes. Long CSS or XPath chains below are an example of a **bad practice** that leads to unstable tests:", "output": "await page.locator(  \n    '#tsf > div:nth-child(2) > div.A8SBwf > div.RNNXgb > div > div.a4bIc > input'  \n).click();  \n  \nawait page  \n    .locator('//*[@id=\"tsf\"]/div[2]/div[1]/div[1]/div/div[2]/input')  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const locator = page.getByTestId('save-button');  \nawait expect(locator).toHaveRole('button');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'], channel: 'chromium' },  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Start waiting for new page before clicking. Note no await.  \nconst pagePromise = context.waitForEvent('page');  \nawait page.getByText('open new tab').click();  \nconst newPage = await pagePromise;  \n// Interact with the new page normally.  \nawait newPage.getByRole('button').click();  \nconsole.log(await newPage.title());", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/pages", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "type Person = { name: string };  \nconst test = base.extend<{ persons: Person[] }>({  \n  // Declare the option, default value is an empty array.  \n  persons: [[], { option: true }],  \n});  \n  \n// Option value is an array of persons.  \nconst actualPersons = [{ name: 'Alice' }, { name: 'Bob' }];  \ntest.use({  \n  // CORRECT: Wrap the value into an array and pass the scope.  \n  persons: [actualPersons, { scope: 'test' }],  \n});  \n  \ntest.use({  \n  // WRONG: passing an array value directly will not work.  \n  persons: actualPersons,  \n});", "output": "type Person = { name: string };  \nconst test = base.extend<{ persons: Person[] }>({  \n  // Declare the option, default value is an empty array.  \n  persons: [[], { option: true }],  \n});  \n  \n// Option value is an array of persons.  \nconst actualPersons = [{ name: 'Alice' }, { name: 'Bob' }];  \ntest.use({  \n  // CORRECT: Wrap the value into an array and pass the scope.  \n  persons: [actualPersons, { scope: 'test' }],  \n});  \n  \ntest.use({  \n  // WRONG: passing an array value directly will not work.  \n  persons: actualPersons,  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Locate element inside frame  \nconst username = await page.frameLocator('.frame-class').getByLabel('User Name');  \nawait username.fill('John');", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/frames", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Test with predefined time\u200b | Often you only need to fake `Date.now` while keeping the timers going. That way the time flows naturally, but `Date.now` always returns a fixed value.", "input": "", "output": "<div id=\"current-time\" data-testid=\"current-time\"></div>  \n<script>  \n  const renderTime = () => {  \n    document.getElementById('current-time').textContent =  \n        new Date().toLocaleString();  \n  };  \n  setInterval(renderTime, 1000);  \n</script>  \n\n\n\nawait page.clock.setFixedTime(new Date('2024-02-02T10:00:00'));  \nawait page.goto('http://localhost:3333');  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \nawait page.clock.setFixedTime(new Date('2024-02-02T10:30:00'));  \n// We know that the page has a timer that updates the time every second.  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:30:00 AM');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/clock"}}
{"instruction": "Generate a Playwright test for the following scenario: You can also tag all tests in a group or provide multiple tags:", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('group', {  \n  tag: '@report',  \n}, () => {  \n  test('test report header', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('test full report', {  \n    tag: ['@slow', '@vrt'],  \n  }, async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: 'Product 2' })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/best-practices", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "\ud83c\udfad Playwright Test\u200b | \ud83e\udd1d `test.parallel()` run tests in the same file in parallel\u200b", "output": "test.describe.parallel('group', () => {  \n  test('runs in parallel 1', async ({ page }) => {  \n  });  \n  test('runs in parallel 2', async ({ page }) => {  \n  });  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { chromium, devices } from 'playwright';  \nimport assert from 'node:assert';  \n  \n(async () => {  \n  // Setup  \n  const browser = await chromium.launch();  \n  const context = await browser.newContext(devices['iPhone 11']);  \n  const page = await context.newPage();  \n  \n  // The actual interesting bit  \n  await context.route('**.jpg', route => route.abort());  \n  await page.navigate('https://example.com/');  \n  \n  assert(await page.title() === 'Example Domain'); // \ud83d\udc4e not a Web First assertion  \n  \n  // Teardown  \n  await context.close();  \n  await browser.close();  \n})();  \n\n\n\nconst assert = require('node:assert');  \nconst { chromium, devices } = require('playwright');  \n  \n(async () => {  \n  // Setup  \n  const browser = await chromium.launch();  \n  const context = await browser.newContext(devices['iPhone 11']);  \n  const page = await context.newPage();  \n  \n  // The actual interesting bit  \n  await context.route('**.jpg', route => route.abort());  \n  await page.navigate('https://example.com/');  \n  \n  assert(await page.title() === 'Example Domain'); // \ud83d\udc4e not a Web First assertion  \n  \n  // Teardown  \n  await context.close();  \n  await browser.close();  \n})();", "output": "import { chromium, devices } from 'playwright';  \nimport assert from 'node:assert';  \n  \n(async () => {  \n  // Setup  \n  const browser = await chromium.launch();  \n  const context = await browser.newContext(devices['iPhone 11']);  \n  const page = await context.newPage();  \n  \n  // The actual interesting bit  \n  await context.route('**.jpg', route => route.abort());  \n  await page.goto('https://example.com/');  \n  \n  assert(await page.title() === 'Example Domain'); // \ud83d\udc4e not a Web First assertion  \n  \n  // Teardown  \n  await context.close();  \n  await browser.close();  \n})();  \n\n\n\nconst assert = require('node:assert');  \nconst { chromium, devices } = require('playwright');  \n  \n(async () => {  \n  // Setup  \n  const browser = await chromium.launch();  \n  const context = await browser.newContext(devices['iPhone 11']);  \n  const page = await context.newPage();  \n  \n  // The actual interesting bit  \n  await context.route('**.jpg', route => route.abort());  \n  await page.goto('https://example.com/');  \n  \n  assert(await page.title() === 'Example Domain'); // \ud83d\udc4e not a Web First assertion  \n  \n  // Teardown  \n  await context.close();  \n  await browser.close();  \n})();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/library", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as base, expect } from '@playwright/test';  \n  \nconst test = base.extend<{ slowFixture: string }>({  \n  slowFixture: [async ({}, use) => {  \n    // ... perform a slow operation ...  \n    await use('hello');  \n  }, { timeout: 60_000 }]  \n});  \n  \ntest('example test', async ({ slowFixture }) => {  \n  // ...  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-timeouts", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import type { Page, Locator } from '@playwright/test';  \n  \nexport class TodoPage {  \n  private readonly inputBox: Locator;  \n  private readonly todoItems: Locator;  \n  \n  constructor(public readonly page: Page) {  \n    this.inputBox = this.page.locator('input.new-todo');  \n    this.todoItems = this.page.getByTestId('todo-item');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://demo.playwright.dev/todomvc/');  \n  }  \n  \n  async addToDo(text: string) {  \n    await this.inputBox.fill(text);  \n    await this.inputBox.press('Enter');  \n  }  \n  \n  async remove(text: string) {  \n    const todo = this.todoItems.filter({ hasText: text });  \n    await todo.hover();  \n    await todo.getByLabel('Delete').click();  \n  }  \n  \n  async removeAll() {  \n    while ((await this.todoItems.count()) > 0) {  \n      await this.todoItems.first().hover();  \n      await this.todoItems.getByLabel('Delete').first().click();  \n    }  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig, devices } from '@playwright/test'; // import devices  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n      },  \n    },  \n    {  \n      name: 'Mobile Safari',  \n      use: {  \n        ...devices['iPhone 13'],  \n      },  \n    },  \n  ],  \n});  \n\n\n\nconst { chromium, devices } = require('playwright');  \nconst browser = await chromium.launch();  \n  \nconst iphone13 = devices['iPhone 13'];  \nconst context = await browser.newContext({  \n  ...iphone13,  \n});", "output": "import { defineConfig, devices } from '@playwright/test'; // import devices  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n      },  \n    },  \n    {  \n      name: 'Mobile Safari',  \n      use: {  \n        ...devices['iPhone 13'],  \n      },  \n    },  \n  ],  \n});  \n\n\n\nconst { chromium, devices } = require('playwright');  \nconst browser = await chromium.launch();  \n  \nconst iphone13 = devices['iPhone 13'];  \nconst context = await browser.newContext({  \n  ...iphone13,  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/emulation", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test.beforeAll(async ({ request }) => {  \n  // Create a new repository  \n  const response = await request.post('/user/repos', {  \n    data: {  \n      name: REPO  \n    }  \n  });  \n  expect(response.ok()).toBeTruthy();  \n});  \n  \ntest.afterAll(async ({ request }) => {  \n  // Delete the repository  \n  const response = await request.delete(`/repos/${USER}/${REPO}`);  \n  expect(response.ok()).toBeTruthy();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/api-testing", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the form_interaction pattern.", "input": "You can make arbitrary data available in your tests from your global setup file by setting them as environment variables via `process.env`. | global-setup.ts", "output": "import type { FullConfig } from '@playwright/test';  \n  \nasync function globalSetup(config: FullConfig) {  \n  process.env.FOO = 'some data';  \n  // Or a more complicated data structure as JSON:  \n  process.env.BAR = JSON.stringify({ some: 'data' });  \n}  \n  \nexport default globalSetup;", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "tests/menu.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('menu', async ({ page }) => {  \n  // Your test that depends on the database  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Generate a Playwright test for the following scenario: my-test.ts", "input": "", "output": "import { test as base } from '@playwright/test';  \n  \nexport type TestOptions = {  \n  person: string;  \n};  \n  \nexport const test = base.extend<TestOptions>({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  person: ['John', { option: true }],  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test('context request will share cookie storage with its browser context', async ({  \n  page,  \n  context,  \n}) => {  \n  await context.route('https://www.github.com/', async route => {  \n    // Send an API request that shares cookie storage with the browser context.  \n    const response = await context.request.fetch(route.request());  \n    const responseHeaders = response.headers();  \n  \n    // The response will have 'Set-Cookie' header.  \n    const responseCookies = new Map(responseHeaders['set-cookie']  \n        .split('\\n')  \n        .map(c => c.split(';', 2)[0].split('=')));  \n    // The response will have 3 cookies in 'Set-Cookie' header.  \n    assert(responseCookies.size).toBe(3);  \n    const contextCookies = await context.cookies();  \n    // The browser context will already contain all the cookies from the API response.  \n    assert(new Map(contextCookies.map(({ name, value }) =>  \n      [name, value])  \n    )).toEqual(responseCookies);  \n  \n    await route.fulfill({  \n      response,  \n      headers: { ...responseHeaders, foo: 'bar' },  \n    });  \n  });  \n  await page.navigate('https://www.github.com/');  \n});", "output": "test('context request will share cookie storage with its browser context', async ({  \n  page,  \n  context,  \n}) => {  \n  await context.route('https://www.github.com/', async route => {  \n    // Send an API request that shares cookie storage with the browser context.  \n    const response = await context.request.fetch(route.request());  \n    const responseHeaders = response.headers();  \n  \n    // The response will have 'Set-Cookie' header.  \n    const responseCookies = new Map(responseHeaders['set-cookie']  \n        .split('\\n')  \n        .map(c => c.split(';', 2)[0].split('=')));  \n    // The response will have 3 cookies in 'Set-Cookie' header.  \n    expect(responseCookies.size).toBe(3);  \n    const contextCookies = await context.cookies();  \n    // The browser context will already contain all the cookies from the API response.  \n    expect(new Map(contextCookies.map(({ name, value }) =>  \n      [name, value])  \n    )).toEqual(responseCookies);  \n  \n    await route.fulfill({  \n      response,  \n      headers: { ...responseHeaders, foo: 'bar' },  \n    });  \n  });  \n  await page.goto('https://www.github.com/');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/api-testing", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: In most cases, it'll be written in one line:", "input": "", "output": "await page.getByRole('link', { name: 'Get started' }).click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/writing-tests"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  await expect(page).toHaveScreenshot({ stylePath: path.join(__dirname, 'screenshot.css') });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "<div id=\"current-time\" data-testid=\"current-time\"></div>  \n<script>  \n  const renderTime = () => {  \n    document.getElementById('current-time').textContent =  \n        new Date().toLocaleString();  \n  };  \n  setInterval(renderTime, 1000);  \n</script>  \n\n\n\n// Initialize clock with a specific time, let the page load naturally.  \nawait page.clock.install({ time: new Date('2024-02-02T08:00:00') });  \nawait page.navigate('http://localhost:3333');  \n  \n// Pause the time flow, stop the timers, you now have manual control  \n// over the page time.  \nawait page.clock.pauseAt(new Date('2024-02-02T10:00:00'));  \nawait assert(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \n// Tick through time manually, firing all timers in the process.  \n// In this case, time will be updated in the screen 2 times.  \nawait page.clock.runFor(2000);  \nawait assert(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:02 AM');", "output": "<div id=\"current-time\" data-testid=\"current-time\"></div>  \n<script>  \n  const renderTime = () => {  \n    document.getElementById('current-time').textContent =  \n        new Date().toLocaleString();  \n  };  \n  setInterval(renderTime, 1000);  \n</script>  \n\n\n\n// Initialize clock with a specific time, let the page load naturally.  \nawait page.clock.install({ time: new Date('2024-02-02T08:00:00') });  \nawait page.goto('http://localhost:3333');  \n  \n// Pause the time flow, stop the timers, you now have manual control  \n// over the page time.  \nawait page.clock.pauseAt(new Date('2024-02-02T10:00:00'));  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \n// Tick through time manually, firing all timers in the process.  \n// In this case, time will be updated in the screen 2 times.  \nawait page.clock.runFor(2000);  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:02 AM');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/clock", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.locator('text=/Log\\\\s*in/i').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "my-test.js", "output": "const base = require('@playwright/test');  \n  \nexports.test = base.test.extend({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  person: ['John', { option: true }],  \n  \n  // Override default \"page\" fixture.  \n  page: async ({ page, person }, use) => {  \n    await page.goto('/chat');  \n    // We use \"person\" parameter as a \"name\" for the chat room.  \n    await page.getByLabel('User Name').fill(person);  \n    await page.getByText('Enter chat room').click();  \n    // Each test will get a \"page\" that already has the person name.  \n    await use(page);  \n  },  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert(page.getByRole('listitem')).toHaveCount(3);", "output": "await expect(page.getByRole('listitem')).toHaveCount(3);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "// This is less fragile than snapshotting the entire violations array.  \nexpect(violationFingerprints(accessibilityScanResults)).toMatchSnapshot();  \n  \n// my-test-utils.js  \nfunction violationFingerprints(accessibilityScanResults) {  \n  const violationFingerprints = accessibilityScanResults.violations.map(violation => ({  \n    rule: violation.id,  \n    // These are CSS selectors which uniquely identify each element with  \n    // a violation of the rule in question.  \n    targets: violation.nodes.map(node => node.target),  \n  }));  \n  \n  return JSON.stringify(violationFingerprints, null, 2);  \n}", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({ userAgent: 'My user agent' });  \n  \ntest('my user agent test', async ({ page }) => {  \n  // ...  \n});  \n\n\n\nconst context = await browser.newContext({  \n  userAgent: 'My user agent'  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: ticking through time manually.", "input": "", "output": "// Initialize clock and let the page load naturally.  \nawait page.clock.install({ time: new Date('2024-02-02T08:00:00') });  \nawait page.goto('http://localhost:3333');  \n  \n// Pretend that the user closed the laptop lid and opened it again at 10am,  \n// Pause the time once reached that point.  \nawait page.clock.pauseAt(new Date('2024-02-02T10:00:00'));  \n  \n// Assert the page state.  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \n// Close the laptop lid again and open it at 10:30am.  \nawait page.clock.fastForward('30:00');  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:30:00 AM');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "You can also introduce a one-off handler for a specific test.", "output": "import { http, HttpResponse } from 'msw';  \n  \ntest('example test', async ({ mount, router }) => {  \n  await router.use(http.get('/data', async ({ request }) => {  \n    return HttpResponse.json({ value: 'mocked' });  \n  }));  \n  \n  // test as usual, your handler is active  \n  // ...  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test for the following scenario: Here is an example of excluding one element from being scanned in one specific test:", "input": "", "output": "test('should not have any accessibility violations outside of elements with known issues', async ({  \n  page,  \n}) => {  \n  await page.goto('https://your-site.com/page-with-known-issues');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .exclude('#element-with-known-issue')  \n      .analyze();  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "First script\u200b | In our first script, we will navigate to `https://playwright.dev/` and take a screenshot in WebKit.", "output": "const { webkit } = require('playwright');  \n  \n(async () => {  \n  const browser = await webkit.launch();  \n  const page = await browser.newPage();  \n  await page.goto('https://playwright.dev/');  \n  await page.screenshot({ path: `example.png` });  \n  await browser.close();  \n})();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/library"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Print dialogs\u200b | In order to assert that a print dialog via [`window.print`](https://developer.mozilla.org/en-US/docs/Web/API/Window/print) was triggered, you can use the following snippet:", "output": "await page.goto('<url>');  \n  \nawait page.evaluate('(() => {window.waitForPrintDialog = new Promise(f => window.print = f);})()');  \nawait page.getByText('Print it!').click();  \n  \nawait page.waitForFunction('window.waitForPrintDialog');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/dialogs"}}
{"instruction": "Generate a Playwright test for the following scenario: Behavior Changes\u200b | [expect(locator).toHaveAttribute()](/docs/api/class-locatorassertions#locator-assertions-to-have-attribute) with an empty value does not match missing attribute anymore. For example, the following snippet will succeed when `button` **does not** have a `disabled` attribute.", "input": "", "output": "await expect(page.getByRole('button')).toHaveAttribute('disabled', '');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "[`expect(locator).toBeChecked({ checked })`](/docs/api/class-locatorassertions#locator-assertions-to-be-checked) | Each locator can now be optionally filtered by the text it contains:", "output": "await page.locator('li', { hasText: 'my item' }).locator('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "navigation"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Group tests\u200b | You can group tests to give them a logical name or to scope before/after hooks to the group.", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('two tests', () => {  \n  test('one', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('two', async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "If the action that triggers the new page is unknown, the following pattern can be used.", "output": "// Get all new pages (including popups) in the context  \ncontext.on('page', async page => {  \n  await page.waitForLoadState();  \n  console.log(await page.title());  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/pages"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Navigate the page  \nawait page.navigate('https://example.com');", "output": "// Navigate the page  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/navigations", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Test inactivity monitoring\u200b | Inactivity monitoring is a common feature in web applications that logs out users after a period of inactivity. Testing this feature can be tricky because you need to wait for a long time to see the effect. With the help of the clock, you can speed up time and test this feature quickly.", "output": "<div id=\"remaining-time\" data-testid=\"remaining-time\"></div>  \n<script>  \n  const endTime = Date.now() + 5 * 60_000;  \n  const renderTime = () => {  \n    const diffInSeconds = Math.round((endTime - Date.now()) / 1000);  \n    if (diffInSeconds <= 0) {  \n      document.getElementById('remaining-time').textContent =  \n        'You have been logged out due to inactivity.';  \n    } else {  \n      document.getElementById('remaining-time').textContent =  \n        `You will be logged out in ${diffInSeconds} seconds.`;  \n    }  \n    setTimeout(renderTime, 1000);  \n  };  \n  renderTime();  \n</script>  \n<button type=\"button\">Interaction</button>  \n\n\n\n// Initial time does not matter for the test, so we can pick current time.  \nawait page.clock.install();  \nawait page.goto('http://localhost:3333');  \n// Interact with the page  \nawait page.getByRole('button').click();  \n  \n// Fast forward time 5 minutes as if the user did not do anything.  \n// Fast forward is like closing the laptop lid and opening it after 5 minutes.  \n// All the timers due will fire once immediately, as in the real browser.  \nawait page.clock.fastForward('05:00');  \n  \n// Check that the user was logged out automatically.  \nawait expect(page.getByText('You have been logged out due to inactivity.')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/clock"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Using the following, Playwright will run your WebView2 application as a sub-process, assign a unique user data directory to it and provide the [Page](/docs/api/class-page \"Page\") instance to your test: | webView2Test.ts", "output": "import { test as base } from '@playwright/test';  \nimport fs from 'fs';  \nimport os from 'os';  \nimport path from 'path';  \nimport childProcess from 'child_process';  \n  \nconst EXECUTABLE_PATH = path.join(  \n    __dirname,  \n    '../../webview2-app/bin/Debug/net8.0-windows/webview2.exe',  \n);  \n  \nexport const test = base.extend({  \n  browser: async ({ playwright }, use, testInfo) => {  \n    const cdpPort = 10000 + testInfo.workerIndex;  \n    // Make sure that the executable exists and is executable  \n    fs.accessSync(EXECUTABLE_PATH, fs.constants.X_OK);  \n    const userDataDir = path.join(  \n        fs.realpathSync.native(os.tmpdir()),  \n        `playwright-webview2-tests/user-data-dir-${testInfo.workerIndex}`,  \n    );  \n    const webView2Process = childProcess.spawn(EXECUTABLE_PATH, [], {  \n      shell: true,  \n      env: {  \n        ...process.env,  \n        WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS: `--remote-debugging-port=${cdpPort}`,  \n        WEBVIEW2_USER_DATA_FOLDER: userDataDir,  \n      }  \n    });  \n    await new Promise<void>(resolve => webView2Process.stdout.on('data', data => {  \n      if (data.toString().includes('WebView2 initialized'))  \n        resolve();  \n    }));  \n    const browser = await playwright.chromium.connectOverCDP(`http://127.0.0.1:${cdpPort}`);  \n    await use(browser);  \n    await browser.close();  \n    childProcess.execSync(`taskkill /pid ${webView2Process.pid} /T /F`);  \n    fs.rmdirSync(userDataDir, { recursive: true });  \n  },  \n  context: async ({ browser }, use) => {  \n    const context = browser.contexts()[0];  \n    await use(context);  \n  },  \n  page: async ({ context }, use) => {  \n    const page = context.pages()[0];  \n    await use(page);  \n  },  \n});  \n  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/webview2"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test } from './my-test';  \n  \ntest('test 1', async ({ page, person }) => {  \n  await page.goto(`/index.html`);  \n  await expect(page.locator('#node')).toContainText(person);  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parameterize", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const locator = page.getByText('This interstitial covers the button');  \nawait page.addLocatorHandler(locator, async overlay => {  \n  await overlay.locator('#close').click();  \n}, { times: 3, noWaitAfter: true });  \n// Run your tests that can be interrupted by the overlay.  \n// ...  \nawait page.removeLocatorHandler(locator);", "output": "const locator = page.getByText('This interstitial covers the button');  \nawait page.addLocatorHandler(locator, async overlay => {  \n  await overlay.locator('#close').click();  \n}, { times: 3, noWaitAfter: true });  \n// Run your tests that can be interrupted by the overlay.  \n// ...  \nawait page.removeLocatorHandler(locator);", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Variations\u200b | Set up route on the entire browser context with [browserContext.route()](/docs/api/class-browsercontext#browser-context-route) or page with [page.route()](/docs/api/class-page#page-route). It will apply to popup windows and opened links.", "output": "await browserContext.route('**/api/login', route => route.fulfill({  \n  status: 200,  \n  body: 'accept',  \n}));  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.getByRole('button', { name: 'Sign in' }).click();", "output": "await page.getByRole('button', { name: 'Sign in' }).click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as base, type Page, type Locator } from '@playwright/test';  \n  \n// Page Object Model for the \"admin\" page.  \n// Here you can add locators and helper methods specific to the admin page.  \nclass AdminPage {  \n  // Page signed in as \"admin\".  \n  page: Page;  \n  \n  // Example locator pointing to \"Welcome, Admin\" greeting.  \n  greeting: Locator;  \n  \n  constructor(page: Page) {  \n    this.page = page;  \n    this.greeting = page.locator('#greeting');  \n  }  \n}  \n  \n// Page Object Model for the \"user\" page.  \n// Here you can add locators and helper methods specific to the user page.  \nclass UserPage {  \n  // Page signed in as \"user\".  \n  page: Page;  \n  \n  // Example locator pointing to \"Welcome, User\" greeting.  \n  greeting: Locator;  \n  \n  constructor(page: Page) {  \n    this.page = page;  \n    this.greeting = page.locator('#greeting');  \n  }  \n}  \n  \n// Declare the types of your fixtures.  \ntype MyFixtures = {  \n  adminPage: AdminPage;  \n  userPage: UserPage;  \n};  \n  \nexport * from '@playwright/test';  \nexport const test = base.extend<MyFixtures>({  \n  adminPage: async ({ browser }, use) => {  \n    const context = await browser.newContext({ storageState: 'playwright/.auth/admin.json' });  \n    const adminPage = new AdminPage(await context.newPage());  \n    await use(adminPage);  \n    await context.close();  \n  },  \n  userPage: async ({ browser }, use) => {  \n    const context = await browser.newContext({ storageState: 'playwright/.auth/user.json' });  \n    const userPage = new UserPage(await context.newPage());  \n    await use(userPage);  \n    await context.close();  \n  },  \n});", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/auth", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as teardown } from '@playwright/test';  \n  \nteardown('delete database', async ({ }) => {  \n  console.log('deleting test database...');  \n  // Delete the database  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest('my test', async ({ page }, testInfo) => {  \n  if (testInfo.retry)  \n    await cleanSomeCachesOnTheServer();  \n  // ...  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('my test', async ({ page }, testInfo) => {  \n  if (testInfo.retry)  \n    await cleanSomeCachesOnTheServer();  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-retries", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "An example of registering selector engine that queries elements based on a tag name: | baseTest.ts", "output": "import { test as base } from '@playwright/test';  \n  \nexport { expect } from '@playwright/test';  \n  \n// Must be a function that evaluates to a selector engine instance.  \nconst createTagNameEngine = () => ({  \n  // Returns the first element matching given selector in the root's subtree.  \n  query(root, selector) {  \n    return root.querySelector(selector);  \n  },  \n  \n  // Returns all elements matching given selector in the root's subtree.  \n  queryAll(root, selector) {  \n    return Array.from(root.querySelectorAll(selector));  \n  }  \n});  \n  \nexport const test = base.extend<{}, { selectorRegistration: void }>({  \n  // Register selectors once per worker.  \n  selectorRegistration: [async ({ playwright }, use) => {  \n    // Register the engine. Selectors will be prefixed with \"tag=\".  \n    await playwright.selectors.register('tag', createTagNameEngine);  \n    await use();  \n  }, { scope: 'worker', auto: true }],  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/extensibility"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as setup, expect } from '@playwright/test';  \n  \nconst adminFile = 'playwright/.auth/admin.json';  \n  \nsetup('authenticate as admin', async ({ page }) => {  \n  // Perform authentication steps. Replace these actions with your own.  \n  await page.goto('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('admin');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n  // Wait until the page receives the cookies.  \n  //  \n  // Sometimes login flow sets cookies in the process of several redirects.  \n  // Wait for the final URL to ensure that the cookies are actually set.  \n  await page.waitForURL('https://github.com/');  \n  // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n  await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n  // End of authentication steps.  \n  \n  await page.context().storageState({ path: adminFile });  \n});  \n  \nconst userFile = 'playwright/.auth/user.json';  \n  \nsetup('authenticate as user', async ({ page }) => {  \n  // Perform authentication steps. Replace these actions with your own.  \n  await page.goto('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('user');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n  // Wait until the page receives the cookies.  \n  //  \n  // Sometimes login flow sets cookies in the process of several redirects.  \n  // Wait for the final URL to ensure that the cookies are actually set.  \n  await page.waitForURL('https://github.com/');  \n  // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n  await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n  // End of authentication steps.  \n  \n  await page.context().storageState({ path: userFile });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/auth", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Just mention fixture in your test function argument, and test runner will take care of it. Fixtures are also available in hooks and other fixtures. If you use TypeScript, fixtures will have the right type. | Below we use the `todoPage` and `settingsPage` fixtures defined above.", "output": "import { test, expect } from './my-test';  \n  \ntest.beforeEach(async ({ settingsPage }) => {  \n  await settingsPage.switchToDarkMode();  \n});  \n  \ntest('basic test', async ({ todoPage, page }) => {  \n  await todoPage.addToDo('something nice');  \n  await expect(page.getByTestId('todo-title')).toContainText(['something nice']);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test for the following scenario: When [page.close()](/docs/api/class-page#page-close) is invoked with the truthy [runBeforeUnload](/docs/api/class-page#page-close-option-run-before-unload) value, the page runs its unload handlers. This is the only case when [page.close()](/docs/api/class-page#page-close) does not wait for the page to actually close, because it might be that the page stays open in the end of the operation. | You can register a dialog handler to handle the `beforeunload` dialog yourself:", "input": "", "output": "page.on('dialog', async dialog => {  \n  assert(dialog.type() === 'beforeunload');  \n  await dialog.dismiss();  \n});  \nawait page.close({ runBeforeUnload: true });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/dialogs"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "[`visible`](/docs/other-locators#css-matching-only-visible-elements) selector engine is equivalent to the `:visible` pseudo class, but could be combined with other selector engines.", "output": "// select the first button among all buttons  \nawait button.click('button >> nth=0');  \n// or if you are using locators, you can use first(), nth() and last()  \nawait page.locator('button').first().click();  \n  \n// click a visible button  \nawait button.click('button >> visible=true');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: Set the base URL and storage state for all tests: | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Base URL to use in actions like `await page.goto('/')`.  \n    baseURL: 'http://127.0.0.1:3000',  \n  \n    // Populates context with given storage state.  \n    storageState: 'state.json',  \n  },  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-use-options"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [  \n    ['list'],  \n    ['json', {  outputFile: 'test-results.json' }]  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const locator = page  \n    .frameLocator('#my-frame')  \n    .getByRole('button', { name: 'Sign in' });  \n  \nawait locator.click();", "output": "const locator = page  \n    .frameLocator('#my-frame')  \n    .getByRole('button', { name: 'Sign in' });  \n  \nawait locator.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: 'line',  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: 'line',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "const locator = page.getByRole('button');  \nawait expect(locator).toHaveAccessibleName('Submit');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Interactions\u200b | Performing actions starts with locating the elements. Playwright uses [Locators API](/docs/locators) for that. Locators represent a way to find element(s) on the page at any moment, learn more about the [different types](/docs/locators) of locators available. Playwright will wait for the element to be [actionable](/docs/actionability) prior to performing the action, so there is no need to wait for it to become available.", "output": "// Create a locator.  \nconst getStarted = page.getByRole('link', { name: 'Get started' });  \n  \n// Click it.  \nawait getStarted.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/writing-tests"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: 'Product 2' })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const browser = await chromium.launch();  \nconst context = await browser.newContext();  \n  \n// Start tracing before creating / navigating a page.  \nawait context.tracing.start({ screenshots: true, snapshots: true });  \n  \nconst page = await context.newPage();  \nawait page.goto('https://playwright.dev');  \n  \n// Stop tracing and export it into a zip archive.  \nawait context.tracing.stop({ path: 'trace.zip' });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Here is what a typical component test looks like: | App.spec.tsx", "input": "", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport App from './App';  \n  \n// Let's test component in a dark scheme!  \ntest.use({ colorScheme: 'dark' });  \n  \ntest('should render', async ({ mount }) => {  \n  const component = await mount(<App></App>);  \n  \n  // As with any Playwright test, assert locator text.  \n  await expect(component).toContainText('React');  \n  // Or do a screenshot \ud83d\ude80  \n  await expect(component).toHaveScreenshot();  \n  // Or use any Playwright method  \n  await component.click();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: Here is the easiest way to obtain a [JSHandle](/docs/api/class-jshandle \"JSHandle\").", "input": "", "output": "const jsHandle = await page.evaluateHandle('window');  \n//  Use jsHandle for evaluations.", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/handles"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "const frameLocator = page.frameLocator('iframe[name=\"embedded\"]');  \n// ...  \nconst locator = frameLocator.owner();  \nawait expect(locator).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: Most of the time, you should input text with [locator.fill()](/docs/api/class-locator#locator-fill). See the Text input section above. You only need to type characters if there is special keyboard handling on the page. | Type into the field character by character, as if it was a user with a real keyboard with [locator.pressSequentially()](/docs/api/class-locator#locator-press-sequentially).", "input": "", "output": "// Press keys one by one  \nawait page.locator('#area').pressSequentially('Hello World!');", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "First we add a new project with the name 'setup db'. We then give it a [testProject.testMatch](/docs/api/class-testproject#test-project-test-match) property in order to match the file called `global.setup.ts`: | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  testDir: './tests',  \n  // ...  \n  projects: [  \n    {  \n      name: 'setup db',  \n      testMatch: /global\\.setup\\.ts/,  \n    },  \n    // {  \n    //   other project  \n    // }  \n  ]  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Generate a Playwright test for the following scenario: Take a look at the following example to see how to write a test. | tests/example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('has title', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  \n  // Expect a title \"to contain\" a substring.  \n  await expect(page).toHaveTitle(/Playwright/);  \n});  \n  \ntest('get started link', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  \n  // Click the get started link.  \n  await page.getByRole('link', { name: 'Get started' }).click();  \n  \n  // Expects page to have a heading with the name of Installation.  \n  await expect(page.getByRole('heading', { name: 'Installation' })).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/writing-tests"}}
{"instruction": "Generate a Playwright test for the following scenario: This method will emit all the necessary keyboard events, with all the `keydown`, `keyup`, `keypress` events in place. You can even specify the optional `delay` between the key presses to simulate real user behavior. | Keys and shortcuts\u200b", "input": "", "output": "// Hit Enter  \nawait page.getByText('Submit').press('Enter');  \n  \n// Dispatch Control+Right  \nawait page.getByRole('textbox').press('Control+ArrowRight');  \n  \n// Press $ sign on keyboard  \nawait page.getByRole('textbox').press('$');", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Generate a Playwright test for the following scenario: Locate an item by its test id of \"orange\" and then click it.", "input": "", "output": "await page.getByTestId('orange').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Waiting for navigation\u200b | Clicking an element could trigger multiple navigations. In these cases, it is recommended to explicitly [page.waitForURL()](/docs/api/class-page#page-wait-for-url) to a specific url.", "output": "await page.getByText('Click me').click();  \nawait page.waitForURL('**/login');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/navigations"}}
{"instruction": "Generate a Playwright test for the following scenario: Specify `globalSetup`, `baseURL` and `storageState` in the configuration file. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  globalSetup: require.resolve('./global-setup'),  \n  use: {  \n    baseURL: 'http://localhost:3000/',  \n    storageState: 'state.json',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Generate a Playwright test for the following scenario: You can put your tests in helper functions in multiple files. Consider the following example where tests are not defined directly in the file, but rather in a wrapper function. | feature-a.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \nexport default function createTests() {  \n  test('feature-a example test', async ({ page }) => {  \n    // ... test goes here  \n  });  \n}", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Generate a Playwright test for the following scenario: Multiple methods like [locator.click()](/docs/api/class-locator#locator-click) or [locator.press()](/docs/api/class-locator#locator-press) now support a `ControlOrMeta` modifier key. This key maps to `Meta` on macOS and maps to `Control` on Windows and Linux.", "input": "", "output": "// Press the common keyboard shortcut Control+S or Meta+S to trigger a \"Save\" operation.  \nawait page.keyboard.press('ControlOrMeta+S');", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Initialize clock and let the page load naturally.  \nawait page.clock.install({ time: new Date('2024-02-02T08:00:00') });  \nawait page.navigate('http://localhost:3333');  \n  \n// Pretend that the user closed the laptop lid and opened it again at 10am,  \n// Pause the time once reached that point.  \nawait page.clock.pauseAt(new Date('2024-02-02T10:00:00'));  \n  \n// Assert the page state.  \nawait assert(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \n// Close the laptop lid again and open it at 10:30am.  \nawait page.clock.fastForward('30:00');  \nawait assert(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:30:00 AM');", "output": "// Initialize clock and let the page load naturally.  \nawait page.clock.install({ time: new Date('2024-02-02T08:00:00') });  \nawait page.goto('http://localhost:3333');  \n  \n// Pretend that the user closed the laptop lid and opened it again at 10am,  \n// Pause the time once reached that point.  \nawait page.clock.pauseAt(new Date('2024-02-02T10:00:00'));  \n  \n// Assert the page state.  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \n// Close the laptop lid again and open it at 10:30am.  \nawait page.clock.fastForward('30:00');  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:30:00 AM');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: 'list',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "This will only find a second button, because it is visible, and then click it.", "output": "await page.locator('button').locator('visible=true').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test for the following scenario: Configure projects for multiple browsers\u200b | By using **projects** you can run your tests in multiple browsers such as chromium, webkit and firefox as well as branded browsers such as Google Chrome and Microsoft Edge. Playwright can also run on emulated tablet and mobile devices. See the [registry of device parameters](https://github.com/microsoft/playwright/blob/main/packages/playwright-core/src/server/deviceDescriptorsSource.json) for a complete list of selected desktop, tablet and mobile devices.", "input": "", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n    },  \n  \n    {  \n      name: 'firefox',  \n      use: { ...devices['Desktop Firefox'] },  \n    },  \n  \n    {  \n      name: 'webkit',  \n      use: { ...devices['Desktop Safari'] },  \n    },  \n  \n    /* Test against mobile viewports. */  \n    {  \n      name: 'Mobile Chrome',  \n      use: { ...devices['Pixel 5'] },  \n    },  \n    {  \n      name: 'Mobile Safari',  \n      use: { ...devices['iPhone 12'] },  \n    },  \n  \n    /* Test against branded browsers. */  \n    {  \n      name: 'Microsoft Edge',  \n      use: {  \n        ...devices['Desktop Edge'],  \n        channel: 'msedge'  \n      },  \n    },  \n    {  \n      name: 'Google Chrome',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        channel: 'chrome'  \n      },  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-projects"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "Error: should be logged in  \n  \n    Call log:  \n      - assert.toBeVisible with timeout 5000ms  \n      - waiting for \"getByText('Name')\"  \n  \n  \n      2 |  \n      3 | test('example test', async({ page }) => {  \n    > 4 |   await assert(page.getByText('Name'), 'should be logged in').toBeVisible();  \n        |                                                                  ^  \n      5 | });  \n      6 |", "output": "Error: should be logged in  \n  \n    Call log:  \n      - expect.toBeVisible with timeout 5000ms  \n      - waiting for \"getByText('Name')\"  \n  \n  \n      2 |  \n      3 | test('example test', async({ page }) => {  \n    > 4 |   await expect(page.getByText('Name'), 'should be logged in').toBeVisible();  \n        |                                                                  ^  \n      5 | });  \n      6 |", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Miscellaneous\u200b | Method [locator.setInputFiles()](/docs/api/class-locator#locator-set-input-files) now supports uploading a directory for `<input type=file webkitdirectory>` elements.", "output": "await page.getByLabel('Upload directory').setInputFiles(path.join(__dirname, 'mydir'));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: warning | Google Chrome and Microsoft Edge have switched to a [new headless mode](https://developer.chrome.com/docs/chromium/headless) implementation that is closer to a regular headed mode. This differs from [chromium headless shell](https://developer.chrome.com/blog/chrome-headless-shell) that is used in Playwright by default when running headless, so expect different behavior in some cases. See [issue #33566](https://github.com/microsoft/playwright/issues/33566) fore details.", "input": "", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    /* Test against branded browsers. */  \n    {  \n      name: 'Google Chrome',  \n      use: { ...devices['Desktop Chrome'], channel: 'chrome' }, // or 'chrome-beta'  \n    },  \n    {  \n      name: 'Microsoft Edge',  \n      use: { ...devices['Desktop Edge'], channel: 'msedge' }, // or \"msedge-beta\" or 'msedge-dev'  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/browsers"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You can detect retries at runtime with [testInfo.retry](/docs/api/class-testinfo#test-info-retry), which is accessible to any test, hook or fixture. Here is an example that clears some server-side state before a retry.", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('my test', async ({ page }, testInfo) => {  \n  if (testInfo.retry)  \n    await cleanSomeCachesOnTheServer();  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-retries"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Start waiting for download before clicking. Note no await.  \nconst downloadPromise = page.waitForEvent('download');  \nawait page.getByText('Download file').click();  \nconst download = await downloadPromise;  \n  \n// Wait for the download process to complete and save the downloaded file somewhere.  \nawait download.saveAs('/path/to/save/at/' + download.suggestedFilename());", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/downloads", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Give failing tests 3 retry attempts  \n  retries: 3,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-retries", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \nexport default function createTests() {  \n  test.use({ viewport: { width: 500, height: 500 } });  \n  \n  test('feature-b example test', async ({ page }) => {  \n    // ... test goes here  \n  });  \n}", "output": "import { test, expect } from '@playwright/test';  \n  \nexport default function createTests() {  \n  test.use({ viewport: { width: 500, height: 500 } });  \n  \n  test('feature-b example test', async ({ page }) => {  \n    // ... test goes here  \n  });  \n}", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parallel", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: For multi-page scenarios, you can access the video file associated with the page via the [page.video()](/docs/api/class-page#page-video).", "input": "", "output": "const path = await page.video().path();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/videos"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  storageState: async ({}, use) => {  \n    const cookie = await getAuthCookie();  \n    await use({ cookies: [cookie] });  \n  },  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { mergeTests, mergeExpects } from '@playwright/test';  \nimport { test as dbTest, assert as dbExpect } from 'database-test-utils';  \nimport { test as a11yTest, assert as a11yExpect } from 'a11y-test-utils';  \n  \nexport const test = mergeTests(dbTest, a11yTest);  \nexport const assert = mergeExpects(dbExpect, a11yExpect);", "output": "import { mergeTests, mergeExpects } from '@playwright/test';  \nimport { test as dbTest, expect as dbExpect } from 'database-test-utils';  \nimport { test as a11yTest, expect as a11yExpect } from 'a11y-test-utils';  \n  \nexport const test = mergeTests(dbTest, a11yTest);  \nexport const expect = mergeExpects(dbExpect, a11yExpect);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from './fixtures';  \n  \ntest('passes', async ({ page, database }) => {  \n  await assert(database).toHaveDatabaseUser('admin');  \n  await assert(page).toPassA11yAudit();  \n});", "output": "import { test, expect } from './fixtures';  \n  \ntest('passes', async ({ page, database }) => {  \n  await expect(database).toHaveDatabaseUser('admin');  \n  await expect(page).toPassA11yAudit();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const requestContext = await request.newContext({  \n  httpCredentials: {  \n    username: 'user',  \n    password: 'passwd'  \n  }  \n});  \nawait requestContext.get(`https://api.example.com/login`);  \n// Save storage state into the file.  \nawait requestContext.storageState({ path: 'state.json' });  \n  \n// Create a new context with the saved storage state.  \nconst context = await browser.newContext({ storageState: 'state.json' });", "output": "const requestContext = await request.newContext({  \n  httpCredentials: {  \n    username: 'user',  \n    password: 'passwd'  \n  }  \n});  \nawait requestContext.get(`https://api.example.com/login`);  \n// Save storage state into the file.  \nawait requestContext.storageState({ path: 'state.json' });  \n  \n// Create a new context with the saved storage state.  \nconst context = await browser.newContext({ storageState: 'state.json' });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/api-testing", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: First we add the [testProject.teardown](/docs/api/class-testproject#test-project-teardown) property to our setup project with the name 'cleanup db' which is the name we gave to our teardown project in the previous step: | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  testDir: './tests',  \n  // ...  \n  projects: [  \n    {  \n      name: 'setup db',  \n      testMatch: /global\\.setup\\.ts/,  \n      teardown: 'cleanup db',  \n    },  \n    {  \n      name: 'cleanup db',  \n      testMatch: /global\\.teardown\\.ts/,  \n    },  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n      dependencies: ['setup db'],  \n    },  \n  ]  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Generate a Playwright test for the following scenario: Alternatively, in a worker fixture: | playwright/fixtures.ts", "input": "", "output": "import { test as baseTest, request } from '@playwright/test';  \nimport fs from 'fs';  \nimport path from 'path';  \n  \nexport * from '@playwright/test';  \nexport const test = baseTest.extend<{}, { workerStorageState: string }>({  \n  // Use the same storage state for all tests in this worker.  \n  storageState: ({ workerStorageState }, use) => use(workerStorageState),  \n  \n  // Authenticate once per worker with a worker-scoped fixture.  \n  workerStorageState: [async ({}, use) => {  \n    // Use parallelIndex as a unique identifier for each worker.  \n    const id = test.info().parallelIndex;  \n    const fileName = path.resolve(test.info().project.outputDir, `.auth/${id}.json`);  \n  \n    if (fs.existsSync(fileName)) {  \n      // Reuse existing authentication state if any.  \n      await use(fileName);  \n      return;  \n    }  \n  \n    // Important: make sure we authenticate in a clean environment by unsetting storage state.  \n    const context = await request.newContext({ storageState: undefined });  \n  \n    // Acquire a unique account, for example create a new one.  \n    // Alternatively, you can have a list of precreated accounts for testing.  \n    // Make sure that accounts are unique, so that multiple team members  \n    // can run tests at the same time without interference.  \n    const account = await acquireAccount(id);  \n  \n    // Send authentication request. Replace with your own.  \n    await context.post('https://github.com/login', {  \n      form: {  \n        'user': 'user',  \n        'password': 'password'  \n      }  \n    });  \n  \n    await context.storageState({ path: fileName });  \n    await context.dispose();  \n    await use(fileName);  \n  }, { scope: 'worker' }],  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Create a Playwright test that demonstrates the form_interaction pattern.", "input": "We can now use `todoPage` fixture as usual, and set the `defaultItem` option in the config file. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \nimport type { MyOptions } from './my-test';  \n  \nexport default defineConfig<MyOptions>({  \n  projects: [  \n    {  \n      name: 'shopping',  \n      use: { defaultItem: 'Buy milk' },  \n    },  \n    {  \n      name: 'wellbeing',  \n      use: { defaultItem: 'Exercise!' },  \n    },  \n  ]  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test for the following scenario: We can now use `todoPage` fixture as usual, and set the `defaultItem` option in the config file. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \nimport type { MyOptions } from './my-test';  \n  \nexport default defineConfig<MyOptions>({  \n  projects: [  \n    {  \n      name: 'shopping',  \n      use: { defaultItem: 'Buy milk' },  \n    },  \n    {  \n      name: 'wellbeing',  \n      use: { defaultItem: 'Exercise!' },  \n    },  \n  ]  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['html', { host: 'localhost', port: '9223' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  fullyParallel: true,  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  fullyParallel: true,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel", "type": "modification"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "note | Using serial is not recommended. It is usually better to make your tests isolated, so they can be run independently.", "output": "import { test, type Page } from '@playwright/test';  \n  \n// Annotate entire file as serial.  \ntest.describe.configure({ mode: 'serial' });  \n  \nlet page: Page;  \n  \ntest.beforeAll(async ({ browser }) => {  \n  page = await browser.newPage();  \n});  \n  \ntest.afterAll(async () => {  \n  await page.close();  \n});  \n  \ntest('runs first', async () => {  \n  await page.goto('https://playwright.dev/');  \n});  \n  \ntest('runs second', async () => {  \n  await page.getByText('Get Started').click();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-parallel", "type": "fixture"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.getByRole('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert(page.getByText('Welcome, John')).toBeVisible();", "output": "await expect(page.getByText('Welcome, John')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  assert: {  \n    // Maximum time assert() should wait for the condition to be met.  \n    timeout: 5000,  \n  \n    toHaveScreenshot: {  \n      // An acceptable amount of pixels that could be different, unset by default.  \n      maxDiffPixels: 10,  \n    },  \n  \n    toMatchSnapshot: {  \n      // An acceptable ratio of pixels that are different to the  \n      // total amount of pixels, between 0 and 1.  \n      maxDiffPixelRatio: 0.1,  \n    },  \n  },  \n  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  expect: {  \n    // Maximum time expect() should wait for the condition to be met.  \n    timeout: 5000,  \n  \n    toHaveScreenshot: {  \n      // An acceptable amount of pixels that could be different, unset by default.  \n      maxDiffPixels: 10,  \n    },  \n  \n    toMatchSnapshot: {  \n      // An acceptable ratio of pixels that are different to the  \n      // total amount of pixels, between 0 and 1.  \n      maxDiffPixelRatio: 0.1,  \n    },  \n  },  \n  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-configuration", "type": "modification"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "Now, each test file should import `test` from our fixtures file instead of `@playwright/test`. | tests/example.spec.ts", "output": "// Important: import our fixtures.  \nimport { test, expect } from '../playwright/fixtures';  \n  \ntest('test', async ({ dbUserName }) => {  \n  // Use the user name in the test.  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-parallel", "type": "fixture"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "CSS: elements matching one of the conditions\u200b | Comma-separated list of CSS selectors will match all elements that can be selected by one of the selectors in that list.", "output": "// Clicks a <button> that has either a \"Log in\" or \"Sign in\" text.  \nawait page.locator('button:has-text(\"Log in\"), button:has-text(\"Sign in\")').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Emulates the user locale.  \n    locale: 'en-GB',  \n  \n    // Emulates the user timezone.  \n    timezoneId: 'Europe/Paris',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/emulation", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Create a new `setup` project in the config and declare it as a [dependency](/docs/test-projects#dependencies) for all your testing projects. This project will always run and authenticate before all the tests. All testing projects should use the authenticated state as `storageState`. | playwright.config.ts", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    // Setup project  \n    { name: 'setup', testMatch: /.*\\.setup\\.ts/ },  \n  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        // Use prepared auth state.  \n        storageState: 'playwright/.auth/user.json',  \n      },  \n      dependencies: ['setup'],  \n    },  \n  \n    {  \n      name: 'firefox',  \n      use: {  \n        ...devices['Desktop Firefox'],  \n        // Use prepared auth state.  \n        storageState: 'playwright/.auth/user.json',  \n      },  \n      dependencies: ['setup'],  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  globalSetup: require.resolve('./global-setup'),  \n  use: {  \n    baseURL: 'http://localhost:3000/',  \n    storageState: 'state.json',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as baseTest, request } from '@playwright/test';  \nimport fs from 'fs';  \nimport path from 'path';  \n  \nexport * from '@playwright/test';  \nexport const test = baseTest.extend<{}, { workerStorageState: string }>({  \n  // Use the same storage state for all tests in this worker.  \n  storageState: ({ workerStorageState }, use) => use(workerStorageState),  \n  \n  // Authenticate once per worker with a worker-scoped fixture.  \n  workerStorageState: [async ({}, use) => {  \n    // Use parallelIndex as a unique identifier for each worker.  \n    const id = test.info().parallelIndex;  \n    const fileName = path.resolve(test.info().project.outputDir, `.auth/${id}.json`);  \n  \n    if (fs.existsSync(fileName)) {  \n      // Reuse existing authentication state if any.  \n      await use(fileName);  \n      return;  \n    }  \n  \n    // Important: make sure we authenticate in a clean environment by unsetting storage state.  \n    const context = await request.newContext({ storageState: undefined });  \n  \n    // Acquire a unique account, for example create a new one.  \n    // Alternatively, you can have a list of precreated accounts for testing.  \n    // Make sure that accounts are unique, so that multiple team members  \n    // can run tests at the same time without interference.  \n    const account = await acquireAccount(id);  \n  \n    // Send authentication request. Replace with your own.  \n    await context.post('https://github.com/login', {  \n      form: {  \n        'user': 'user',  \n        'password': 'password'  \n      }  \n    });  \n  \n    await context.storageState({ path: fileName });  \n    await context.dispose();  \n    await use(fileName);  \n  }, { scope: 'worker' }],  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/auth", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test.describe('chromium only', () => {  \n  test.skip(({ browserName }) => browserName !== 'chromium', 'Chromium only!');  \n  \n  test.beforeAll(async () => {  \n    // This hook is only run in Chromium.  \n  });  \n  \n  test('test 1', async ({ page }) => {  \n    // This test is only run in Chromium.  \n  });  \n  \n  test('test 2', async ({ page }) => {  \n    // This test is only run in Chromium.  \n  });  \n});", "output": "test.describe('chromium only', () => {  \n  test.skip(({ browserName }) => browserName !== 'chromium', 'Chromium only!');  \n  \n  test.beforeAll(async () => {  \n    // This hook is only run in Chromium.  \n  });  \n  \n  test('test 1', async ({ page }) => {  \n    // This test is only run in Chromium.  \n  });  \n  \n  test('test 2', async ({ page }) => {  \n    // This test is only run in Chromium.  \n  });  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-annotations", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Retry blocks of code until all assertions pass:", "input": "", "output": "await expect(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  await expect(response).toBeOK();  \n}).toPass();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  retries: 1,  \n  use: {  \n    trace: 'on-first-retry',  \n  },  \n});  \n\n\n\nconst browser = await chromium.launch();  \nconst context = await browser.newContext();  \n  \n// Start tracing before creating / navigating a page.  \nawait context.tracing.start({ screenshots: true, snapshots: true });  \n  \nconst page = await context.newPage();  \nawait page.goto('https://playwright.dev');  \n  \n// Stop tracing and export it into a zip archive.  \nawait context.tracing.stop({ path: 'trace.zip' });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/trace-viewer", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest.use({  \n  geolocation: { longitude: 41.890221, latitude: 12.492348 },  \n  permissions: ['geolocation'],  \n});  \n  \ntest('my test with geolocation', async ({ page, context }) => {  \n  // overwrite the location for this test  \n  await context.setGeolocation({ longitude: 48.858455, latitude: 2.294474 });  \n});  \n\n\n\nawait context.setGeolocation({ longitude: 48.858455, latitude: 2.294474 });", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  geolocation: { longitude: 41.890221, latitude: 12.492348 },  \n  permissions: ['geolocation'],  \n});  \n  \ntest('my test with geolocation', async ({ page, context }) => {  \n  // overwrite the location for this test  \n  await context.setGeolocation({ longitude: 48.858455, latitude: 2.294474 });  \n});  \n\n\n\nawait context.setGeolocation({ longitude: 48.858455, latitude: 2.294474 });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Check all checkboxes!  \nconst checkboxes = page.getByRole('checkbox');  \nfor (const checkbox of await checkboxes.all())  \n  await checkbox.check();", "output": "// Check all checkboxes!  \nconst checkboxes = page.getByRole('checkbox');  \nfor (const checkbox of await checkboxes.all())  \n  await checkbox.check();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Mouse click\u200b | Performs a simple human click.", "output": "// Generic click  \nawait page.getByRole('button').click();  \n  \n// Double click  \nawait page.getByText('Item').dblclick();  \n  \n// Right click  \nawait page.getByText('Item').click({ button: 'right' });  \n  \n// Shift + click  \nawait page.getByText('Item').click({ modifiers: ['Shift'] });  \n  \n// Ctrl + click or Windows and Linux  \n// Meta + click on macOS  \nawait page.getByText('Item').click({ modifiers: ['ControlOrMeta'] });  \n  \n// Hover over element  \nawait page.getByText('Item').hover();  \n  \n// Click the top left corner  \nawait page.getByText('Item').click({ position: { x: 0, y: 0 } });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest.describe('navigation', () => {  \n  test.beforeEach(async ({ page }) => {  \n    // Go to the starting url before each test.  \n    await page.navigate('https://playwright.dev/');  \n  });  \n  \n  test('main navigation', async ({ page }) => {  \n    // Assertions use the assert API.  \n    await assert(page).toHaveURL('https://playwright.dev/');  \n  });  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('navigation', () => {  \n  test.beforeEach(async ({ page }) => {  \n    // Go to the starting url before each test.  \n    await page.goto('https://playwright.dev/');  \n  });  \n  \n  test('main navigation', async ({ page }) => {  \n    // Assertions use the expect API.  \n    await expect(page).toHaveURL('https://playwright.dev/');  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/writing-tests", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "JavaScript", "output": "import { chromium, devices } from 'playwright';  \nimport assert from 'node:assert';  \n  \n(async () => {  \n  // Setup  \n  const browser = await chromium.launch();  \n  const context = await browser.newContext(devices['iPhone 11']);  \n  const page = await context.newPage();  \n  \n  // The actual interesting bit  \n  await context.route('**.jpg', route => route.abort());  \n  await page.goto('https://example.com/');  \n  \n  assert(await page.title() === 'Example Domain'); // \ud83d\udc4e not a Web First assertion  \n  \n  // Teardown  \n  await context.close();  \n  await browser.close();  \n})();  \n\n\n\nconst assert = require('node:assert');  \nconst { chromium, devices } = require('playwright');  \n  \n(async () => {  \n  // Setup  \n  const browser = await chromium.launch();  \n  const context = await browser.newContext(devices['iPhone 11']);  \n  const page = await context.newPage();  \n  \n  // The actual interesting bit  \n  await context.route('**.jpg', route => route.abort());  \n  await page.goto('https://example.com/');  \n  \n  assert(await page.title() === 'Example Domain'); // \ud83d\udc4e not a Web First assertion  \n  \n  // Teardown  \n  await context.close();  \n  await browser.close();  \n})();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/library"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('context fetch', async ({ page }) => {  \n  // Do a GET request on behalf of page  \n  const response = await page.request.get('http://example.com/foo.json');  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { expect, test, devices } from '@playwright/test';  \n  \ntest.use(devices['iPhone 11']);  \n  \ntest('should be titled', async ({ page, context }) => {  \n  await context.route('**.jpg', route => route.abort());  \n  await page.goto('https://example.com/');  \n  \n  await expect(page).toHaveTitle('Example');  \n});  \n\n\n\nconst { expect, test, devices } = require('@playwright/test');  \n  \ntest.use(devices['iPhone 11']);  \n  \ntest('should be titled', async ({ page, context }) => {  \n  await context.route('**.jpg', route => route.abort());  \n  await page.goto('https://example.com/');  \n  \n  await expect(page).toHaveTitle('Example');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/library", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Webservers can sometimes take longer to boot up. In this case, you can increase the timeout to wait for the server to start. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Rest of your config...  \n  \n  // Run your local dev server before starting the tests  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n    timeout: 120 * 1000,  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-webserver"}}
{"instruction": "Generate a Playwright test for the following scenario: **Accessibility assertions** | [expect(locator).toHaveAccessibleName()](/docs/api/class-locatorassertions#locator-assertions-to-have-accessible-name) checks if the element has the specified accessible name:", "input": "", "output": "const locator = page.getByRole('button');  \nawait expect(locator).toHaveAccessibleName('Submit');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest('should use custom proxy on a new context', async ({ browser }) => {  \n  const context = await browser.newContext({  \n    proxy: {  \n      server: 'http://myproxy.com:3128',  \n    }  \n  });  \n  const page = await context.newPage();  \n  \n  await context.close();  \n});  \n\n\n\nconst browser = await chromium.launch();  \nconst context = await browser.newContext({  \n  proxy: { server: 'http://myproxy.com:3128' }  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('should use custom proxy on a new context', async ({ browser }) => {  \n  const context = await browser.newContext({  \n    proxy: {  \n      server: 'http://myproxy.com:3128',  \n    }  \n  });  \n  const page = await context.newPage();  \n  \n  await context.close();  \n});  \n\n\n\nconst browser = await chromium.launch();  \nconst context = await browser.newContext({  \n  proxy: { server: 'http://myproxy.com:3128' }  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/network", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Only test what you control. Don't try to test links to external sites or third party servers that you do not control. Not only is it time consuming and can slow down your tests but also you cannot control the content of the page you are linking to, or if there are cookie banners or overlay pages or anything else that might cause your test to fail. | Instead, use the [Playwright Network API](/docs/network#handle-requests) and guarantee the response needed.", "output": "await page.route('**/api/fetch_data_third_party_dependency', route => route.fulfill({  \n  status: 200,  \n  body: testData,  \n}));  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/best-practices"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('basic test', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  \n  await expect(page).toHaveTitle(/Playwright/);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-fixtures", "type": "completion"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({ userAgent: 'My user agent' });  \n  \ntest('my user agent test', async ({ page }) => {  \n  // ...  \n});  \n\n\n\nconst context = await browser.newContext({  \n  userAgent: 'My user agent'  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Click the third \"Buy\" button  \nawait page.locator(':nth-match(:text(\"Buy\"), 3)').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Don't use manual assertions\u200b | Don't use manual assertions that are not awaiting the expect. In the code below the await is inside the expect rather than before it. When using assertions such as `isVisible()` the test won't wait a single second, it will just check the locator is there and return immediately.", "output": "// \ud83d\udc4e  \nexpect(await page.getByText('welcome').isVisible()).toBe(true);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/best-practices"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test as setup, expect } from '@playwright/test';  \n  \nconst adminFile = 'playwright/.auth/admin.json';  \n  \nsetup('authenticate as admin', async ({ page }) => {  \n  // Perform authentication steps. Replace these actions with your own.  \n  await page.goto('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('admin');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n  // Wait until the page receives the cookies.  \n  //  \n  // Sometimes login flow sets cookies in the process of several redirects.  \n  // Wait for the final URL to ensure that the cookies are actually set.  \n  await page.waitForURL('https://github.com/');  \n  // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n  await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n  // End of authentication steps.  \n  \n  await page.context().storageState({ path: adminFile });  \n});  \n  \nconst userFile = 'playwright/.auth/user.json';  \n  \nsetup('authenticate as user', async ({ page }) => {  \n  // Perform authentication steps. Replace these actions with your own.  \n  await page.goto('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('user');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n  // Wait until the page receives the cookies.  \n  //  \n  // Sometimes login flow sets cookies in the process of several redirects.  \n  // Wait for the final URL to ensure that the cookies are actually set.  \n  await page.waitForURL('https://github.com/');  \n  // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n  await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n  // End of authentication steps.  \n  \n  await page.context().storageState({ path: userFile });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/auth", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: Don't use manual assertions\u200b | Don't use manual assertions that are not awaiting the expect. In the code below the await is inside the expect rather than before it. When using assertions such as `isVisible()` the test won't wait a single second, it will just check the locator is there and return immediately.", "input": "", "output": "// \ud83d\udc4e  \nexpect(await page.getByText('welcome').isVisible()).toBe(true);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/best-practices"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  // environment variables which are set in globalSetup are only available inside test().  \n  const { FOO, BAR } = process.env;  \n  \n  // FOO and BAR properties are populated.  \n  expect(FOO).toEqual('some data');  \n  \n  const complexData = JSON.parse(BAR);  \n  expect(BAR).toEqual({ some: 'data' });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Press keys one by one  \nawait page.locator('#area').pressSequentially('Hello World!');", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "component.spec.tsx", "output": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('callback', async ({ mount }) => {  \n  const component = await mount(<Component onClick={() => {}} />);  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "The difference between the [Locator](/docs/api/class-locator \"Locator\") and [ElementHandle](/docs/api/class-elementhandle \"ElementHandle\") is that the latter points to a particular element, while Locator captures the logic of how to retrieve that element. | In the example below, handle points to a particular DOM element on page. If that element changes text or is used by React to render an entirely different component, handle is still pointing to that very stale DOM element. This can lead to unexpected behaviors.", "output": "const handle = await page.$('text=Submit');  \n// ...  \nawait handle.hover();  \nawait handle.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/handles"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const context = await browser.newContext({  \n  recordHar: {  \n    path: 'github.har.zip',  \n  }  \n});", "output": "const context = await browser.newContext({  \n  recordHar: {  \n    path: 'github.har.zip',  \n  }  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: './my-awesome-reporter.ts',  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: './my-awesome-reporter.ts',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "const newEmail = page.getByRole('button', { name: 'New' });  \nconst dialog = page.getByText('Confirm security settings');  \nawait expect(newEmail.or(dialog).first()).toBeVisible();  \nif (await dialog.isVisible())  \n  await page.getByRole('button', { name: 'Dismiss' }).click();  \nawait newEmail.click();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: component.spec.tsx", "input": "", "output": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('callback', async ({ mount }) => {  \n  const component = await mount(<Component onClick={() => {}} />);  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport App from './App';  \n  \n// Let's test component in a dark scheme!  \ntest.use({ colorScheme: 'dark' });  \n  \ntest('should render', async ({ mount }) => {  \n  const component = await mount(<App></App>);  \n  \n  // As with any Playwright test, assert locator text.  \n  await expect(component).toContainText('React');  \n  // Or do a screenshot \ud83d\ude80  \n  await expect(component).toHaveScreenshot();  \n  // Or use any Playwright method  \n  await component.click();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "component.spec.tsx", "output": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(<Component/>);  \n  await component.update(  \n      <Component msg=\"greetings\" v-on:click={() => {}}>Child</Component>  \n  );  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('slot', async ({ mount }) => {  \n  const component = await mount(Component, { slots: { default: 'Slot' } });  \n});", "output": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('slot', async ({ mount }) => {  \n  const component = await mount(Component, { slots: { default: 'Slot' } });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('basic test', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  const name = await page.innerText('.navbar__title');  \n  expect(name).toBe('Playwright');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.navigate('https://playwright.dev');  \n  await assert(page).toHaveScreenshot();  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  await expect(page).toHaveScreenshot();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: component.spec.ts", "input": "", "output": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('props', async ({ mount }) => {  \n  const component = await mount(Component, { props: { msg: 'greetings' } });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from './fixtures';  \nimport { assert } from '@playwright/test';  \n  \ntest('basic', async ({ }) => {  \n  // ...  \n});", "output": "import { test } from './fixtures';  \nimport { expect } from '@playwright/test';  \n  \ntest('basic', async ({ }) => {  \n  // ...  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "Create `playwright/fixtures.ts` file that will [override `storageState` fixture](/docs/test-fixtures#overriding-fixtures) to authenticate once per worker. Use [testInfo.parallelIndex](/docs/api/class-testinfo#test-info-parallel-index) to differentiate between workers. | playwright/fixtures.ts", "output": "import { test as baseTest, expect } from '@playwright/test';  \nimport fs from 'fs';  \nimport path from 'path';  \n  \nexport * from '@playwright/test';  \nexport const test = baseTest.extend<{}, { workerStorageState: string }>({  \n  // Use the same storage state for all tests in this worker.  \n  storageState: ({ workerStorageState }, use) => use(workerStorageState),  \n  \n  // Authenticate once per worker with a worker-scoped fixture.  \n  workerStorageState: [async ({ browser }, use) => {  \n    // Use parallelIndex as a unique identifier for each worker.  \n    const id = test.info().parallelIndex;  \n    const fileName = path.resolve(test.info().project.outputDir, `.auth/${id}.json`);  \n  \n    if (fs.existsSync(fileName)) {  \n      // Reuse existing authentication state if any.  \n      await use(fileName);  \n      return;  \n    }  \n  \n    // Important: make sure we authenticate in a clean environment by unsetting storage state.  \n    const page = await browser.newPage({ storageState: undefined });  \n  \n    // Acquire a unique account, for example create a new one.  \n    // Alternatively, you can have a list of precreated accounts for testing.  \n    // Make sure that accounts are unique, so that multiple team members  \n    // can run tests at the same time without interference.  \n    const account = await acquireAccount(id);  \n  \n    // Perform authentication steps. Replace these actions with your own.  \n    await page.goto('https://github.com/login');  \n    await page.getByLabel('Username or email address').fill(account.username);  \n    await page.getByLabel('Password').fill(account.password);  \n    await page.getByRole('button', { name: 'Sign in' }).click();  \n    // Wait until the page receives the cookies.  \n    //  \n    // Sometimes login flow sets cookies in the process of several redirects.  \n    // Wait for the final URL to ensure that the cookies are actually set.  \n    await page.waitForURL('https://github.com/');  \n    // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n    await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n    // End of authentication steps.  \n  \n    await page.context().storageState({ path: fileName });  \n    await page.close();  \n    await use(fileName);  \n  }, { scope: 'worker' }],  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Configure projects for multiple browsers\u200b | By using **projects** you can run your tests in multiple browsers such as chromium, webkit and firefox as well as branded browsers such as Google Chrome and Microsoft Edge. Playwright can also run on emulated tablet and mobile devices. See the [registry of device parameters](https://github.com/microsoft/playwright/blob/main/packages/playwright-core/src/server/deviceDescriptorsSource.json) for a complete list of selected desktop, tablet and mobile devices.", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n    },  \n  \n    {  \n      name: 'firefox',  \n      use: { ...devices['Desktop Firefox'] },  \n    },  \n  \n    {  \n      name: 'webkit',  \n      use: { ...devices['Desktop Safari'] },  \n    },  \n  \n    /* Test against mobile viewports. */  \n    {  \n      name: 'Mobile Chrome',  \n      use: { ...devices['Pixel 5'] },  \n    },  \n    {  \n      name: 'Mobile Safari',  \n      use: { ...devices['iPhone 12'] },  \n    },  \n  \n    /* Test against branded browsers. */  \n    {  \n      name: 'Microsoft Edge',  \n      use: {  \n        ...devices['Desktop Edge'],  \n        channel: 'msedge'  \n      },  \n    },  \n    {  \n      name: 'Google Chrome',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        channel: 'chrome'  \n      },  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-projects"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as base, expect } from '@playwright/test';  \n  \nconst test = base.extend<{ slowFixture: string }>({  \n  slowFixture: [async ({}, use) => {  \n    // ... perform a slow operation ...  \n    await use('hello');  \n  }, { timeout: 60000 }]  \n});  \n  \ntest('example test', async ({ slowFixture }) => {  \n  // ...  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "// Initialize clock and let the page load naturally.  \nawait page.clock.install({ time: new Date('2024-02-02T08:00:00') });  \nawait page.goto('http://localhost:3333');  \n  \n// Pretend that the user closed the laptop lid and opened it again at 10am,  \n// Pause the time once reached that point.  \nawait page.clock.pauseAt(new Date('2024-02-02T10:00:00'));  \n  \n// Assert the page state.  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \n// Close the laptop lid again and open it at 10:30am.  \nawait page.clock.fastForward('30:00');  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:30:00 AM');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest('basic test', async ({ page }) => {  \n  await page.navigate('https://playwright.dev/');  \n  const name = await page.innerText('.navbar__title');  \n  assert(name).toBe('Playwright');  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('basic test', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  const name = await page.innerText('.navbar__title');  \n  expect(name).toBe('Playwright');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: [`expect(locator).toBeChecked({ checked })`](/docs/api/class-locatorassertions#locator-assertions-to-be-checked) | Each locator can now be optionally filtered by the text it contains:", "input": "", "output": "await page.locator('li', { hasText: 'my item' }).locator('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: Matching two locators simultaneously\u200b | Method [locator.and()](/docs/api/class-locator#locator-and) narrows down an existing locator by matching an additional locator. For example, you can combine [page.getByRole()](/docs/api/class-page#page-get-by-role) and [page.getByTitle()](/docs/api/class-page#page-get-by-title) to match by both role and title.", "input": "", "output": "const button = page.getByRole('button').and(page.getByTitle('Subscribe'));", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Other Options\u200b | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Maximum time each action such as `click()` can take. Defaults to 0 (no limit).  \n    actionTimeout: 0,  \n  \n    // Name of the browser that runs tests. For example `chromium`, `firefox`, `webkit`.  \n    browserName: 'chromium',  \n  \n    // Toggles bypassing Content-Security-Policy.  \n    bypassCSP: true,  \n  \n    // Channel to use, for example \"chrome\", \"chrome-beta\", \"msedge\", \"msedge-beta\".  \n    channel: 'chrome',  \n  \n    // Run browser in headless mode.  \n    headless: false,  \n  \n    // Change the default data-testid attribute.  \n    testIdAttribute: 'pw-test-id',  \n  },  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-use-options", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { mergeTests } from '@playwright/test';  \nimport { test as dbTest } from 'database-test-utils';  \nimport { test as a11yTest } from 'a11y-test-utils';  \n  \nexport const test = mergeTests(dbTest, a11yTest);", "output": "import { mergeTests } from '@playwright/test';  \nimport { test as dbTest } from 'database-test-utils';  \nimport { test as a11yTest } from 'a11y-test-utils';  \n  \nexport const test = mergeTests(dbTest, a11yTest);", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// \ud83d\udc4d  \nawait assert(page.getByText('welcome')).toBeVisible();  \n  \n// \ud83d\udc4e  \nassert(await page.getByText('welcome').isVisible()).toBe(true);", "output": "// \ud83d\udc4d  \nawait expect(page.getByText('welcome')).toBeVisible();  \n  \n// \ud83d\udc4e  \nexpect(await page.getByText('welcome').isVisible()).toBe(true);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/best-practices", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Basic navigation\u200b | Simplest form of a navigation is opening a URL:", "output": "// Navigate the page  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/navigations", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.getByText('Details').click();  \n\n\n\n<x-details role=button aria-expanded=true aria-controls=inner-details>  \n  <div>Title</div>  \n  #shadow-root  \n    <div id=inner-details>Details</div>  \n</x-details>", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test.describe.serial('group', () => {  \n  test('runs first', async ({ page }) => { /* ... */ });  \n  test('runs second', async ({ page }) => { /* ... */ });  \n});", "output": "test.describe.serial('group', () => {  \n  test('runs first', async ({ page }) => { /* ... */ });  \n  test('runs second', async ({ page }) => { /* ... */ });  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const { test } = require('@playwright/test');  \nconst { TodoPage } = require('./todo-page');  \n  \ntest.describe('todo tests', () => {  \n  let todoPage;  \n  \n  test.beforeEach(async ({ page }) => {  \n    todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo('item1');  \n    await todoPage.addToDo('item2');  \n  });  \n  \n  test.afterEach(async () => {  \n    await todoPage.removeAll();  \n  });  \n  \n  test('should add an item', async () => {  \n    await todoPage.addToDo('my item');  \n    // ...  \n  });  \n  \n  test('should remove an item', async () => {  \n    await todoPage.remove('item1');  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test.describe.parallel('group', () => {  \n  test('runs in parallel 1', async ({ page }) => {  \n  });  \n  test('runs in parallel 2', async ({ page }) => {  \n  });  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('children', async ({ mount }) => {  \n  const component = await mount(<Component>Child</Component>);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: You can check the issues count after locating it by the title text:", "input": "", "output": "await expect(page.getByTitle('Issues count')).toHaveText('25 issues');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Highlights\u200b | New role selectors that allow selecting elements by their [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) and [accessible name](https://w3c.github.io/accname/#dfn-accessible-name).", "output": "// Click a button with accessible name \"log in\"  \nawait page.locator('role=button[name=\"log in\"]').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('props', async ({ mount }) => {  \n  const component = await mount(Component, { props: { msg: 'greetings' } });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: tests/example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  geolocation: { longitude: 41.890221, latitude: 12.492348 },  \n  permissions: ['geolocation'],  \n});  \n  \ntest('my test with geolocation', async ({ page, context }) => {  \n  // overwrite the location for this test  \n  await context.setGeolocation({ longitude: 48.858455, latitude: 2.294474 });  \n});  \n\n\n\nawait context.setGeolocation({ longitude: 48.858455, latitude: 2.294474 });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Modern pages perform numerous activities after the `load` event was fired. They fetch data lazily, populate UI, load expensive resources, scripts and styles after the `load` event was fired. There is no way to tell that the page is `loaded`, it depends on the page, framework, etc. So when can you start interacting with it? | In Playwright you can interact with the page at any moment. It will automatically wait for the target elements to become [actionable](/docs/actionability).", "output": "// Navigate and click element  \n// Click will auto-wait for the element  \nawait page.goto('https://example.com');  \nawait page.getByText('Example Domain').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/navigations", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.route('**/api/fetch_data', route => route.fulfill({  \n  status: 200,  \n  body: testData,  \n}));  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Here is an example that defines a common timeout and two projects. The \"Smoke\" project runs a small subset of tests without retries, and \"Default\" project runs all other tests with retries. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  timeout: 60000, // Timeout is shared between all tests.  \n  projects: [  \n    {  \n      name: 'Smoke',  \n      testMatch: /.*smoke.spec.ts/,  \n      retries: 0,  \n    },  \n    {  \n      name: 'Default',  \n      testIgnore: /.*smoke.spec.ts/,  \n      retries: 2,  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-projects"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Use the count assertion to ensure that the list has 3 items.", "output": "await expect(page.getByRole('listitem')).toHaveCount(3);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Run your local dev server before starting the tests  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n    stdout: 'pipe',  \n    stderr: 'pipe',  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Run your local dev server before starting the tests  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n    stdout: 'pipe',  \n    stderr: 'pipe',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "async function login(page) {  \n  await test.step('login', async () => {  \n    // ...  \n  }, { box: true });  // Note the \"box\" option here.  \n}  \n\n\n\nError: Timed out 5000ms waiting for expect(locator).toBeVisible()  \n  ... error details omitted ...  \n  \n  14 |   await page.goto('https://github.com/login');  \n> 15 |   await login(page);  \n     |         ^  \n  16 | });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "playwright.config.ts", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        // It is important to define the `viewport` property after destructuring `devices`,  \n        // since devices also define the `viewport` for that device.  \n        viewport: { width: 1280, height: 720 },  \n      },  \n    },  \n  ]  \n});  \n\n\n\n// Create context with given viewport  \nconst context = await browser.newContext({  \n  viewport: { width: 1280, height: 1024 }  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const status = await page.evaluate(async () => {  \n  const response = await fetch(location.href);  \n  return response.status;  \n});", "output": "const status = await page.evaluate(async () => {  \n  const response = await fetch(location.href);  \n  return response.status;  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/evaluating", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Whether the meta viewport tag is taken into account and touch events are enabled. | playwright.config.ts", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        // It is important to define the `isMobile` property after destructuring `devices`,  \n        // since devices also define the `isMobile` for that device.  \n        isMobile: false,  \n      },  \n    },  \n  ]  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    launchOptions: {  \n      slowMo: 50,  \n    },  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    launchOptions: {  \n      slowMo: 50,  \n    },  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Playwright Test includes the ability to produce and visually compare screenshots using `await expect(page).toHaveScreenshot()`. On first execution, Playwright test will generate reference screenshots. Subsequent runs will compare against the reference. | example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  await expect(page).toHaveScreenshot();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const handle = await page.$('text=Submit');  \n// ...  \nawait handle.hover();  \nawait handle.click();", "output": "const handle = await page.$('text=Submit');  \n// ...  \nawait handle.hover();  \nawait handle.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/handles", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "page.on('dialog', async dialog => {  \n  assert(dialog.type() === 'beforeunload');  \n  await dialog.dismiss();  \n});  \nawait page.close({ runBeforeUnload: true });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/dialogs", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "[test.beforeAll()](/docs/api/class-test#test-before-all) and [test.afterAll()](/docs/api/class-test#test-after-all) hooks run before/after all tests declared in the same file and same [test.describe()](/docs/api/class-test#test-describe) block (if any), once per worker process. If you want to declare hooks that run before/after all tests in every file, you can declare them as auto fixtures with `scope: 'worker'` as follows: | fixtures.ts", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend<{}, { forEachWorker: void }>({  \n  forEachWorker: [async ({}, use) => {  \n    // This code runs before all the tests in the worker process.  \n    console.log(`Starting test worker ${test.info().workerIndex}`);  \n    await use();  \n    // This code runs after all the tests in the worker process.  \n    console.log(`Stopping test worker ${test.info().workerIndex}`);  \n  }, { scope: 'worker', auto: true }],  // automatically starts for every worker.  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "Playwright Test runs tests in worker processes. These processes are OS processes, running independently, orchestrated by the test runner. All workers have identical environments and each starts its own browser. | Consider the following snippet:", "output": "import { test } from '@playwright/test';  \n  \ntest.describe('suite', () => {  \n  test.beforeAll(async () => { /* ... */ });  \n  test('first good', async ({ page }) => { /* ... */ });  \n  test('second flaky', async ({ page }) => { /* ... */ });  \n  test('third good', async ({ page }) => { /* ... */ });  \n  test.afterAll(async () => { /* ... */ });  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-retries"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.getByTestId('directions').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "Playwright Test runs tests in worker processes. These processes are OS processes, running independently, orchestrated by the test runner. All workers have identical environments and each starts its own browser. | Consider the following snippet:", "output": "import { test } from '@playwright/test';  \n  \ntest.describe('suite', () => {  \n  test.beforeAll(async () => { /* ... */ });  \n  test('first good', async ({ page }) => { /* ... */ });  \n  test('second flaky', async ({ page }) => { /* ... */ });  \n  test('third good', async ({ page }) => { /* ... */ });  \n  test.afterAll(async () => { /* ... */ });  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-retries", "type": "fixture"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: 'orange' })  \n    .click();", "output": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: 'orange' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: You can configure Playwright globally, per project, or per test. For example, you can set the locale to be used globally by adding `locale` to the `use` option of the Playwright config, and then override it for a specific project using the `project` option in the config. You can also override it for a specific test by adding `test.use({})` in the test file and passing in the options. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    locale: 'en-GB'  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Context geolocation  \n    geolocation: { longitude: 12.492507, latitude: 41.889938 },  \n    permissions: ['geolocation'],  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Context geolocation  \n    geolocation: { longitude: 12.492507, latitude: 41.889938 },  \n    permissions: ['geolocation'],  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/emulation", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Before  \n  \nimport { type PlaywrightTestConfig, devices } from '@playwright/experimental-ct-react';  \nconst config: PlaywrightTestConfig = {  \n  // ... config goes here ...  \n};  \nexport default config;", "output": "// Before  \n  \nimport { type PlaywrightTestConfig, devices } from '@playwright/experimental-ct-react';  \nconst config: PlaywrightTestConfig = {  \n  // ... config goes here ...  \n};  \nexport default config;", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "In most cases, it'll be written in one line:", "output": "await page.getByRole('link', { name: 'Get started' }).click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/writing-tests", "type": "navigation"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "ticking through time manually.", "output": "// Initialize clock and let the page load naturally.  \nawait page.clock.install({ time: new Date('2024-02-02T08:00:00') });  \nawait page.goto('http://localhost:3333');  \n  \n// Pretend that the user closed the laptop lid and opened it again at 10am,  \n// Pause the time once reached that point.  \nawait page.clock.pauseAt(new Date('2024-02-02T10:00:00'));  \n  \n// Assert the page state.  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \n// Close the laptop lid again and open it at 10:30am.  \nawait page.clock.fastForward('30:00');  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:30:00 AM');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: my-test.js", "input": "", "output": "const base = require('@playwright/test');  \n  \nexports.test = base.test.extend({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  person: ['John', { option: true }],  \n  \n  // Override default \"page\" fixture.  \n  page: async ({ page, person }, use) => {  \n    await page.goto('/chat');  \n    // We use \"person\" parameter as a \"name\" for the chat room.  \n    await page.getByLabel('User Name').fill(person);  \n    await page.getByText('Enter chat room').click();  \n    // Each test will get a \"page\" that already has the person name.  \n    await use(page);  \n  },  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const locator = page.frameLocator('#my-iframe').locator('text=Submit');  \nawait locator.click();", "output": "const locator = page.frameLocator('#my-iframe').locator('text=Submit');  \nawait locator.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect(page.getByText('Name'), 'should be logged in').toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Test Runner\u200b | [test.step()](/docs/api/class-test#test-step) now returns the value of the step function:", "input": "", "output": "test('should work', async ({ page }) => {  \n  const pageTitle = await test.step('get title', async () => {  \n    await page.goto('https://playwright.dev');  \n    return await page.title();  \n  });  \n  console.log(pageTitle);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "The filtering locator **must be relative** to the original locator and is queried starting with the original locator match, not the document root. Therefore, the following will not work, because the filtering locator starts matching from the `<ul>` list element that is outside of the `<li>` list item matched by the original locator:", "output": "// \u2716 WRONG  \nawait expect(page  \n    .getByRole('listitem')  \n    .filter({ has: page.getByRole('list').getByText('Product 2') }))  \n    .toHaveCount(1);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Text input  \nawait page.getByRole('textbox').fill('Peter');  \n  \n// Date input  \nawait page.getByLabel('Birth date').fill('2020-02-02');  \n  \n// Time input  \nawait page.getByLabel('Appointment time').fill('13:15');  \n  \n// Local datetime input  \nawait page.getByLabel('Local time').fill('2020-03-02T05:15');", "output": "// Text input  \nawait page.getByRole('textbox').fill('Peter');  \n  \n// Date input  \nawait page.getByLabel('Birth date').fill('2020-02-02');  \n  \n// Time input  \nawait page.getByLabel('Appointment time').fill('13:15');  \n  \n// Local datetime input  \nawait page.getByLabel('Local time').fill('2020-03-02T05:15');", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/input", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "<div id=\"remaining-time\" data-testid=\"remaining-time\"></div>  \n<script>  \n  const endTime = Date.now() + 5 * 60_000;  \n  const renderTime = () => {  \n    const diffInSeconds = Math.round((endTime - Date.now()) / 1000);  \n    if (diffInSeconds <= 0) {  \n      document.getElementById('remaining-time').textContent =  \n        'You have been logged out due to inactivity.';  \n    } else {  \n      document.getElementById('remaining-time').textContent =  \n        `You will be logged out in ${diffInSeconds} seconds.`;  \n    }  \n    setTimeout(renderTime, 1000);  \n  };  \n  renderTime();  \n</script>  \n<button type=\"button\">Interaction</button>  \n\n\n\n// Initial time does not matter for the test, so we can pick current time.  \nawait page.clock.install();  \nawait page.goto('http://localhost:3333');  \n// Interact with the page  \nawait page.getByRole('button').click();  \n  \n// Fast forward time 5 minutes as if the user did not do anything.  \n// Fast forward is like closing the laptop lid and opening it after 5 minutes.  \n// All the timers due will fire once immediately, as in the real browser.  \nawait page.clock.fastForward('05:00');  \n  \n// Check that the user was logged out automatically.  \nawait expect(page.getByText('You have been logged out due to inactivity.')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/clock", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.locator('li', { hasText: 'my item' }).locator('button').click();", "output": "await page.locator('li', { hasText: 'my item' }).locator('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Configuration for the expect assertion library. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  expect: {  \n    // Maximum time expect() should wait for the condition to be met.  \n    timeout: 5000,  \n  \n    toHaveScreenshot: {  \n      // An acceptable amount of pixels that could be different, unset by default.  \n      maxDiffPixels: 10,  \n    },  \n  \n    toMatchSnapshot: {  \n      // An acceptable ratio of pixels that are different to the  \n      // total amount of pixels, between 0 and 1.  \n      maxDiffPixelRatio: 0.1,  \n    },  \n  },  \n  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-configuration"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect(page.getByTestId('status')).toHaveText('Submitted');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Locate an item by its text content and click it.", "output": "await page.getByText('orange').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "navigation"}}
{"instruction": "Create a Playwright test that demonstrates the form_interaction pattern.", "input": "Select options\u200b | Selects one or multiple options in the `<select>` element with [locator.selectOption()](/docs/api/class-locator#locator-select-option). You can specify option `value`, or `label` to select. Multiple options can be selected.", "output": "// Single selection matching the value or label  \nawait page.getByLabel('Choose a color').selectOption('blue');  \n  \n// Single selection matching the label  \nawait page.getByLabel('Choose a color').selectOption({ label: 'Blue' });  \n  \n// Multiple selected items  \nawait page.getByLabel('Choose multiple colors').selectOption(['red', 'green', 'blue']);", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Generate a Playwright test for the following scenario: Most of the time you should put `beforeEach`, `beforeAll`, `afterEach` and `afterAll` hooks outside of `forEach`, so that hooks are executed just once: | example.spec.ts", "input": "", "output": "test.beforeEach(async ({ page }) => {  \n  // ...  \n});  \n  \ntest.afterEach(async ({ page }) => {  \n  // ...  \n});  \n  \n[  \n  { name: 'Alice', expected: 'Hello, Alice!' },  \n  { name: 'Bob', expected: 'Hello, Bob!' },  \n  { name: 'Charlie', expected: 'Hello, Charlie!' },  \n].forEach(({ name, expected }) => {  \n  test(`testing with ${name}`, async ({ page }) => {  \n    await page.goto(`https://example.com/greet?name=${name}`);  \n    await expect(page.getByRole('heading')).toHaveText(expected);  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Base URL to use in actions like `await page.goto('/')`.  \n    baseURL: 'http://127.0.0.1:3000',  \n  \n    // Populates context with given storage state.  \n    storageState: 'state.json',  \n  },  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-use-options", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Set expect timeout in the config\u200b | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  expect: {  \n    timeout: 10_000,  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts"}}
{"instruction": "Generate a Playwright test for the following scenario: my-test.ts", "input": "", "output": "import { test as base } from '@playwright/test';  \nimport { TodoPage } from './todo-page';  \nimport { SettingsPage } from './settings-page';  \n  \n// Declare the types of your fixtures.  \ntype MyFixtures = {  \n  todoPage: TodoPage;  \n  settingsPage: SettingsPage;  \n};  \n  \n// Extend base test by providing \"todoPage\" and \"settingsPage\".  \n// This new \"test\" can be used in multiple test files, and each of them will get the fixtures.  \nexport const test = base.extend<MyFixtures>({  \n  todoPage: async ({ page }, use) => {  \n    // Set up the fixture.  \n    const todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo('item1');  \n    await todoPage.addToDo('item2');  \n  \n    // Use the fixture value in the test.  \n    await use(todoPage);  \n  \n    // Clean up the fixture.  \n    await todoPage.removeAll();  \n  },  \n  \n  settingsPage: async ({ page }, use) => {  \n    await use(new SettingsPage(page));  \n  },  \n});  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test('log battery calls', async ({ page }) => {  \n  const log = [];  \n  // Expose function for pushing messages to the Node.js script.  \n  await page.exposeFunction('logCall', msg => log.push(msg));  \n  await page.addInitScript(() => {  \n    const mockBattery = {  \n      level: 0.75,  \n      charging: true,  \n      chargingTime: 1800,  \n      dischargingTime: Infinity,  \n      // Log addEventListener calls.  \n      addEventListener: (name, cb) => logCall(`addEventListener:${name}`)  \n    };  \n    // Override the method to always return mock battery info.  \n    window.navigator.getBattery = async () => {  \n      logCall('getBattery');  \n      return mockBattery;  \n    };  \n  });  \n  \n  await page.goto('/');  \n  await expect(page.locator('.battery-percentage')).toHaveText('75%');  \n  \n  // Compare actual calls with golden.  \n  expect(log).toEqual([  \n    'getBattery',  \n    'addEventListener:chargingchange',  \n    'addEventListener:levelchange'  \n  ]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock-browser-apis", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['html', { attachmentsBaseURL: 'https://external-storage.com/' }]],  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['html', { attachmentsBaseURL: 'https://external-storage.com/' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { expect, test, devices } from '@playwright/test';  \n  \ntest.use(devices['iPhone 11']);  \n  \ntest('should be titled', async ({ page, context }) => {  \n  await context.route('**.jpg', route => route.abort());  \n  await page.goto('https://example.com/');  \n  \n  await expect(page).toHaveTitle('Example');  \n});  \n\n\n\nconst { expect, test, devices } = require('@playwright/test');  \n  \ntest.use(devices['iPhone 11']);  \n  \ntest('should be titled', async ({ page, context }) => {  \n  await context.route('**.jpg', route => route.abort());  \n  await page.goto('https://example.com/');  \n  \n  await expect(page).toHaveTitle('Example');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/library", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('has title', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  \n  // Expect a title \"to contain\" a substring.  \n  await expect(page).toHaveTitle(/Playwright/);  \n});  \n  \ntest('get started link', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  \n  // Click the get started link.  \n  await page.getByRole('link', { name: 'Get started' }).click();  \n  \n  // Expects page to have a heading with the name of Installation.  \n  await expect(page.getByRole('heading', { name: 'Installation' })).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/writing-tests", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const buffer = await page.screenshot();  \nconsole.log(buffer.toString('base64'));", "output": "const buffer = await page.screenshot();  \nconsole.log(buffer.toString('base64'));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/screenshots", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "[`expect(locator).toBeChecked({ checked })`](/docs/api/class-locatorassertions#locator-assertions-to-be-checked) | Each locator can now be optionally filtered by the text it contains:", "output": "await page.locator('li', { hasText: 'my item' }).locator('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Other Updates\u200b | Locator now supports a `has` option that makes sure it contains another locator inside:", "output": "await page.locator('article', {  \n  has: page.locator('.highlight'),  \n}).click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Tests start already authenticated because we specify `storageState` that was populated by global setup.", "output": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  await page.goto('/');  \n  // You are signed in!  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await page.goto('https://playwright.dev');  \nawait expect(page.locator('body')).toMatchAriaSnapshot(`  \n  - banner:  \n    - heading /Playwright enables reliable/ [level=1]  \n    - link \"Get started\"  \n    - link \"Star microsoft/playwright on GitHub\"  \n  - main:  \n    - img \"Browsers (Chromium, Firefox, WebKit)\"  \n    - heading \"Any browser \u2022 Any platform \u2022 One API\"  \n`);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  storageState: async ({}, use) => {  \n    const cookie = await getAuthCookie();  \n    await use({ cookies: [cookie] });  \n  },  \n});", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  storageState: async ({}, use) => {  \n    const cookie = await getAuthCookie();  \n    await use({ cookies: [cookie] });  \n  },  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.routeWebSocket('wss://example.com/ws', ws => {  \n  const server = ws.connectToServer();  \n  ws.onMessage(message => {  \n    if (message === 'request')  \n      server.send('request2');  \n    else  \n      server.send(message);  \n  });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/mock", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Use a regular expression:", "output": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: /Product 2/ })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('loads page without images', async ({ page }) => {  \n  // Block png and jpeg images.  \n  await page.route(/(png|jpeg)$/, route => route.abort());  \n  \n  await page.goto('https://playwright.dev');  \n  // ... test goes here  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/network", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // 'github' for GitHub Actions CI to generate annotations, plus a concise 'dot'  \n  // default 'list' when running locally  \n  reporter: process.env.CI ? 'github' : 'list',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert(page.getByText('Welcome, John', { exact: true })).toBeVisible();", "output": "await expect(page.getByText('Welcome, John', { exact: true })).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Wait for a locator to resolve to a single element with a given state. Defaults to the `state: 'visible'`. | Comes especially handy when working with lists:", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('context fetch', async ({ page }) => {  \n  const completeness = page.locator('text=Success');  \n  await completeness.waitFor();  \n  expect(await page.screenshot()).toMatchSnapshot('screen.png');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert(locator).toMatchAriaSnapshot('');", "output": "await expect(locator).toMatchAriaSnapshot('');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/aria-snapshots", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "JavaScript", "output": "import { expect, test, devices } from '@playwright/test';  \n  \ntest.use(devices['iPhone 11']);  \n  \ntest('should be titled', async ({ page, context }) => {  \n  await context.route('**.jpg', route => route.abort());  \n  await page.goto('https://example.com/');  \n  \n  await expect(page).toHaveTitle('Example');  \n});  \n\n\n\nconst { expect, test, devices } = require('@playwright/test');  \n  \ntest.use(devices['iPhone 11']);  \n  \ntest('should be titled', async ({ page, context }) => {  \n  await context.route('**.jpg', route => route.abort());  \n  await page.goto('https://example.com/');  \n  \n  await expect(page).toHaveTitle('Example');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/library"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Next, add init script to the page.", "output": "import { test, expect } from '@playwright/test';  \nimport path from 'path';  \n  \ntest.beforeEach(async ({ page }) => {  \n  // Add script for every test in the beforeEach hook.  \n  // Make sure to correctly resolve the script path.  \n  await page.addInitScript({ path: path.resolve(__dirname, '../mocks/preload.js') });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/evaluating"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "For example, you can run a group of tests just in Chromium by passing a callback. | example.spec.ts", "output": "test.describe('chromium only', () => {  \n  test.skip(({ browserName }) => browserName !== 'chromium', 'Chromium only!');  \n  \n  test.beforeAll(async () => {  \n    // This hook is only run in Chromium.  \n  });  \n  \n  test('test 1', async ({ page }) => {  \n    // This test is only run in Chromium.  \n  });  \n  \n  test('test 2', async ({ page }) => {  \n    // This test is only run in Chromium.  \n  });  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-annotations"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect(page).toHaveTitle(/Playwright/);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/writing-tests", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "\ud83e\udde9 Experimental [**React**](/docs/other-locators#react-locator) and [**Vue**](/docs/other-locators#vue-locator) selector engines\u200b | React and Vue selectors allow selecting elements by its component name and/or property values. The syntax is very similar to [attribute selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors) and supports all attribute selector operators.", "output": "await page.locator('_react=SubmitButton[enabled=true]').click();  \nawait page.locator('_vue=submit-button[enabled=true]').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: By default, [fixture](/docs/test-fixtures) shares timeout with the test. However, for slow fixtures, especially [worker-scoped](/docs/test-fixtures#worker-scoped-fixtures) ones, it is convenient to have a separate timeout. This way you can keep the overall test timeout small, and give the slow fixture more time. | example.spec.ts", "input": "", "output": "import { test as base, expect } from '@playwright/test';  \n  \nconst test = base.extend<{ slowFixture: string }>({  \n  slowFixture: [async ({}, use) => {  \n    // ... perform a slow operation ...  \n    await use('hello');  \n  }, { timeout: 60_000 }]  \n});  \n  \ntest('example test', async ({ slowFixture }) => {  \n  // ...  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-timeouts"}}
{"instruction": "Generate a Playwright test for the following scenario: When expect fails, the error would look like this:", "input": "", "output": "Error: should be logged in  \n  \n    Call log:  \n      - expect.toBeVisible with timeout 5000ms  \n      - waiting for \"getByText('Name')\"  \n  \n  \n      2 |  \n      3 | test('example test', async({ page }) => {  \n    > 4 |   await expect(page.getByText('Name'), 'should be logged in').toBeVisible();  \n        |                                                                  ^  \n      5 | });  \n      6 |", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  expect: {  \n    toHaveScreenshot: { maxDiffPixels: 100 },  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('children', async ({ mount }) => {  \n  const component = await mount(<Component>Child</Component>);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Start waiting for popup before clicking. Note no await.  \nconst popupPromise = page.waitForEvent('popup');  \nawait page.getByText('open the popup').click();  \nconst popup = await popupPromise;  \nawait popup.goto('https://wikipedia.org');", "output": "// Start waiting for popup before clicking. Note no await.  \nconst popupPromise = page.waitForEvent('popup');  \nawait page.getByText('open the popup').click();  \nconst popup = await popupPromise;  \nawait popup.goto('https://wikipedia.org');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/events", "type": "modification"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "Box fixtures\u200b | Usually, custom fixtures are reported as separate steps in in the UI mode, Trace Viewer and various test reports. They also appear in error messages from the test runner. For frequently-used fixtures, this can mean lots of noise. You can stop the fixtures steps from being shown in the UI by \"boxing\" it.", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  helperFixture: [async ({}, use, testInfo) => {  \n    // ...  \n  }, { box: true }],  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "fixture"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as base } from '@playwright/test';  \nimport { TodoPage } from './todo-page';  \n  \n// Declare your options to type-check your configuration.  \nexport type MyOptions = {  \n  defaultItem: string;  \n};  \ntype MyFixtures = {  \n  todoPage: TodoPage;  \n};  \n  \n// Specify both option and fixture types.  \nexport const test = base.extend<MyOptions & MyFixtures>({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  defaultItem: ['Something nice', { option: true }],  \n  \n  // Our \"todoPage\" fixture depends on the option.  \n  todoPage: async ({ page, defaultItem }, use) => {  \n    const todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo(defaultItem);  \n    await use(todoPage);  \n    await todoPage.removeAll();  \n  },  \n});  \nexport { assert } from '@playwright/test';", "output": "import { test as base } from '@playwright/test';  \nimport { TodoPage } from './todo-page';  \n  \n// Declare your options to type-check your configuration.  \nexport type MyOptions = {  \n  defaultItem: string;  \n};  \ntype MyFixtures = {  \n  todoPage: TodoPage;  \n};  \n  \n// Specify both option and fixture types.  \nexport const test = base.extend<MyOptions & MyFixtures>({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  defaultItem: ['Something nice', { option: true }],  \n  \n  // Our \"todoPage\" fixture depends on the option.  \n  todoPage: async ({ page, defaultItem }, use) => {  \n    const todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo(defaultItem);  \n    await use(todoPage);  \n    await todoPage.removeAll();  \n  },  \n});  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  await test.step('Log in', async () => {  \n    // ...  \n  });  \n  await test.step('news feed', async () => {  \n    // ...  \n  });  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  await test.step('Log in', async () => {  \n    // ...  \n  });  \n  await test.step('news feed', async () => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.locator('_react=BookItem').click();", "output": "await page.locator('_react=BookItem').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: component.spec.ts", "input": "", "output": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('event', async ({ mount }) => {  \n  const component = await mount(Component, { on: { click() {} } });  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "You can also [filter locators](/docs/locators#filtering-locators) by text or by another locator.", "output": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: 'Product 2' })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/best-practices"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.navigate('https://playwright.dev');  \nawait assert(page).toHaveScreenshot({  \n  mask: [page.locator('img')],  \n  maskColor: '#00FF00', // green  \n});", "output": "await page.goto('https://playwright.dev');  \nawait expect(page).toHaveScreenshot({  \n  mask: [page.locator('img')],  \n  maskColor: '#00FF00', // green  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('unmount', async ({ mount }) => {  \n  const component = await mount(Component);  \n  await component.unmount();  \n});", "output": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('unmount', async ({ mount }) => {  \n  const component = await mount(Component);  \n  await component.unmount();  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "Alternatively, in a worker fixture: | playwright/fixtures.ts", "output": "import { test as baseTest, request } from '@playwright/test';  \nimport fs from 'fs';  \nimport path from 'path';  \n  \nexport * from '@playwright/test';  \nexport const test = baseTest.extend<{}, { workerStorageState: string }>({  \n  // Use the same storage state for all tests in this worker.  \n  storageState: ({ workerStorageState }, use) => use(workerStorageState),  \n  \n  // Authenticate once per worker with a worker-scoped fixture.  \n  workerStorageState: [async ({}, use) => {  \n    // Use parallelIndex as a unique identifier for each worker.  \n    const id = test.info().parallelIndex;  \n    const fileName = path.resolve(test.info().project.outputDir, `.auth/${id}.json`);  \n  \n    if (fs.existsSync(fileName)) {  \n      // Reuse existing authentication state if any.  \n      await use(fileName);  \n      return;  \n    }  \n  \n    // Important: make sure we authenticate in a clean environment by unsetting storage state.  \n    const context = await request.newContext({ storageState: undefined });  \n  \n    // Acquire a unique account, for example create a new one.  \n    // Alternatively, you can have a list of precreated accounts for testing.  \n    // Make sure that accounts are unique, so that multiple team members  \n    // can run tests at the same time without interference.  \n    const account = await acquireAccount(id);  \n  \n    // Send authentication request. Replace with your own.  \n    await context.post('https://github.com/login', {  \n      form: {  \n        'user': 'user',  \n        'password': 'password'  \n      }  \n    });  \n  \n    await context.storageState({ path: fileName });  \n    await context.dispose();  \n    await use(fileName);  \n  }, { scope: 'worker' }],  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Generate a Playwright test for the following scenario: For example, this could be used to setup App router in Vue.js: | src/component.spec.ts", "input": "", "output": "import { test } from '@playwright/experimental-ct-vue';  \nimport { Component } from './mycomponent';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(Component, {  \n    hooksConfig: {  \n      /* anything to configure your app */  \n    }  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: [expect(locator).toHaveAccessibleDescription()](/docs/api/class-locatorassertions#locator-assertions-to-have-accessible-description) checks if the element has the specified accessible description:", "input": "", "output": "const locator = page.getByRole('button');  \nawait expect(locator).toHaveAccessibleDescription('Upload a photo');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Downloaded files are deleted when the browser context that produced them is closed. | Here is the simplest way to handle the file download:", "output": "// Start waiting for download before clicking. Note no await.  \nconst downloadPromise = page.waitForEvent('download');  \nawait page.getByText('Download file').click();  \nconst download = await downloadPromise;  \n  \n// Wait for the download process to complete and save the downloaded file somewhere.  \nawait download.saveAs('/path/to/save/at/' + download.suggestedFilename());", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/downloads"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "expect.toPass\u200b | You can retry blocks of code until they are passing successfully.", "output": "await expect(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  expect(response.status()).toBe(200);  \n}).toPass();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  expect(response.status()).toBe(200);  \n}).toPass();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('specific viewport block', () => {  \n  test.use({ viewport: { width: 1600, height: 1200 } });  \n  \n  test('my test', async ({ page }) => {  \n    // ...  \n  });  \n});  \n\n\n\n// Create context with given viewport  \nconst context = await browser.newContext({  \n  viewport: { width: 1600, height: 1200 }  \n});  \nconst page = await context.newPage();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "component.spec.ts", "output": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(Component);  \n  await component.update({  \n    props: { msg: 'greetings' },  \n    on: { click() {} },  \n    slots: { default: 'Child' }  \n  });  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "electronApp.on('console', async msg => {  \n  const values = [];  \n  for (const arg of msg.args())  \n    values.push(await arg.jsonValue());  \n  console.log(...values);  \n});  \nawait electronApp.evaluate(() => console.log('hello', 5, { foo: 'bar' }));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { chromium, type FullConfig } from '@playwright/test';  \n  \nasync function globalSetup(config: FullConfig) {  \n  const { baseURL, storageState } = config.projects[0].use;  \n  const browser = await chromium.launch();  \n  const page = await browser.newPage();  \n  await page.navigate(baseURL!);  \n  await page.getByLabel('User Name').fill('user');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByText('Sign in').click();  \n  await page.context().storageState({ path: storageState as string });  \n  await browser.close();  \n}  \n  \nexport default globalSetup;", "output": "import { chromium, type FullConfig } from '@playwright/test';  \n  \nasync function globalSetup(config: FullConfig) {  \n  const { baseURL, storageState } = config.projects[0].use;  \n  const browser = await chromium.launch();  \n  const page = await browser.newPage();  \n  await page.goto(baseURL!);  \n  await page.getByLabel('User Name').fill('user');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByText('Sign in').click();  \n  await page.context().storageState({ path: storageState as string });  \n  await browser.close();  \n}  \n  \nexport default globalSetup;", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Release left mouse button.", "input": "", "output": "await page.locator('#item-to-be-dragged').dragTo(page.locator('#item-to-drop-at'));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Generate a Playwright test for the following scenario: component.spec.tsx", "input": "", "output": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('props', async ({ mount }) => {  \n  const component = await mount(<Component msg=\"greetings\" />);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "You can use multiple reporters at the same time. For example you can use `'list'` for nice terminal output and `'json'` to get a comprehensive json file with the test results. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [  \n    ['list'],  \n    ['json', {  outputFile: 'test-results.json' }]  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Generate a Playwright test for the following scenario: You can locate the element by the text it contains:", "input": "", "output": "await expect(page.getByText('Welcome, John')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  expect(await page.textContent('.hero__title')).toMatchSnapshot('hero.txt');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: Click to expand the code for the `TodoPage` | todo-page.ts", "input": "", "output": "import type { Page, Locator } from '@playwright/test';  \n  \nexport class TodoPage {  \n  private readonly inputBox: Locator;  \n  private readonly todoItems: Locator;  \n  \n  constructor(public readonly page: Page) {  \n    this.inputBox = this.page.locator('input.new-todo');  \n    this.todoItems = this.page.getByTestId('todo-item');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://demo.playwright.dev/todomvc/');  \n  }  \n  \n  async addToDo(text: string) {  \n    await this.inputBox.fill(text);  \n    await this.inputBox.press('Enter');  \n  }  \n  \n  async remove(text: string) {  \n    const todo = this.todoItems.filter({ hasText: text });  \n    await todo.hover();  \n    await todo.getByLabel('Delete').click();  \n  }  \n  \n  async removeAll() {  \n    while ((await this.todoItems.count()) > 0) {  \n      await this.todoItems.first().hover();  \n      await this.todoItems.getByLabel('Delete').first().click();  \n    }  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test for the following scenario: Set the test id to use a custom data attribute for your tests. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    testIdAttribute: 'data-pw'  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Custom expect message\u200b | You can specify a custom expect message as a second argument to the `expect` function, for example:", "output": "await expect(page.getByText('Name'), 'should be logged in').toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  retries: process.env.CI ? 2 : 0, // set to 2 when running on CI  \n  // ...  \n  use: {  \n    trace: 'on-first-retry', // record traces on first retry of each test  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  retries: process.env.CI ? 2 : 0, // set to 2 when running on CI  \n  // ...  \n  use: {  \n    trace: 'on-first-retry', // record traces on first retry of each test  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/trace-viewer-intro", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const locator = page.locator('button');  \nawait locator.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Added before v1.9 playwright.devices | Returns a dictionary of devices to be used with [browser.newContext()](/docs/api/class-browser#browser-new-context) or [browser.newPage()](/docs/api/class-browser#browser-new-page).", "output": "const { webkit, devices } = require('playwright');  \nconst iPhone = devices['iPhone 6'];  \n  \n(async () => {  \n  const browser = await webkit.launch();  \n  const context = await browser.newContext({  \n    ...iPhone  \n  });  \n  const page = await context.newPage();  \n  await page.goto('http://example.com');  \n  // other actions...  \n  await browser.close();  \n})();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/api/class-playwright", "type": "navigation"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "// 5 in-stock items  \nawait expect(page.getByRole('listitem').filter({ hasNotText: 'Out of stock' })).toHaveCount(5);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "completion"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect(page.locator('text=Name'), 'should be logged in').toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Selector ambiguity is a common problem in automation testing. **\"strict\" mode** ensures that your selector points to a single element and throws otherwise. | Pass `strict: true` into your action calls to opt in.", "output": "// This will throw if you have more than one button!  \nawait page.click('button', { strict: true });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "navigation"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Here is an example of reusing your existing MSW handlers in the test.", "output": "import { handlers } from '@src/mocks/handlers';  \n  \ntest.beforeEach(async ({ router }) => {  \n  // install common handlers before each test  \n  await router.use(...handlers);  \n});  \n  \ntest('example test', async ({ mount }) => {  \n  // test as usual, your handlers are active  \n  // ...  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  geolocation: { longitude: 41.890221, latitude: 12.492348 },  \n  permissions: ['geolocation'],  \n});  \n  \ntest('my test with geolocation', async ({ page }) => {  \n  // ...  \n});  \n\n\n\nconst context = await browser.newContext({  \n  geolocation: { longitude: 41.890221, latitude: 12.492348 },  \n  permissions: ['geolocation']  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test.beforeEach(async ({ page }) => {  \n  // ...  \n});  \n  \ntest.afterEach(async ({ page }) => {  \n  // ...  \n});  \n  \n[  \n  { name: 'Alice', asserted: 'Hello, Alice!' },  \n  { name: 'Bob', asserted: 'Hello, Bob!' },  \n  { name: 'Charlie', asserted: 'Hello, Charlie!' },  \n].forEach(({ name, asserted }) => {  \n  test(`testing with ${name}`, async ({ page }) => {  \n    await page.navigate(`https://example.com/greet?name=${name}`);  \n    await assert(page.getByRole('heading')).toHaveText(asserted);  \n  });  \n});", "output": "test.beforeEach(async ({ page }) => {  \n  // ...  \n});  \n  \ntest.afterEach(async ({ page }) => {  \n  // ...  \n});  \n  \n[  \n  { name: 'Alice', expected: 'Hello, Alice!' },  \n  { name: 'Bob', expected: 'Hello, Bob!' },  \n  { name: 'Charlie', expected: 'Hello, Charlie!' },  \n].forEach(({ name, expected }) => {  \n  test(`testing with ${name}`, async ({ page }) => {  \n    await page.goto(`https://example.com/greet?name=${name}`);  \n    await expect(page.getByRole('heading')).toHaveText(expected);  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parameterize", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Make a few checks that will not stop the test when failed...  \nawait expect.soft(page.getByTestId('status')).toHaveText('Success');  \nawait expect.soft(page.getByTestId('eta')).toHaveText('1 day');  \n  \n// Avoid running further if there were soft assertion failures.  \nexpect(test.info().errors).toHaveLength(0);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Dragging manually\u200b | If you want precise control over the drag operation, use lower-level methods like [locator.hover()](/docs/api/class-locator#locator-hover), [mouse.down()](/docs/api/class-mouse#mouse-down), [mouse.move()](/docs/api/class-mouse#mouse-move) and [mouse.up()](/docs/api/class-mouse#mouse-up).", "output": "await page.locator('#item-to-be-dragged').hover();  \nawait page.mouse.down();  \nawait page.locator('#item-to-drop-at').hover();  \nawait page.mouse.up();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Generate a Playwright test for the following scenario: New `maxDiffPixels` and `maxDiffPixelRatio` options for fine-grained screenshot comparison using `expect().toMatchSnapshot()`:", "input": "", "output": "expect(await page.screenshot()).toMatchSnapshot({  \n  maxDiffPixels: 27, // allow no more than 27 different pixels.  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: Grant `\"geolocation\"` permissions and set geolocation to a specific area. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Context geolocation  \n    geolocation: { longitude: 12.492507, latitude: 41.889938 },  \n    permissions: ['geolocation'],  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Generate a Playwright test for the following scenario: Use [testProject.snapshotPathTemplate](/docs/api/class-testproject#test-project-snapshot-path-template) and [testConfig.snapshotPathTemplate](/docs/api/class-testconfig#test-config-snapshot-path-template) to configure a template controlling location of snapshots generated by [expect(page).toHaveScreenshot()](/docs/api/class-pageassertions#page-assertions-to-have-screenshot-1) and [expect(value).toMatchSnapshot()](/docs/api/class-snapshotassertions#snapshot-assertions-to-match-snapshot-1). | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  testDir: './tests',  \n  snapshotPathTemplate: '{testDir}/__screenshots__/{testFilePath}/{arg}{ext}',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: Get by nth item\u200b | If you have a list of identical elements, and the only way to distinguish between them is the order, you can choose a specific element from a list with [locator.first()](/docs/api/class-locator#locator-first), [locator.last()](/docs/api/class-locator#locator-last) or [locator.nth()](/docs/api/class-locator#locator-nth).", "input": "", "output": "const banana = await page.getByRole('listitem').nth(1);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.locator('text=Log in').click();", "output": "await page.locator('text=Log in').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: New APIs\u200b | New method [route.fetch()](/docs/api/class-route#route-fetch) and new option `json` for [route.fulfill()](/docs/api/class-route#route-fulfill):", "input": "", "output": "await page.route('**/api/settings', async route => {  \n  // Fetch original settings.  \n  const response = await route.fetch();  \n  \n  // Force settings theme to a predefined value.  \n  const json = await response.json();  \n  json.theme = 'Solorized';  \n  \n  // Fulfill with modified data.  \n  await route.fulfill({ json });  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/test';  \n  \ntest.use({ storageState: 'playwright/.auth/admin.json' });  \n  \ntest('admin test', async ({ page }) => {  \n  // page is authenticated as admin  \n});  \n  \ntest.describe(() => {  \n  test.use({ storageState: 'playwright/.auth/user.json' });  \n  \n  test('user test', async ({ page }) => {  \n    // page is authenticated as a user  \n  });  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/auth", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "For example, you can use [`AxeBuilder.include()`](https://github.com/dequelabs/axe-core-npm/blob/develop/packages/playwright/README.md#axebuilderincludeselector-string--string) to constrain an accessibility scan to only run against one specific part of a page. | `AxeBuilder.analyze()` will scan the page _in its current state_ when you call it. To scan parts of a page that are revealed based on UI interactions, use [Locators](/docs/locators) to interact with the page before invoking `analyze()`:", "output": "test('navigation menu should not have automatically detectable accessibility violations', async ({  \n  page,  \n}) => {  \n  await page.goto('https://your-site.com/');  \n  \n  await page.getByRole('button', { name: 'Navigation Menu' }).click();  \n  \n  // It is important to waitFor() the page to be in the desired  \n  // state *before* running analyze(). Otherwise, axe might not  \n  // find all the elements your test expects it to scan.  \n  await page.locator('#navigation-menu-flyout').waitFor();  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .include('#navigation-menu-flyout')  \n      .analyze();  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "The difference between the [Locator](/docs/api/class-locator) and [ElementHandle](/docs/api/class-elementhandle) is that the latter points to a particular element, while [Locator](/docs/api/class-locator) captures the logic of how to retrieve that element. | Also, locators are **\"strict\" by default**!", "output": "const locator = page.locator('button');  \nawait locator.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await browserContext.route('**/api/login', route => route.fulfill({  \n  status: 200,  \n  body: 'accept',  \n}));  \nawait page.navigate('https://example.com');", "output": "await browserContext.route('**/api/login', route => route.fulfill({  \n  status: 200,  \n  body: 'accept',  \n}));  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Playwright Test uses the [pixelmatch](https://github.com/mapbox/pixelmatch) library. You can [pass various options](/docs/api/class-pageassertions#page-assertions-to-have-screenshot-1) to modify its behavior: | example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  await expect(page).toHaveScreenshot({ maxDiffPixels: 100 });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "component.spec.ts", "output": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(Component);  \n  await component.update({  \n    props: { msg: 'greetings' },  \n    on: { click() {} },  \n    slots: { default: 'Child' }  \n  });  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    httpCredentials: {  \n      username: 'bill',  \n      password: 'pa55w0rd',  \n    }  \n  }  \n});  \n\n\n\nconst context = await browser.newContext({  \n  httpCredentials: {  \n    username: 'bill',  \n    password: 'pa55w0rd',  \n  },  \n});  \nconst page = await context.newPage();  \nawait page.navigate('https://example.com');", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    httpCredentials: {  \n      username: 'bill',  \n      password: 'pa55w0rd',  \n    }  \n  }  \n});  \n\n\n\nconst context = await browser.newContext({  \n  httpCredentials: {  \n    username: 'bill',  \n    password: 'pa55w0rd',  \n  },  \n});  \nconst page = await context.newPage();  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test as base } from '@playwright/test';  \n  \nexport { expect } from '@playwright/test';  \n  \n// Must be a function that evaluates to a selector engine instance.  \nconst createTagNameEngine = () => ({  \n  // Returns the first element matching given selector in the root's subtree.  \n  query(root, selector) {  \n    return root.querySelector(selector);  \n  },  \n  \n  // Returns all elements matching given selector in the root's subtree.  \n  queryAll(root, selector) {  \n    return Array.from(root.querySelectorAll(selector));  \n  }  \n});  \n  \nexport const test = base.extend<{}, { selectorRegistration: void }>({  \n  // Register selectors once per worker.  \n  selectorRegistration: [async ({ playwright }, use) => {  \n    // Register the engine. Selectors will be prefixed with \"tag=\".  \n    await playwright.selectors.register('tag', createTagNameEngine);  \n    await use();  \n  }, { scope: 'worker', auto: true }],  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/extensibility", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const newEmail = page.getByRole('button', { name: 'New' });  \nconst dialog = page.getByText('Confirm security settings');  \nawait assert(newEmail.or(dialog).first()).toBeVisible();  \nif (await dialog.isVisible())  \n  await page.getByRole('button', { name: 'Dismiss' }).click();  \nawait newEmail.click();", "output": "const newEmail = page.getByRole('button', { name: 'New' });  \nconst dialog = page.getByText('Confirm security settings');  \nawait expect(newEmail.or(dialog).first()).toBeVisible();  \nif (await dialog.isVisible())  \n  await page.getByRole('button', { name: 'Dismiss' }).click();  \nawait newEmail.click();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Then we add the [testProject.dependencies](/docs/api/class-testproject#test-project-dependencies) property to our projects that depend on the setup project and pass into the array the name of our dependency project, which we defined in the previous step: | playwright.config.ts", "input": "", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  testDir: './tests',  \n  // ...  \n  projects: [  \n    {  \n      name: 'setup db',  \n      testMatch: /global\\.setup\\.ts/,  \n    },  \n    {  \n      name: 'chromium with db',  \n      use: { ...devices['Desktop Chrome'] },  \n      dependencies: ['setup db'],  \n    },  \n  ]  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // ...  \n  use: {  \n    clientCertificates: [{  \n      origin: 'https://example.com',  \n      certPath: './cert.pem',  \n      keyPath: './key.pem',  \n      passphrase: 'mysecretpassword',  \n    }],  \n  },  \n  // ...  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // ...  \n  use: {  \n    clientCertificates: [{  \n      origin: 'https://example.com',  \n      certPath: './cert.pem',  \n      keyPath: './key.pem',  \n      passphrase: 'mysecretpassword',  \n    }],  \n  },  \n  // ...  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: You can override options for a specific test file by using the `test.use()` method and passing in the options. For example to run tests with the French locale for a specific test:", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({ locale: 'fr-FR' });  \n  \ntest('example', async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-use-options"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    colorScheme: 'dark',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/emulation", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.route('**/*.{png,jpg,jpeg}', route => route.abort());  \n  \n// Abort based on the request type  \nawait page.route('**/*', route => {  \n  return route.request().resourceType() === 'image' ? route.abort() : route.continue();  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/network", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Traces are recorded using the new [browserContext.tracing](/docs/api/class-browsercontext#browser-context-tracing) API:", "output": "const browser = await chromium.launch();  \nconst context = await browser.newContext();  \n  \n// Start tracing before creating / navigating a page.  \nawait context.tracing.start({ screenshots: true, snapshots: true });  \n  \nconst page = await context.newPage();  \nawait page.goto('https://playwright.dev');  \n  \n// Stop tracing and export it into a zip archive.  \nawait context.tracing.stop({ path: 'trace.zip' });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test.beforeEach(async ({ page, isMobile }) => {  \n  test.fixme(isMobile, 'Settings page does not work in mobile yet');  \n  \n  await page.navigate('http://localhost:3000/settings');  \n});  \n  \ntest('user profile', async ({ page }) => {  \n  await page.getByText('My Profile').click();  \n  // ...  \n});", "output": "test.beforeEach(async ({ page, isMobile }) => {  \n  test.fixme(isMobile, 'Settings page does not work in mobile yet');  \n  \n  await page.goto('http://localhost:3000/settings');  \n});  \n  \ntest('user profile', async ({ page }) => {  \n  await page.getByText('My Profile').click();  \n  // ...  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-annotations", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \nimport dotenv from 'dotenv';  \nimport path from 'path';  \n  \n// Read from \".env\" file.  \ndotenv.config({ path: path.resolve(__dirname, '.env') });  \n  \n// Alternatively, read from \"../my.env\" file.  \ndotenv.config({ path: path.resolve(__dirname, '..', 'my.env') });  \n  \nexport default defineConfig({  \n  use: {  \n    baseURL: process.env.STAGING === '1' ? 'http://staging.example.test/' : 'http://example.test/',  \n  }  \n});", "output": "import { defineConfig } from '@playwright/test';  \nimport dotenv from 'dotenv';  \nimport path from 'path';  \n  \n// Read from \".env\" file.  \ndotenv.config({ path: path.resolve(__dirname, '.env') });  \n  \n// Alternatively, read from \"../my.env\" file.  \ndotenv.config({ path: path.resolve(__dirname, '..', 'my.env') });  \n  \nexport default defineConfig({  \n  use: {  \n    baseURL: process.env.STAGING === '1' ? 'http://staging.example.test/' : 'http://example.test/',  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parameterize", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.getByRole('link', { name: 'Get started' }).click();", "output": "await page.getByRole('link', { name: 'Get started' }).click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/writing-tests", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "And then locate the element as you would normally do:", "output": "await page.getByTestId('directions').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('unmount', async ({ mount }) => {  \n  const component = await mount(<Component/>);  \n  await component.unmount();  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "[  \n  { name: 'Alice', expected: 'Hello, Alice!' },  \n  { name: 'Bob', expected: 'Hello, Bob!' },  \n  { name: 'Charlie', expected: 'Hello, Charlie!' },  \n].forEach(({ name, expected }) => {  \n  // You can also do it with test.describe() or with multiple tests as long the test name is unique.  \n  test(`testing with ${name}`, async ({ page }) => {  \n    await page.goto(`https://example.com/greet?name=${name}`);  \n    await expect(page.getByRole('heading')).toHaveText(expected);  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parameterize", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Create a page.  \nconst page = await context.newPage();  \n  \n// Navigate explicitly, similar to entering a URL in the browser.  \nawait page.goto('http://example.com');  \n// Fill an input.  \nawait page.locator('#search').fill('query');  \n  \n// Navigate implicitly by clicking a link.  \nawait page.locator('#submit').click();  \n// Expect a new url.  \nconsole.log(page.url());", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/pages", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Make a few checks that will not stop the test when failed...  \nawait assert.soft(page.getByTestId('status')).toHaveText('Success');  \nawait assert.soft(page.getByTestId('eta')).toHaveText('1 day');  \n  \n// ... and continue the test to check more things.  \nawait page.getByRole('link', { name: 'next page' }).click();  \nawait assert.soft(page.getByRole('heading', { name: 'Make another order' })).toBeVisible();", "output": "// Make a few checks that will not stop the test when failed...  \nawait expect.soft(page.getByTestId('status')).toHaveText('Success');  \nawait expect.soft(page.getByTestId('eta')).toHaveText('1 day');  \n  \n// ... and continue the test to check more things.  \nawait page.getByRole('link', { name: 'next page' }).click();  \nawait expect.soft(page.getByRole('heading', { name: 'Make another order' })).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Setup the handler.  \nawait page.addLocatorHandler(  \n    page.getByRole('heading', { name: 'Hej! You are in control of your cookies.' }),  \n    async () => {  \n      await page.getByRole('button', { name: 'Accept all' }).click();  \n    });  \n// Write the test as usual.  \nawait page.goto('https://www.ikea.com/');  \nawait page.getByRole('link', { name: 'Collection of blue and white' }).click();  \nawait expect(page.getByRole('heading', { name: 'Light and easy' })).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/experimental-ct-vue';  \nimport type { HooksConfig } from '../playwright';  \nimport ProductsPage from './pages/ProductsPage.vue';  \n  \ntest('configure routing through hooks config', async ({ page, mount }) => {  \n  const component = await mount<HooksConfig>(ProductsPage, {  \n    hooksConfig: { enableRouting: true },  \n  });  \n  await assert(component.getByRole('link')).toHaveAttribute('href', '/products/42');  \n});", "output": "import { test, expect } from '@playwright/experimental-ct-vue';  \nimport type { HooksConfig } from '../playwright';  \nimport ProductsPage from './pages/ProductsPage.vue';  \n  \ntest('configure routing through hooks config', async ({ page, mount }) => {  \n  const component = await mount<HooksConfig>(ProductsPage, {  \n    hooksConfig: { enableRouting: true },  \n  });  \n  await expect(component.getByRole('link')).toHaveAttribute('href', '/products/42');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test('this will work', async ({ mount }) => {  \n  const component = await mount(<ProcessViewer process={{ name: 'playwright' }}/>);  \n});  \n  \ntest('this will not work', async ({ mount }) => {  \n  // `process` is a Node object, we can't pass it to the browser and expect it to work.  \n  const component = await mount(<ProcessViewer process={process}/>);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Use the [code generator](/docs/codegen) to generate a locator, and then edit it as you'd like. | Every time a locator is used for an action, an up-to-date DOM element is located in the page. In the snippet below, the underlying DOM element will be located twice, once prior to every action. This means that if the DOM changes in between the calls due to re-render, the new element corresponding to the locator will be used.", "input": "", "output": "const locator = page.getByRole('button', { name: 'Sign in' });  \n  \nawait locator.hover();  \nawait locator.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Vue locator allows finding elements by their component name and property values. The syntax is very similar to [CSS attribute selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors) and supports all CSS attribute selector operators. | In Vue locator, component names are transcribed with **kebab-case**.", "output": "await page.locator('_vue=book-item').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        locale: 'de-DE',  \n      },  \n    },  \n  ],  \n});", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        locale: 'de-DE',  \n      },  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Below is an example that [creates fixtures](/docs/test-fixtures#creating-a-fixture) for two [Page Object Models](/docs/pom) \\- admin POM and user POM. It assumes `adminStorageState.json` and `userStorageState.json` files were created in the global setup. | playwright/fixtures.ts", "input": "", "output": "import { test as base, type Page, type Locator } from '@playwright/test';  \n  \n// Page Object Model for the \"admin\" page.  \n// Here you can add locators and helper methods specific to the admin page.  \nclass AdminPage {  \n  // Page signed in as \"admin\".  \n  page: Page;  \n  \n  // Example locator pointing to \"Welcome, Admin\" greeting.  \n  greeting: Locator;  \n  \n  constructor(page: Page) {  \n    this.page = page;  \n    this.greeting = page.locator('#greeting');  \n  }  \n}  \n  \n// Page Object Model for the \"user\" page.  \n// Here you can add locators and helper methods specific to the user page.  \nclass UserPage {  \n  // Page signed in as \"user\".  \n  page: Page;  \n  \n  // Example locator pointing to \"Welcome, User\" greeting.  \n  greeting: Locator;  \n  \n  constructor(page: Page) {  \n    this.page = page;  \n    this.greeting = page.locator('#greeting');  \n  }  \n}  \n  \n// Declare the types of your fixtures.  \ntype MyFixtures = {  \n  adminPage: AdminPage;  \n  userPage: UserPage;  \n};  \n  \nexport * from '@playwright/test';  \nexport const test = base.extend<MyFixtures>({  \n  adminPage: async ({ browser }, use) => {  \n    const context = await browser.newContext({ storageState: 'playwright/.auth/admin.json' });  \n    const adminPage = new AdminPage(await context.newPage());  \n    await use(adminPage);  \n    await context.close();  \n  },  \n  userPage: async ({ browser }, use) => {  \n    const context = await browser.newContext({ storageState: 'playwright/.auth/user.json' });  \n    const userPage = new UserPage(await context.newPage());  \n    await use(userPage);  \n    await context.close();  \n  },  \n});", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const { chromium } = require('playwright');  \n  \n(async () => {  \n  const browser = await chromium.launch();  \n  // Create pages, interact with UI elements, assert values  \n  await browser.close();  \n})();", "output": "const { chromium } = require('playwright');  \n  \n(async () => {  \n  const browser = await chromium.launch();  \n  // Create pages, interact with UI elements, assert values  \n  await browser.close();  \n})();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/library", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Validating postconditions\u200b | The following test creates a new issue via user interface in the browser and then uses checks if it was created via API:", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \nconst REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \n// Request context is reused by all tests in the file.  \nlet apiContext;  \n  \ntest.beforeAll(async ({ playwright }) => {  \n  apiContext = await playwright.request.newContext({  \n    // All requests we send go to this API endpoint.  \n    baseURL: 'https://api.github.com',  \n    extraHTTPHeaders: {  \n      // We set this header per GitHub guidelines.  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add authorization token to all requests.  \n      // Assuming personal access token available in the environment.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    },  \n  });  \n});  \n  \ntest.afterAll(async ({ }) => {  \n  // Dispose all responses.  \n  await apiContext.dispose();  \n});  \n  \ntest('last created issue should be on the server', async ({ page }) => {  \n  await page.goto(`https://github.com/${USER}/${REPO}/issues`);  \n  await page.getByText('New Issue').click();  \n  await page.getByRole('textbox', { name: 'Title' }).fill('Bug report 1');  \n  await page.getByRole('textbox', { name: 'Comment body' }).fill('Bug description');  \n  await page.getByText('Submit new issue').click();  \n  const issueId = page.url().substr(page.url().lastIndexOf('/'));  \n  \n  const newIssue = await apiContext.get(  \n      `https://api.github.com/repos/${USER}/${REPO}/issues/${issueId}`  \n  );  \n  expect(newIssue.ok()).toBeTruthy();  \n  expect(newIssue.json()).toEqual(expect.objectContaining({  \n    title: 'Bug report 1'  \n  }));  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/api-testing"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.getByText('Click me').click();  \nawait page.waitForURL('**/login');", "output": "await page.getByText('Click me').click();  \nawait page.waitForURL('**/login');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/navigations", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Playwright Test runs tests in worker processes. These processes are OS processes, running independently, orchestrated by the test runner. All workers have identical environments and each starts its own browser. | Consider the following snippet:", "input": "", "output": "import { test } from '@playwright/test';  \n  \ntest.describe('suite', () => {  \n  test.beforeAll(async () => { /* ... */ });  \n  test('first good', async ({ page }) => { /* ... */ });  \n  test('second flaky', async ({ page }) => { /* ... */ });  \n  test('third good', async ({ page }) => { /* ... */ });  \n  test.afterAll(async () => { /* ... */ });  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-retries"}}
{"instruction": "Generate a Playwright test for the following scenario: It is now possible to do response interception by combining [API Testing](/docs/api-testing) with [request interception](/docs/network#modify-requests). | For example, we can blur all the images on the page:", "input": "", "output": "import { test, expect } from '@playwright/test';  \nimport jimp from 'jimp'; // image processing library  \n  \ntest('response interception', async ({ page }) => {  \n  await page.route('**/*.jpeg', async route => {  \n    const response = await page._request.fetch(route.request());  \n    const image = await jimp.read(await response.body());  \n    await image.blur(5);  \n    await route.fulfill({  \n      response,  \n      body: await image.getBufferAsync('image/jpeg'),  \n    });  \n  });  \n  const response = await page.goto('https://playwright.dev');  \n  expect(response.status()).toBe(200);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Rest of your config...  \n  \n  // Run your local dev server before starting the tests  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n    timeout: 120 * 1000,  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Rest of your config...  \n  \n  // Run your local dev server before starting the tests  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n    timeout: 120 * 1000,  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-webserver", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from './my-test';  \n  \ntest('test 1', async ({ page, person }) => {  \n  await page.goto(`/index.html`);  \n  await expect(page.locator('#node')).toContainText(person);  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parameterize", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert(page.locator('body')).toMatchAriaSnapshot(`  \n  - heading \"title\"  \n`);", "output": "await expect(page.locator('body')).toMatchAriaSnapshot(`  \n  - heading \"title\"  \n`);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/aria-snapshots", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    testIdAttribute: 'data-pw'  \n  }  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    testIdAttribute: 'data-pw'  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "// Fill the input by targeting the label.  \nawait expect(page.locator('label')).toHaveText('Password');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/other-locators", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "Use [test.describe.serial()](/docs/api/class-test#test-describe-serial) to group dependent tests to ensure they will always run together and in order. If one of the tests fails, all subsequent tests are skipped. All tests in the group are retried together. | Consider the following snippet that uses `test.describe.serial`:", "output": "import { test } from '@playwright/test';  \n  \ntest.describe.configure({ mode: 'serial' });  \n  \ntest.beforeAll(async () => { /* ... */ });  \ntest('first good', async ({ page }) => { /* ... */ });  \ntest('second flaky', async ({ page }) => { /* ... */ });  \ntest('third good', async ({ page }) => { /* ... */ });", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-retries"}}
{"instruction": "Generate a Playwright test for the following scenario: Playwright Test uses the [pixelmatch](https://github.com/mapbox/pixelmatch) library. You can [pass various options](/docs/api/class-pageassertions#page-assertions-to-have-screenshot-1) to modify its behavior: | example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  await expect(page).toHaveScreenshot({ maxDiffPixels: 100 });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.getByRole('button', { name: 'Sign in' }).click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: alert(), confirm(), prompt() dialogs\u200b | By default, dialogs are auto-dismissed by Playwright, so you don't have to handle them. However, you can register a dialog handler before the action that triggers the dialog to either [dialog.accept()](/docs/api/class-dialog#dialog-accept) or [dialog.dismiss()](/docs/api/class-dialog#dialog-dismiss) it.", "input": "", "output": "page.on('dialog', dialog => dialog.accept());  \nawait page.getByRole('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/dialogs"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Replaying from HAR\u200b | Now that you have the HAR file recorded and modified the mock data, it can be used to serve matching responses in the test. For this, just turn off or simply remove the `update` option. This will run the test against the HAR file instead of hitting the API.", "output": "test('gets the json from HAR and checks the new fruit has been added', async ({ page }) => {  \n  // Replay API requests from HAR.  \n  // Either use a matching response from the HAR,  \n  // or abort the request if nothing matches.  \n  await page.routeFromHAR('./hars/fruit.har', {  \n    url: '*/**/api/v1/fruits',  \n    update: false,  \n  });  \n  \n  // Go to the page  \n  await page.goto('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the Playwright fruit is visible  \n  await expect(page.getByText('Playwright', { exact: true })).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('group', {  \n  tag: '@report',  \n}, () => {  \n  test('test report header', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('test full report', {  \n    tag: ['@slow', '@vrt'],  \n  }, async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: playwright-dev-page.ts", "input": "", "output": "import { expect, type Locator, type Page } from '@playwright/test';  \n  \nexport class PlaywrightDevPage {  \n  readonly page: Page;  \n  readonly getStartedLink: Locator;  \n  readonly gettingStartedHeader: Locator;  \n  readonly pomLink: Locator;  \n  readonly tocList: Locator;  \n  \n  constructor(page: Page) {  \n    this.page = page;  \n    this.getStartedLink = page.locator('a', { hasText: 'Get started' });  \n    this.gettingStartedHeader = page.locator('h1', { hasText: 'Installation' });  \n    this.pomLink = page.locator('li', {  \n      hasText: 'Guides',  \n    }).locator('a', {  \n      hasText: 'Page Object Model',  \n    });  \n    this.tocList = page.locator('article div.markdown ul > li > a');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://playwright.dev');  \n  }  \n  \n  async getStarted() {  \n    await this.getStartedLink.first().click();  \n    await expect(this.gettingStartedHeader).toBeVisible();  \n  }  \n  \n  async pageObjectModel() {  \n    await this.getStarted();  \n    await this.pomLink.click();  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/pom"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "This will also set the default timeouts of Playwright to 0 (= no timeout). | To debug your tests using the browser developer tools, start by setting a breakpoint in your test to pause the execution using the [page.pause()](/docs/api/class-page#page-pause) method.", "output": "await page.pause();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/debug"}}
{"instruction": "Generate a Playwright test for the following scenario: Mock API requests\u200b | The following code will intercept all the calls to `*/**/api/v1/fruits` and will return a custom response instead. No requests to the API will be made. The test goes to the URL that uses the mocked route and asserts that mock data is present on the page.", "input": "", "output": "test(\"mocks a fruit and doesn't call api\", async ({ page }) => {  \n  // Mock the api call before navigating  \n  await page.route('*/**/api/v1/fruits', async route => {  \n    const json = [{ name: 'Strawberry', id: 21 }];  \n    await route.fulfill({ json });  \n  });  \n  // Go to the page  \n  await page.goto('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the Strawberry fruit is visible  \n  await expect(page.getByText('Strawberry')).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "New [locator.and()](/docs/api/class-locator#locator-and) to create a locator that matches both locators.", "output": "const button = page.getByRole('button').and(page.getByTitle('Subscribe'));", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: Emulate the network being offline. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    offline: true  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as setup } from '@playwright/test';  \n  \nconst authFile = 'playwright/.auth/user.json';  \n  \nsetup('authenticate', async ({ request }) => {  \n  // Send authentication request. Replace with your own.  \n  await request.post('https://github.com/login', {  \n    form: {  \n      'user': 'user',  \n      'password': 'password'  \n    }  \n  });  \n  await request.storageState({ path: authFile });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/auth", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "component.spec.ts", "output": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('event', async ({ mount }) => {  \n  const component = await mount(Component, { on: { click() {} } });  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Locate an item by its text content and click it.", "output": "await page.getByText('orange').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { chromium, type FullConfig } from '@playwright/test';  \n  \nasync function globalSetup(config: FullConfig) {  \n  const { baseURL, storageState } = config.projects[0].use;  \n  const browser = await chromium.launch();  \n  const page = await browser.newPage();  \n  await page.goto(baseURL!);  \n  await page.getByLabel('User Name').fill('user');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByText('Sign in').click();  \n  await page.context().storageState({ path: storageState as string });  \n  await browser.close();  \n}  \n  \nexport default globalSetup;", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the form_interaction pattern.", "input": "Create a story file for your component: | input-media.story.tsx", "output": "import React from 'react';  \nimport InputMedia from './import-media';  \n  \ntype InputMediaForTestProps = {  \n  onMediaChange(mediaName: string): void;  \n};  \n  \nexport function InputMediaForTest(props: InputMediaForTestProps) {  \n  // Instead of sending a complex `media` object to the test, send the media name.  \n  return <InputMedia onChange={media => props.onMediaChange(media.name)} />;  \n}  \n// Export more stories here.", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Behavior Change\u200b | A bunch of Playwright APIs already support the `waitUntil: 'domcontentloaded'` option. For example:", "output": "await page.goto('https://playwright.dev', {  \n  waitUntil: 'domcontentloaded',  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.getByLabel('Password').fill('secret');", "output": "await page.getByLabel('Password').fill('secret');", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Forcing the click\u200b | Sometimes, apps use non-trivial logic where hovering the element overlays it with another element that intercepts the click. This behavior is indistinguishable from a bug where element gets covered and the click is dispatched elsewhere. If you know this is taking place, you can bypass the [actionability](/docs/actionability) checks and force the click:", "output": "await page.getByRole('button').click({ force: true });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Mouse click\u200b | Performs a simple human click.", "output": "// Generic click  \nawait page.getByRole('button').click();  \n  \n// Double click  \nawait page.getByText('Item').dblclick();  \n  \n// Right click  \nawait page.getByText('Item').click({ button: 'right' });  \n  \n// Shift + click  \nawait page.getByText('Item').click({ modifiers: ['Shift'] });  \n  \n// Ctrl + click or Windows and Linux  \n// Meta + click on macOS  \nawait page.getByText('Item').click({ modifiers: ['ControlOrMeta'] });  \n  \n// Hover over element  \nawait page.getByText('Item').hover();  \n  \n// Click the top left corner  \nawait page.getByText('Item').click({ position: { x: 0, y: 0 } });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input", "type": "navigation"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "`beforeAll` and `afterAll` hooks have a separate timeout, by default equal to test timeout. You can change it separately for each hook by calling [testInfo.setTimeout()](/docs/api/class-testinfo#test-info-set-timeout) inside the hook. | example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.beforeAll(async () => {  \n  // Set timeout for this hook.  \n  test.setTimeout(60000);  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-timeouts"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Here we compare text content against the reference. | example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  expect(await page.textContent('.hero__title')).toMatchSnapshot('hero.txt');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // ...  \n  use: {  \n    clientCertificates: [{  \n      origin: 'https://example.com',  \n      certPath: './cert.pem',  \n      keyPath: './key.pem',  \n      passphrase: 'mysecretpassword',  \n    }],  \n  },  \n  // ...  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Each test should be completely isolated from another test and should run independently with its own local storage, session storage, data, cookies etc. [Test isolation](/docs/browser-contexts) improves reproducibility, makes debugging easier and prevents cascading test failures. | In order to avoid repetition for a particular part of your test you can use [before and after hooks](/docs/api/class-test). Within your test file add a before hook to run a part of your test before each test such as going to a particular URL or logging in to a part of your app. This keeps your tests isolated as no test relies on another. However it is also ok to have a little duplication when tests are simple enough especially if it keeps your tests clearer and easier to read and maintain.", "output": "import { test } from '@playwright/test';  \n  \ntest.beforeEach(async ({ page }) => {  \n  // Runs before each test and signs in each page.  \n  await page.goto('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('username');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n});  \n  \ntest('first', async ({ page }) => {  \n  // page is signed in.  \n});  \n  \ntest('second', async ({ page }) => {  \n  // page is signed in.  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/best-practices", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "assert(value).not.toEqual(0);  \nawait assert(locator).not.toContainText('some text');", "output": "expect(value).not.toEqual(0);  \nawait expect(locator).not.toContainText('some text');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: 'line',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Network events\u200b | You can monitor all the [Request](/docs/api/class-request \"Request\")s and [Response](/docs/api/class-response \"Response\")s:", "output": "// Subscribe to 'request' and 'response' events.  \npage.on('request', request => console.log('>>', request.method(), request.url()));  \npage.on('response', response => console.log('<<', response.status(), response.url()));  \n  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Generate a Playwright test for the following scenario: Other Options\u200b | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Maximum time each action such as `click()` can take. Defaults to 0 (no limit).  \n    actionTimeout: 0,  \n  \n    // Name of the browser that runs tests. For example `chromium`, `firefox`, `webkit`.  \n    browserName: 'chromium',  \n  \n    // Toggles bypassing Content-Security-Policy.  \n    bypassCSP: true,  \n  \n    // Channel to use, for example \"chrome\", \"chrome-beta\", \"msedge\", \"msedge-beta\".  \n    channel: 'chrome',  \n  \n    // Run browser in headless mode.  \n    headless: false,  \n  \n    // Change the default data-testid attribute.  \n    testIdAttribute: 'pw-test-id',  \n  },  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-use-options"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.locator('#item-to-be-dragged').hover();  \nawait page.mouse.down();  \nawait page.locator('#item-to-drop-at').hover();  \nawait page.mouse.up();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input", "type": "website_test"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "my-test.js", "output": "const base = require('@playwright/test');  \n  \nexports.test = base.test.extend({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  person: ['John', { option: true }],  \n  \n  // Override default \"page\" fixture.  \n  page: async ({ page, person }, use) => {  \n    await page.goto('/chat');  \n    // We use \"person\" parameter as a \"name\" for the chat room.  \n    await page.getByLabel('User Name').fill(person);  \n    await page.getByText('Enter chat room').click();  \n    // Each test will get a \"page\" that already has the person name.  \n    await use(page);  \n  },  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-parameterize", "type": "fixture"}}
{"instruction": "Generate a Playwright test for the following scenario: Legacy text locator has a few variations: | `text=Log in` \\- default matching is case-insensitive, trims whitespace and searches for a substring. For example, `text=Log` matches `<button>Log in</button>`.", "input": "", "output": "await page.locator('text=Log in').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test for the following scenario: Then use these fixtures in a test:", "input": "", "output": "import { test, expect } from './fixtures';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://example.com');  \n  await expect(page.locator('body')).toHaveText('Changed by my-extension');  \n});  \n  \ntest('popup page', async ({ page, extensionId }) => {  \n  await page.goto(`chrome-extension://${extensionId}/popup.html`);  \n  await expect(page.locator('body')).toHaveText('my-extension popup');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/chrome-extensions"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "If the page opens a pop-up (e.g. pages opened by `target=\"_blank\"` links), you can get a reference to it by listening to the `popup` event on the page. | This event is emitted in addition to the `browserContext.on('page')` event, but only for popups relevant to this page.", "output": "// Start waiting for popup before clicking. Note no await.  \nconst popupPromise = page.waitForEvent('popup');  \nawait page.getByText('open the popup').click();  \nconst popup = await popupPromise;  \n// Interact with the new popup normally.  \nawait popup.getByRole('button').click();  \nconsole.log(await popup.title());", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/pages"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "And then locate the element as you would normally do:", "output": "await page.getByTestId('directions').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Now use this reporter with [testConfig.reporter](/docs/api/class-testconfig#test-config-reporter). | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: './my-awesome-reporter.ts',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Generate a Playwright test for the following scenario: New property [testInfo.tags](/docs/api/class-testinfo#test-info-tags) exposes test tags during test execution.", "input": "", "output": "test('example', async ({ page }) => {  \n  console.log(test.info().tags);  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  timeout: 60000, // Timeout is shared between all tests.  \n  projects: [  \n    {  \n      name: 'staging',  \n      use: {  \n        baseURL: 'staging.example.com',  \n      },  \n      retries: 2,  \n    },  \n    {  \n      name: 'production',  \n      use: {  \n        baseURL: 'production.example.com',  \n      },  \n      retries: 0,  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-projects", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "To launch a server during the tests, use the [`webServer`](/docs/test-webserver) option in the configuration file. The server will wait for a given url to be available before running the tests, and the url will be passed over to Playwright as a [`baseURL`](/docs/api/class-testoptions#test-options-base-url) when creating a context. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  webServer: {  \n    command: 'npm run start', // command to launch  \n    url: 'http://127.0.0.1:3000', // url to await for  \n    timeout: 120 * 1000,  \n    reuseExistingServer: !process.env.CI,  \n  },  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  expect: {  \n    toHaveScreenshot: { maxDiffPixels: 100 },  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Handle requests\u200b", "output": "await page.route('**/api/fetch_data', route => route.fulfill({  \n  status: 200,  \n  body: testData,  \n}));  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('report tests', {  \n  annotation: { type: 'category', description: 'report' },  \n}, () => {  \n  test('test report header', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('test full report', {  \n    annotation: [  \n      { type: 'issue', description: 'https://github.com/microsoft/playwright/issues/23180' },  \n      { type: 'performance', description: 'very slow test!' },  \n    ],  \n  }, async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    /* Test against branded browsers. */  \n    {  \n      name: 'Google Chrome',  \n      use: { ...devices['Desktop Chrome'], channel: 'chrome' }, // or 'chrome-beta'  \n    },  \n    {  \n      name: 'Microsoft Edge',  \n      use: { ...devices['Desktop Edge'], channel: 'msedge' }, // or \"msedge-beta\" or 'msedge-dev'  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/browsers", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['list', { printSteps: true }]],  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['list', { printSteps: true }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "In the setup project: | tests/auth.setup.ts", "output": "import { test as setup } from '@playwright/test';  \n  \nconst authFile = 'playwright/.auth/user.json';  \n  \nsetup('authenticate', async ({ request }) => {  \n  // Send authentication request. Replace with your own.  \n  await request.post('https://github.com/login', {  \n    form: {  \n      'user': 'user',  \n      'password': 'password'  \n    }  \n  });  \n  await request.storageState({ path: authFile });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "page.on('dialog', async dialog => {  \n  assert(dialog.type() === 'beforeunload');  \n  await dialog.dismiss();  \n});  \nawait page.close({ runBeforeUnload: true });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/dialogs", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: If you'd like to share the default value among all the tests in the project, you can specify it in the playwright config, either globally or per project: | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  expect: {  \n    toHaveScreenshot: { maxDiffPixels: 100 },  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \nimport AxeBuilder from '@axe-core/playwright'; // 1  \n  \ntest.describe('homepage', () => { // 2  \n  test('should not have any automatically detectable accessibility issues', async ({ page }) => {  \n    await page.navigate('https://your-site.com/'); // 3  \n  \n    const accessibilityScanResults = await new AxeBuilder({ page }).analyze(); // 4  \n  \n    assert(accessibilityScanResults.violations).toEqual([]); // 5  \n  });  \n});  \n\n\n\nconst { test, assert } = require('@playwright/test');  \nconst AxeBuilder = require('@axe-core/playwright').default; // 1  \n  \ntest.describe('homepage', () => { // 2  \n  test('should not have any automatically detectable accessibility issues', async ({ page }) => {  \n    await page.navigate('https://your-site.com/'); // 3  \n  \n    const accessibilityScanResults = await new AxeBuilder({ page }).analyze(); // 4  \n  \n    assert(accessibilityScanResults.violations).toEqual([]); // 5  \n  });  \n});", "output": "import { test, expect } from '@playwright/test';  \nimport AxeBuilder from '@axe-core/playwright'; // 1  \n  \ntest.describe('homepage', () => { // 2  \n  test('should not have any automatically detectable accessibility issues', async ({ page }) => {  \n    await page.goto('https://your-site.com/'); // 3  \n  \n    const accessibilityScanResults = await new AxeBuilder({ page }).analyze(); // 4  \n  \n    expect(accessibilityScanResults.violations).toEqual([]); // 5  \n  });  \n});  \n\n\n\nconst { test, expect } = require('@playwright/test');  \nconst AxeBuilder = require('@axe-core/playwright').default; // 1  \n  \ntest.describe('homepage', () => { // 2  \n  test('should not have any automatically detectable accessibility issues', async ({ page }) => {  \n    await page.goto('https://your-site.com/'); // 3  \n  \n    const accessibilityScanResults = await new AxeBuilder({ page }).analyze(); // 4  \n  \n    expect(accessibilityScanResults.violations).toEqual([]); // 5  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: 'line',  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: 'line',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.addInitScript(() => {  \n  Object.defineProperty(Object.getPrototypeOf(navigator), 'cookieEnabled', { value: false });  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/mock-browser-apis", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Capture screenshot after each test failure.  \n    screenshot: 'only-on-failure',  \n  \n    // Record trace only when retrying a test for the first time.  \n    trace: 'on-first-retry',  \n  \n    // Record video only when retrying a test for the first time.  \n    video: 'on-first-retry'  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "<div id=\"current-time\" data-testid=\"current-time\"></div>  \n<script>  \n  const renderTime = () => {  \n    document.getElementById('current-time').textContent =  \n        new Date().toLocaleString();  \n  };  \n  setInterval(renderTime, 1000);  \n</script>  \n\n\n\n// Initialize clock with some time before the test time and let the page load  \n// naturally. `Date.now` will progress as the timers fire.  \nawait page.clock.install({ time: new Date('2024-02-02T08:00:00') });  \nawait page.goto('http://localhost:3333');  \n  \n// Pretend that the user closed the laptop lid and opened it again at 10am,  \n// Pause the time once reached that point.  \nawait page.clock.pauseAt(new Date('2024-02-02T10:00:00'));  \n  \n// Assert the page state.  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \n// Close the laptop lid again and open it at 10:30am.  \nawait page.clock.fastForward('30:00');  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:30:00 AM');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/clock", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "app.spec.ts", "output": "import { test, expect } from '@playwright/experimental-ct-svelte';  \nimport App from './App.svelte';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(App);  \n  await expect(component).toContainText('Learn Svelte');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as setup } from '@playwright/test';  \n  \nsetup('create new database', async ({ }) => {  \n  console.log('creating new database...');  \n  // Initialize the database  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import type { Page, Locator } from '@playwright/test';  \n  \nexport class TodoPage {  \n  private readonly inputBox: Locator;  \n  private readonly todoItems: Locator;  \n  \n  constructor(public readonly page: Page) {  \n    this.inputBox = this.page.locator('input.new-todo');  \n    this.todoItems = this.page.getByTestId('todo-item');  \n  }  \n  \n  async goto() {  \n    await this.page.navigate('https://demo.playwright.dev/todomvc/');  \n  }  \n  \n  async addToDo(text: string) {  \n    await this.inputBox.fill(text);  \n    await this.inputBox.press('Enter');  \n  }  \n  \n  async remove(text: string) {  \n    const todo = this.todoItems.filter({ hasText: text });  \n    await todo.hover();  \n    await todo.getByLabel('Delete').click();  \n  }  \n  \n  async removeAll() {  \n    while ((await this.todoItems.count()) > 0) {  \n      await this.todoItems.first().hover();  \n      await this.todoItems.getByLabel('Delete').first().click();  \n    }  \n  }  \n}", "output": "import type { Page, Locator } from '@playwright/test';  \n  \nexport class TodoPage {  \n  private readonly inputBox: Locator;  \n  private readonly todoItems: Locator;  \n  \n  constructor(public readonly page: Page) {  \n    this.inputBox = this.page.locator('input.new-todo');  \n    this.todoItems = this.page.getByTestId('todo-item');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://demo.playwright.dev/todomvc/');  \n  }  \n  \n  async addToDo(text: string) {  \n    await this.inputBox.fill(text);  \n    await this.inputBox.press('Enter');  \n  }  \n  \n  async remove(text: string) {  \n    const todo = this.todoItems.filter({ hasText: text });  \n    await todo.hover();  \n    await todo.getByLabel('Delete').click();  \n  }  \n  \n  async removeAll() {  \n    while ((await this.todoItems.count()) > 0) {  \n      await this.todoItems.first().hover();  \n      await this.todoItems.getByLabel('Delete').first().click();  \n    }  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Click the third \"Buy\" button  \nawait page.locator(':nth-match(:text(\"Buy\"), 3)').click();", "output": "// Click the third \"Buy\" button  \nawait page.locator(':nth-match(:text(\"Buy\"), 3)').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as base } from '@playwright/test';  \n  \ntype Account = {  \n  username: string;  \n  password: string;  \n};  \n  \n// Note that we pass worker fixture types as a second template parameter.  \nexport const test = base.extend<{}, { account: Account }>({  \n  account: [async ({ browser }, use, workerInfo) => {  \n    // Unique username.  \n    const username = 'user' + workerInfo.workerIndex;  \n    const password = 'verysecure';  \n  \n    // Create the account with Playwright.  \n    const page = await browser.newPage();  \n    await page.navigate('/signup');  \n    await page.getByLabel('User Name').fill(username);  \n    await page.getByLabel('Password').fill(password);  \n    await page.getByText('Sign up').click();  \n    // Make sure everything is ok.  \n    await assert(page.getByTestId('result')).toHaveText('Success');  \n    // Do not forget to cleanup.  \n    await page.close();  \n  \n    // Use the account value.  \n    await use({ username, password });  \n  }, { scope: 'worker' }],  \n  \n  page: async ({ page, account }, use) => {  \n    // Sign in with our account.  \n    const { username, password } = account;  \n    await page.navigate('/signin');  \n    await page.getByLabel('User Name').fill(username);  \n    await page.getByLabel('Password').fill(password);  \n    await page.getByText('Sign in').click();  \n    await assert(page.getByTestId('userinfo')).toHaveText(username);  \n  \n    // Use signed-in page in the test.  \n    await use(page);  \n  },  \n});  \nexport { assert } from '@playwright/test';", "output": "import { test as base } from '@playwright/test';  \n  \ntype Account = {  \n  username: string;  \n  password: string;  \n};  \n  \n// Note that we pass worker fixture types as a second template parameter.  \nexport const test = base.extend<{}, { account: Account }>({  \n  account: [async ({ browser }, use, workerInfo) => {  \n    // Unique username.  \n    const username = 'user' + workerInfo.workerIndex;  \n    const password = 'verysecure';  \n  \n    // Create the account with Playwright.  \n    const page = await browser.newPage();  \n    await page.goto('/signup');  \n    await page.getByLabel('User Name').fill(username);  \n    await page.getByLabel('Password').fill(password);  \n    await page.getByText('Sign up').click();  \n    // Make sure everything is ok.  \n    await expect(page.getByTestId('result')).toHaveText('Success');  \n    // Do not forget to cleanup.  \n    await page.close();  \n  \n    // Use the account value.  \n    await use({ username, password });  \n  }, { scope: 'worker' }],  \n  \n  page: async ({ page, account }, use) => {  \n    // Sign in with our account.  \n    const { username, password } = account;  \n    await page.goto('/signin');  \n    await page.getByLabel('User Name').fill(username);  \n    await page.getByLabel('Password').fill(password);  \n    await page.getByText('Sign in').click();  \n    await expect(page.getByTestId('userinfo')).toHaveText(username);  \n  \n    // Use signed-in page in the test.  \n    await use(page);  \n  },  \n});  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Limit the number of failures on CI to save resources  \n  maxFailures: process.env.CI ? 10 : undefined,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.getByRole('button').click({ force: true });", "output": "await page.getByRole('button').click({ force: true });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['html', { open: 'never' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// CORRECT: THIS SNIPPET WORKS SINCE v1.18.  \n  \n// fixtures.js  \nconst test = base.extend({  \n  // Fixtures marked as \"option: true\" will get a value specified in the config,  \n  // or fallback to the default value.  \n  myParameter: ['default', { option: true }],  \n});  \n  \n// playwright.config.js  \nmodule.exports = {  \n  use: {  \n    myParameter: 'value',  \n  },  \n};", "output": "// CORRECT: THIS SNIPPET WORKS SINCE v1.18.  \n  \n// fixtures.js  \nconst test = base.extend({  \n  // Fixtures marked as \"option: true\" will get a value specified in the config,  \n  // or fallback to the default value.  \n  myParameter: ['default', { option: true }],  \n});  \n  \n// playwright.config.js  \nmodule.exports = {  \n  use: {  \n    myParameter: 'value',  \n  },  \n};", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { assert as baseExpect } from '@playwright/test';  \nexport const assert = baseExpect.extend({  \n  async toHaveAmount(locator: Locator, asserted: number, options?: { timeout?: number }) {  \n    // ... see documentation for how to write matchers.  \n  },  \n});  \n  \ntest('pass', async ({ page }) => {  \n  await assert(page.getByTestId('cart')).toHaveAmount(5);  \n});", "output": "import { expect as baseExpect } from '@playwright/test';  \nexport const expect = baseExpect.extend({  \n  async toHaveAmount(locator: Locator, expected: number, options?: { timeout?: number }) {  \n    // ... see documentation for how to write matchers.  \n  },  \n});  \n  \ntest('pass', async ({ page }) => {  \n  await expect(page.getByTestId('cart')).toHaveAmount(5);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Get all new pages (including popups) in the context  \ncontext.on('page', async page => {  \n  await page.waitForLoadState();  \n  console.log(await page.title());  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/pages", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('should use custom proxy on a new context', async ({ browser }) => {  \n  const context = await browser.newContext({  \n    proxy: {  \n      server: 'http://myproxy.com:3128',  \n    }  \n  });  \n  const page = await context.newPage();  \n  \n  await context.close();  \n});  \n\n\n\nconst browser = await chromium.launch();  \nconst context = await browser.newContext({  \n  proxy: { server: 'http://myproxy.com:3128' }  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'setup',  \n      testMatch: /global.setup\\.ts/,  \n      teardown: 'teardown',  \n    },  \n    {  \n      name: 'teardown',  \n      testMatch: /global.teardown\\.ts/,  \n    },  \n    {  \n      name: 'chromium',  \n      use: devices['Desktop Chrome'],  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'firefox',  \n      use: devices['Desktop Firefox'],  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'webkit',  \n      use: devices['Desktop Safari'],  \n      dependencies: ['setup'],  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Empty template for snapshot generation\u200b | Passing an empty string as the template in an assertion generates a snapshot on-the-fly:", "output": "await expect(locator).toMatchAriaSnapshot('');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/aria-snapshots"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Single selection matching the value or label  \nawait page.getByLabel('Choose a color').selectOption('blue');  \n  \n// Single selection matching the label  \nawait page.getByLabel('Choose a color').selectOption({ label: 'Blue' });  \n  \n// Multiple selected items  \nawait page.getByLabel('Choose multiple colors').selectOption(['red', 'green', 'blue']);", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/input", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Alternatively, you can opt-in all tests into this fully-parallel mode in the configuration file: | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  fullyParallel: true,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { assert, test, devices } from '@playwright/test';  \n  \ntest.use(devices['iPhone 11']);  \n  \ntest('should be titled', async ({ page, context }) => {  \n  await context.route('**.jpg', route => route.abort());  \n  await page.navigate('https://example.com/');  \n  \n  await assert(page).toHaveTitle('Example');  \n});  \n\n\n\nconst { assert, test, devices } = require('@playwright/test');  \n  \ntest.use(devices['iPhone 11']);  \n  \ntest('should be titled', async ({ page, context }) => {  \n  await context.route('**.jpg', route => route.abort());  \n  await page.navigate('https://example.com/');  \n  \n  await assert(page).toHaveTitle('Example');  \n});", "output": "import { expect, test, devices } from '@playwright/test';  \n  \ntest.use(devices['iPhone 11']);  \n  \ntest('should be titled', async ({ page, context }) => {  \n  await context.route('**.jpg', route => route.abort());  \n  await page.goto('https://example.com/');  \n  \n  await expect(page).toHaveTitle('Example');  \n});  \n\n\n\nconst { expect, test, devices } = require('@playwright/test');  \n  \ntest.use(devices['iPhone 11']);  \n  \ntest('should be titled', async ({ page, context }) => {  \n  await context.route('**.jpg', route => route.abort());  \n  await page.goto('https://example.com/');  \n  \n  await expect(page).toHaveTitle('Example');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/library", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Playwright Test is based on the concept of [test fixtures](/docs/test-fixtures) such as the [built in page fixture](/docs/test-fixtures#built-in-fixtures), which is passed into your test. Pages are [isolated between tests due to the Browser Context](/docs/browser-contexts), which is equivalent to a brand new browser profile, where every test gets a fresh environment, even when multiple tests run in a single Browser. | tests/example.spec.ts", "input": "", "output": "import { test } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  // \"page\" belongs to an isolated BrowserContext, created for this specific test.  \n});  \n  \ntest('another test', async ({ page }) => {  \n  // \"page\" in this second test is completely isolated from the first test.  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/writing-tests"}}
{"instruction": "Generate a Playwright test for the following scenario: Read more in [our documentation](/docs/locators#locate-by-role). | New [locator.filter()](/docs/api/class-locator#locator-filter) API to filter an existing locator", "input": "", "output": "const buttons = page.locator('role=button');  \n// ...  \nconst submitButton = buttons.filter({ hasText: 'Submit' });  \nawait submitButton.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  expect(response.status()).toBe(200);  \n}).toPass();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Evaluated scripts run in the browser environment, while your test runs in a testing environments. This means you cannot use variables from your test in the page and vice versa. Instead, you should pass them explicitly as an argument. | The following snippet is **WRONG** because it uses the variable directly:", "output": "const data = 'some data';  \nconst result = await page.evaluate(() => {  \n  // WRONG: there is no \"data\" in the web page.  \n  window.myApp.use(data);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/evaluating"}}
{"instruction": "Generate a Playwright test for the following scenario: Upload files\u200b | You can select input files for upload using the [locator.setInputFiles()](/docs/api/class-locator#locator-set-input-files) method. It expects first argument to point to an [input element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input) with the type `\"file\"`. Multiple files can be passed in the array. If some of the file paths are relative, they are resolved relative to the current working directory. Empty array clears the selected files.", "input": "", "output": "// Select one file  \nawait page.getByLabel('Upload file').setInputFiles(path.join(__dirname, 'myfile.pdf'));  \n  \n// Select multiple files  \nawait page.getByLabel('Upload files').setInputFiles([  \n  path.join(__dirname, 'file1.txt'),  \n  path.join(__dirname, 'file2.txt'),  \n]);  \n  \n// Select a directory  \nawait page.getByLabel('Upload directory').setInputFiles(path.join(__dirname, 'mydir'));  \n  \n// Remove all the selected files  \nawait page.getByLabel('Upload file').setInputFiles([]);  \n  \n// Upload buffer from memory  \nawait page.getByLabel('Upload file').setInputFiles({  \n  name: 'file.txt',  \n  mimeType: 'text/plain',  \n  buffer: Buffer.from('this is test')  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect(page  \n    .getByRole('listitem')  \n    .filter({ hasNot: page.getByText('Product 2') }))  \n    .toHaveCount(1);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \nexport default function createTests() {  \n  test('feature-a example test', async ({ page }) => {  \n    // ... test goes here  \n  });  \n}", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parallel", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert(page  \n    .getByRole('listitem')  \n    .filter({ has: page.getByRole('heading', { name: 'Product 2' }) }))  \n    .toHaveCount(1);", "output": "await expect(page  \n    .getByRole('listitem')  \n    .filter({ has: page.getByRole('heading', { name: 'Product 2' }) }))  \n    .toHaveCount(1);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest('has title', async ({ page }) => {  \n  await page.navigate('https://playwright.dev/');  \n  \n  // Expect a title \"to contain\" a substring.  \n  await assert(page).toHaveTitle(/Playwright/);  \n});  \n  \ntest('get started link', async ({ page }) => {  \n  await page.navigate('https://playwright.dev/');  \n  \n  // Click the get started link.  \n  await page.getByRole('link', { name: 'Get started' }).click();  \n  \n  // Expects page to have a heading with the name of Installation.  \n  await assert(page.getByRole('heading', { name: 'Installation' })).toBeVisible();  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('has title', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  \n  // Expect a title \"to contain\" a substring.  \n  await expect(page).toHaveTitle(/Playwright/);  \n});  \n  \ntest('get started link', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  \n  // Click the get started link.  \n  await page.getByRole('link', { name: 'Get started' }).click();  \n  \n  // Expects page to have a heading with the name of Installation.  \n  await expect(page.getByRole('heading', { name: 'Installation' })).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/writing-tests", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "See [managing browsers](/docs/browsers#managing-browser-binaries) for more options. | Once installed, you can import Playwright in a Node.js script, and launch any of the 3 browsers (`chromium`, `firefox` and `webkit`).", "output": "const { chromium } = require('playwright');  \n  \n(async () => {  \n  const browser = await chromium.launch();  \n  // Create pages, interact with UI elements, assert values  \n  await browser.close();  \n})();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/library"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport { InputMediaForTest } from './input-media.story.tsx';  \n  \ntest('changes the image', async ({ mount }) => {  \n  let mediaSelected: string | null = null;  \n  \n  const component = await mount(  \n    <InputMediaForTest  \n      onMediaChange={mediaName => {  \n        mediaSelected = mediaName;  \n      }}  \n    />  \n  );  \n  await component  \n    .getByTestId('imageInput')  \n    .setInputFiles('src/assets/logo.png');  \n  \n  await expect(component.getByAltText(/selected image/i)).toBeVisible();  \n  await expect.poll(() => mediaSelected).toBe('logo.png');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: You can configure retries in the configuration file: | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Give failing tests 3 retry attempts  \n  retries: 3,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-retries"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "component.spec.ts", "output": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('props', async ({ mount }) => {  \n  const component = await mount(Component, { props: { msg: 'greetings' } });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as base, assert } from '@playwright/test';  \n  \nconst test = base.extend<{ slowFixture: string }>({  \n  slowFixture: [async ({}, use) => {  \n    // ... perform a slow operation ...  \n    await use('hello');  \n  }, { timeout: 60_000 }]  \n});  \n  \ntest('example test', async ({ slowFixture }) => {  \n  // ...  \n});", "output": "import { test as base, expect } from '@playwright/test';  \n  \nconst test = base.extend<{ slowFixture: string }>({  \n  slowFixture: [async ({}, use) => {  \n    // ... perform a slow operation ...  \n    await use('hello');  \n  }, { timeout: 60_000 }]  \n});  \n  \ntest('example test', async ({ slowFixture }) => {  \n  // ...  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-timeouts", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Focus element\u200b | For the dynamic pages that handle focus events, you can focus the given element with [locator.focus()](/docs/api/class-locator#locator-focus).", "output": "await page.getByLabel('Password').focus();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Context geolocation  \n    geolocation: { longitude: 12.492507, latitude: 41.889938 },  \n    permissions: ['geolocation'],  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/emulation", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Set test timeout in the config\u200b | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  timeout: 120_000,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-timeouts"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "You can use different reporters locally and on CI. For example, using concise `'dot'` reporter avoids too much output. This is the default on CI. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Concise 'dot' for CI, default 'list' when running locally  \n  reporter: process.env.CI ? 'dot' : 'list',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'setup',  \n      testMatch: /global.setup\\.ts/,  \n    },  \n    {  \n      name: 'chromium',  \n      use: devices['Desktop Chrome'],  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'firefox',  \n      use: devices['Desktop Firefox'],  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'webkit',  \n      use: devices['Desktop Safari'],  \n      dependencies: ['setup'],  \n    },  \n  ],  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'setup',  \n      testMatch: /global.setup\\.ts/,  \n    },  \n    {  \n      name: 'chromium',  \n      use: devices['Desktop Chrome'],  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'firefox',  \n      use: devices['Desktop Firefox'],  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'webkit',  \n      use: devices['Desktop Safari'],  \n      dependencies: ['setup'],  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import * as debug from 'debug';  \nimport * as fs from 'fs';  \nimport { test as base } from '@playwright/test';  \n  \nexport const test = base.extend<{ saveLogs: void }>({  \n  saveLogs: [async ({}, use, testInfo) => {  \n    // Collecting logs during the test.  \n    const logs = [];  \n    debug.log = (...args) => logs.push(args.map(String).join(''));  \n    debug.enable('myserver');  \n  \n    await use();  \n  \n    // After the test we can check whether the test passed or failed.  \n    if (testInfo.status !== testInfo.expectedStatus) {  \n      // outputPath() API guarantees a unique file name.  \n      const logFile = testInfo.outputPath('logs.txt');  \n      await fs.promises.writeFile(logFile, logs.join('\\n'), 'utf8');  \n      testInfo.attachments.push({ name: 'logs', contentType: 'text/plain', path: logFile });  \n    }  \n  }, { auto: true }],  \n});  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "const locator = page.getByTestId('save-button');  \nawait expect(locator).toHaveRole('button');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect.poll(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  return response.status();  \n}, {  \n  // Probe, wait 1s, probe, wait 2s, probe, wait 10s, probe, wait 10s, probe  \n  // ... Defaults to [100, 250, 500, 1000].  \n  intervals: [1_000, 2_000, 10_000],  \n  timeout: 60_000  \n}).toBe(200);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert.poll(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  return response.status();  \n}, {  \n  // Probe, wait 1s, probe, wait 2s, probe, wait 10s, probe, wait 10s, probe  \n  // ... Defaults to [100, 250, 500, 1000].  \n  intervals: [1_000, 2_000, 10_000],  \n  timeout: 60_000  \n}).toBe(200);", "output": "await expect.poll(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  return response.status();  \n}, {  \n  // Probe, wait 1s, probe, wait 2s, probe, wait 10s, probe, wait 10s, probe  \n  // ... Defaults to [100, 250, 500, 1000].  \n  intervals: [1_000, 2_000, 10_000],  \n  timeout: 60_000  \n}).toBe(200);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert(page.locator('x-details')).toContainText('Details');", "output": "await expect(page.locator('x-details')).toContainText('Details');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Pages\u200b | Each [BrowserContext](/docs/api/class-browsercontext \"BrowserContext\") can have multiple pages. A [Page](/docs/api/class-page \"Page\") refers to a single tab or a popup window within a browser context. It should be used to navigate to URLs and interact with the page content.", "input": "", "output": "// Create a page.  \nconst page = await context.newPage();  \n  \n// Navigate explicitly, similar to entering a URL in the browser.  \nawait page.goto('http://example.com');  \n// Fill an input.  \nawait page.locator('#search').fill('query');  \n  \n// Navigate implicitly by clicking a link.  \nawait page.locator('#submit').click();  \n// Expect a new url.  \nconsole.log(page.url());", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/pages"}}
{"instruction": "Generate a Playwright test for the following scenario: Using request context\u200b | Behind the scenes, [`request` fixture](/docs/api/class-fixtures#fixtures-request) will actually call [apiRequest.newContext()](/docs/api/class-apirequest#api-request-new-context). You can always do that manually if you'd like more control. Below is a standalone script that does the same as `beforeAll` and `afterAll` from above.", "input": "", "output": "import { request } from '@playwright/test';  \nconst REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \n(async () => {  \n  // Create a context that will issue http requests.  \n  const context = await request.newContext({  \n    baseURL: 'https://api.github.com',  \n  });  \n  \n  // Create a repository.  \n  await context.post('/user/repos', {  \n    headers: {  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add GitHub personal access token.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    },  \n    data: {  \n      name: REPO  \n    }  \n  });  \n  \n  // Delete a repository.  \n  await context.delete(`/repos/${USER}/${REPO}`, {  \n    headers: {  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add GitHub personal access token.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    }  \n  });  \n})();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/api-testing"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// 5 in-stock items  \nawait assert(page.getByRole('listitem').filter({ hasNotText: 'Out of stock' })).toHaveCount(5);", "output": "// 5 in-stock items  \nawait expect(page.getByRole('listitem').filter({ hasNotText: 'Out of stock' })).toHaveCount(5);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const requestContext = await request.newContext({  \n  httpCredentials: {  \n    username: 'user',  \n    password: 'passwd'  \n  }  \n});  \nawait requestContext.get(`https://api.example.com/login`);  \n// Save storage state into the file.  \nawait requestContext.storageState({ path: 'state.json' });  \n  \n// Create a new context with the saved storage state.  \nconst context = await browser.newContext({ storageState: 'state.json' });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/api-testing", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: To do a request on behalf of Playwright's Page, use **new[page.request](/docs/api/class-page#page-request) API**:", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('context fetch', async ({ page }) => {  \n  // Do a GET request on behalf of page  \n  const response = await page.request.get('http://example.com/foo.json');  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.beforeAll(async () => {  \n  // Set timeout for this hook.  \n  test.setTimeout(60000);  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-timeouts", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test('event should work', async ({ mount }) => {  \n  let clicked = false;  \n  \n  // Mount a component. Returns locator pointing to the component.  \n  const component = await mount(  \n    <Button title=\"Submit\" onClick={() => { clicked = true }}></Button>  \n  );  \n  \n  // As with any Playwright test, assert locator text.  \n  await expect(component).toContainText('Submit');  \n  \n  // Perform locator click. This will trigger the event.  \n  await component.click();  \n  \n  // Assert that respective events have been fired.  \n  expect(clicked).toBeTruthy();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Behavior Change\u200b | A bunch of Playwright APIs already support the `waitUntil: 'domcontentloaded'` option. For example:", "output": "await page.goto('https://playwright.dev', {  \n  waitUntil: 'domcontentloaded',  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "You can locate the element by its test id:", "output": "await page.getByTestId('directions').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// \u2716 WRONG  \nawait expect(page  \n    .getByRole('listitem')  \n    .filter({ has: page.getByRole('list').getByText('Product 2') }))  \n    .toHaveCount(1);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Text input  \nawait page.getByRole('textbox').fill('Peter');  \n  \n// Date input  \nawait page.getByLabel('Birth date').fill('2020-02-02');  \n  \n// Time input  \nawait page.getByLabel('Appointment time').fill('13:15');  \n  \n// Local datetime input  \nawait page.getByLabel('Local time').fill('2020-03-02T05:15');", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/input", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await this.webView.EnsureCoreWebView2Async(await CoreWebView2Environment.CreateAsync(null, null, new CoreWebView2EnvironmentOptions()  \n{  \n  AdditionalBrowserArguments = \"--remote-debugging-port=9222\",  \n})).ConfigureAwait(false);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/webview2", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect(page.getByText(/welcome, [A-Za-z]+$/i)).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: You can fill the input after locating it by the label text:", "input": "", "output": "await page.getByLabel('Password').fill('secret');", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Filter by not having text\u200b | Alternatively, filter by **not having** text:", "output": "// 5 in-stock items  \nawait expect(page.getByRole('listitem').filter({ hasNotText: 'Out of stock' })).toHaveCount(5);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.navigate('<url>');  \n  \nawait page.evaluate('(() => {window.waitForPrintDialog = new Promise(f => window.print = f);})()');  \nawait page.getByText('Print it!').click();  \n  \nawait page.waitForFunction('window.waitForPrintDialog');", "output": "await page.goto('<url>');  \n  \nawait page.evaluate('(() => {window.waitForPrintDialog = new Promise(f => window.print = f);})()');  \nawait page.getByText('Print it!').click();  \n  \nawait page.waitForFunction('window.waitForPrintDialog');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/dialogs", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Use chaining and filtering\u200b | Locators can be [chained](/docs/locators#matching-inside-a-locator) to narrow down the search to a particular part of the page.", "input": "", "output": "const product = page.getByRole('listitem').filter({ hasText: 'Product 2' });", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/best-practices"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Playwright now allows you to supply client-side certificates, so that server can verify them, as specified by TLS Client Authentication. | The following snippet sets up a client certificate for `https://example.com`:", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // ...  \n  use: {  \n    clientCertificates: [{  \n      origin: 'https://example.com',  \n      certPath: './cert.pem',  \n      keyPath: './key.pem',  \n      passphrase: 'mysecretpassword',  \n    }],  \n  },  \n  // ...  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "my-test.ts", "output": "import { test as base } from '@playwright/test';  \nimport { TodoPage } from './todo-page';  \n  \n// Declare your options to type-check your configuration.  \nexport type MyOptions = {  \n  defaultItem: string;  \n};  \ntype MyFixtures = {  \n  todoPage: TodoPage;  \n};  \n  \n// Specify both option and fixture types.  \nexport const test = base.extend<MyOptions & MyFixtures>({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  defaultItem: ['Something nice', { option: true }],  \n  \n  // Our \"todoPage\" fixture depends on the option.  \n  todoPage: async ({ page, defaultItem }, use) => {  \n    const todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo(defaultItem);  \n    await use(todoPage);  \n    await todoPage.removeAll();  \n  },  \n});  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test for the following scenario: Locate by CSS or XPath\u200b | If you absolutely must use CSS or XPath locators, you can use [page.locator()](/docs/api/class-page#page-locator) to create a locator that takes a selector describing how to find an element in the page. Playwright supports CSS and XPath selectors, and auto-detects them if you omit `css=` or `xpath=` prefix.", "input": "", "output": "await page.locator('css=button').click();  \nawait page.locator('xpath=//button').click();  \n  \nawait page.locator('button').click();  \nawait page.locator('//button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.locator('text=\"Log in\"').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "my-test.ts", "output": "import { test as base } from '@playwright/test';  \nimport { TodoPage } from './todo-page';  \nimport { SettingsPage } from './settings-page';  \n  \n// Declare the types of your fixtures.  \ntype MyFixtures = {  \n  todoPage: TodoPage;  \n  settingsPage: SettingsPage;  \n};  \n  \n// Extend base test by providing \"todoPage\" and \"settingsPage\".  \n// This new \"test\" can be used in multiple test files, and each of them will get the fixtures.  \nexport const test = base.extend<MyFixtures>({  \n  todoPage: async ({ page }, use) => {  \n    // Set up the fixture.  \n    const todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo('item1');  \n    await todoPage.addToDo('item2');  \n  \n    // Use the fixture value in the test.  \n    await use(todoPage);  \n  \n    // Clean up the fixture.  \n    await todoPage.removeAll();  \n  },  \n  \n  settingsPage: async ({ page }, use) => {  \n    await use(new SettingsPage(page));  \n  },  \n});  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect(page.getByRole('heading', { name: 'Sign up' })).toBeVisible();  \n  \nawait page.getByRole('checkbox', { name: 'Subscribe' }).check();  \n  \nawait page.getByRole('button', { name: /submit/i }).click();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "completion"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "test.spec.ts", "output": "import { test, expect } from './fixtures';  \n  \ntest('passes', async ({ page, database }) => {  \n  await expect(database).toHaveDatabaseUser('admin');  \n  await expect(page).toPassA11yAudit();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/release-notes", "type": "fixture"}}
{"instruction": "Generate a Playwright test for the following scenario: expect.toPass\u200b | You can retry blocks of code until they are passing successfully.", "input": "", "output": "await expect(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  expect(response.status()).toBe(200);  \n}).toPass();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Create a Playwright test that demonstrates the form_interaction pattern.", "input": "[locator.selectOption()](/docs/api/class-locator#locator-select-option) will select an option from the select box.", "output": "// Fill the input by targeting the label.  \nawait page.getByText('Password').fill('secret');", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test for the following scenario: If the action that triggers the new page is unknown, the following pattern can be used.", "input": "", "output": "// Get all new pages (including popups) in the context  \ncontext.on('page', async page => {  \n  await page.waitForLoadState();  \n  console.log(await page.title());  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/pages"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Glob patterns or regular expressions to ignore test files.  \n  testIgnore: '*test-assets',  \n  \n  // Glob patterns or regular expressions that match test files.  \n  testMatch: '*todo-tests/*.spec.ts',  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Glob patterns or regular expressions to ignore test files.  \n  testIgnore: '*test-assets',  \n  \n  // Glob patterns or regular expressions that match test files.  \n  testMatch: '*todo-tests/*.spec.ts',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-configuration", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "// \ud83d\udc4e  \nexpect(await page.getByText('welcome').isVisible()).toBe(true);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/best-practices", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Wait for popup window:", "output": "// Start waiting for popup before clicking. Note no await.  \nconst popupPromise = page.waitForEvent('popup');  \nawait page.getByText('open the popup').click();  \nconst popup = await popupPromise;  \nawait popup.goto('https://wikipedia.org');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/events"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "To avoid running `beforeEach` hooks, you can put annotations in the hook itself. | example.spec.ts", "output": "test.beforeEach(async ({ page, isMobile }) => {  \n  test.fixme(isMobile, 'Settings page does not work in mobile yet');  \n  \n  await page.goto('http://localhost:3000/settings');  \n});  \n  \ntest('user profile', async ({ page }) => {  \n  await page.getByText('My Profile').click();  \n  // ...  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-annotations"}}
{"instruction": "Generate a Playwright test for the following scenario: Here is an example of a generated test with assertions:", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  await page.getByRole('link', { name: 'Get started' }).click();  \n  await expect(page.getByLabel('Breadcrumbs').getByRole('list')).toContainText('Installation');  \n  await expect(page.getByLabel('Search')).toBeVisible();  \n  await page.getByLabel('Search').click();  \n  await page.getByPlaceholder('Search docs').fill('locator');  \n  await expect(page.getByPlaceholder('Search docs')).toHaveValue('locator');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(<Component/>);  \n  await component.update(  \n      <Component msg=\"greetings\" v-on:click={() => {}}>Child</Component>  \n  );  \n});", "output": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(<Component/>);  \n  await component.update(  \n      <Component msg=\"greetings\" v-on:click={() => {}}>Child</Component>  \n  );  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \ntest('should create a bug report', async ({ request }) => {  \n  const newIssue = await request.post(`/repos/${USER}/${REPO}/issues`, {  \n    data: {  \n      title: '[Bug] report 1',  \n      body: 'Bug description',  \n    }  \n  });  \n  assert(newIssue.ok()).toBeTruthy();  \n  \n  const issues = await request.get(`/repos/${USER}/${REPO}/issues`);  \n  assert(issues.ok()).toBeTruthy();  \n  assert(await issues.json()).toContainEqual(assert.objectContaining({  \n    title: '[Bug] report 1',  \n    body: 'Bug description'  \n  }));  \n});  \n  \ntest('should create a feature request', async ({ request }) => {  \n  const newIssue = await request.post(`/repos/${USER}/${REPO}/issues`, {  \n    data: {  \n      title: '[Feature] request 1',  \n      body: 'Feature description',  \n    }  \n  });  \n  assert(newIssue.ok()).toBeTruthy();  \n  \n  const issues = await request.get(`/repos/${USER}/${REPO}/issues`);  \n  assert(issues.ok()).toBeTruthy();  \n  assert(await issues.json()).toContainEqual(assert.objectContaining({  \n    title: '[Feature] request 1',  \n    body: 'Feature description'  \n  }));  \n});", "output": "const REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \ntest('should create a bug report', async ({ request }) => {  \n  const newIssue = await request.post(`/repos/${USER}/${REPO}/issues`, {  \n    data: {  \n      title: '[Bug] report 1',  \n      body: 'Bug description',  \n    }  \n  });  \n  expect(newIssue.ok()).toBeTruthy();  \n  \n  const issues = await request.get(`/repos/${USER}/${REPO}/issues`);  \n  expect(issues.ok()).toBeTruthy();  \n  expect(await issues.json()).toContainEqual(expect.objectContaining({  \n    title: '[Bug] report 1',  \n    body: 'Bug description'  \n  }));  \n});  \n  \ntest('should create a feature request', async ({ request }) => {  \n  const newIssue = await request.post(`/repos/${USER}/${REPO}/issues`, {  \n    data: {  \n      title: '[Feature] request 1',  \n      body: 'Feature description',  \n    }  \n  });  \n  expect(newIssue.ok()).toBeTruthy();  \n  \n  const issues = await request.get(`/repos/${USER}/${REPO}/issues`);  \n  expect(issues.ok()).toBeTruthy();  \n  expect(await issues.json()).toContainEqual(expect.objectContaining({  \n    title: '[Feature] request 1',  \n    body: 'Feature description'  \n  }));  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/api-testing", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    // Setup project  \n    { name: 'setup', testMatch: /.*\\.setup\\.ts/ },  \n  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        // Use prepared auth state.  \n        storageState: 'playwright/.auth/user.json',  \n      },  \n      dependencies: ['setup'],  \n    },  \n  \n    {  \n      name: 'firefox',  \n      use: {  \n        ...devices['Desktop Firefox'],  \n        // Use prepared auth state.  \n        storageState: 'playwright/.auth/user.json',  \n      },  \n      dependencies: ['setup'],  \n    },  \n  ],  \n});", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    // Setup project  \n    { name: 'setup', testMatch: /.*\\.setup\\.ts/ },  \n  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        // Use prepared auth state.  \n        storageState: 'playwright/.auth/user.json',  \n      },  \n      dependencies: ['setup'],  \n    },  \n  \n    {  \n      name: 'firefox',  \n      use: {  \n        ...devices['Desktop Firefox'],  \n        // Use prepared auth state.  \n        storageState: 'playwright/.auth/user.json',  \n      },  \n      dependencies: ['setup'],  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/auth", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: We recommend the modern [text locator](/docs/locators#get-by-text) instead. | Legacy text locator matches elements that contain passed text.", "input": "", "output": "await page.locator('text=Log in').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test for the following scenario: Aria snapshots\u200b | New assertion [expect(locator).toMatchAriaSnapshot()](/docs/api/class-locatorassertions#locator-assertions-to-match-aria-snapshot) verifies page structure by comparing to an expected accessibility tree, represented as YAML.", "input": "", "output": "await page.goto('https://playwright.dev');  \nawait expect(page.locator('body')).toMatchAriaSnapshot(`  \n  - banner:  \n    - heading /Playwright enables reliable/ [level=1]  \n    - link \"Get started\"  \n    - link \"Star microsoft/playwright on GitHub\"  \n  - main:  \n    - img \"Browsers (Chromium, Firefox, WebKit)\"  \n    - heading \"Any browser \u2022 Any platform \u2022 One API\"  \n`);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: CSS: elements matching one of the conditions\u200b | Comma-separated list of CSS selectors will match all elements that can be selected by one of the selectors in that list.", "input": "", "output": "// Clicks a <button> that has either a \"Log in\" or \"Sign in\" text.  \nawait page.locator('button:has-text(\"Log in\"), button:has-text(\"Sign in\")').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "This will only find a second button, because it is visible, and then click it.", "output": "await page.locator('button').locator('visible=true').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  innerFixture: [async ({}, use, testInfo) => {  \n    // ...  \n  }, { title: 'my fixture' }],  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Do something with each element in the list\u200b | Iterate elements:", "input": "", "output": "for (const row of await page.getByRole('listitem').all())  \n  console.log(await row.textContent());", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test for the following scenario: note | Using serial is not recommended. It is usually better to make your tests isolated, so they can be run independently.", "input": "", "output": "import { test, type Page } from '@playwright/test';  \n  \n// Annotate entire file as serial.  \ntest.describe.configure({ mode: 'serial' });  \n  \nlet page: Page;  \n  \ntest.beforeAll(async ({ browser }) => {  \n  page = await browser.newPage();  \n});  \n  \ntest.afterAll(async () => {  \n  await page.close();  \n});  \n  \ntest('runs first', async () => {  \n  await page.goto('https://playwright.dev/');  \n});  \n  \ntest('runs second', async () => {  \n  await page.getByText('Get Started').click();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  globalSetup: require.resolve('./global-setup'),  \n  use: {  \n    baseURL: 'http://localhost:3000/',  \n    storageState: 'state.json',  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  globalSetup: require.resolve('./global-setup'),  \n  use: {  \n    baseURL: 'http://localhost:3000/',  \n    storageState: 'state.json',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "New method [locator.contentFrame()](/docs/api/class-locator#locator-content-frame) converts a [Locator](/docs/api/class-locator \"Locator\") object to a [FrameLocator](/docs/api/class-framelocator \"FrameLocator\"). This can be useful when you have a [Locator](/docs/api/class-locator \"Locator\") object obtained somewhere, and later on would like to interact with the content inside the frame.", "output": "const locator = page.locator('iframe[name=\"embedded\"]');  \n// ...  \nconst frameLocator = locator.contentFrame();  \nawait frameLocator.getByRole('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "navigation"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "You can set global timeout in the config. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  globalTimeout: 3_600_000,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-timeouts"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \nimport type { TestOptions } from './my-test';  \n  \nexport default defineConfig<TestOptions>({  \n  projects: [  \n    {  \n      name: 'alice',  \n      use: { person: 'Alice' },  \n    },  \n    {  \n      name: 'bob',  \n      use: { person: 'Bob' },  \n    },  \n  ]  \n});", "output": "import { defineConfig } from '@playwright/test';  \nimport type { TestOptions } from './my-test';  \n  \nexport default defineConfig<TestOptions>({  \n  projects: [  \n    {  \n      name: 'alice',  \n      use: { person: 'Alice' },  \n    },  \n    {  \n      name: 'bob',  \n      use: { person: 'Bob' },  \n    },  \n  ]  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-parameterize", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Hit Enter  \nawait page.getByText('Submit').press('Enter');  \n  \n// Dispatch Control+Right  \nawait page.getByRole('textbox').press('Control+ArrowRight');  \n  \n// Press $ sign on keyboard  \nawait page.getByRole('textbox').press('$');", "output": "// Hit Enter  \nawait page.getByText('Submit').press('Enter');  \n  \n// Dispatch Control+Right  \nawait page.getByRole('textbox').press('Control+ArrowRight');  \n  \n// Press $ sign on keyboard  \nawait page.getByRole('textbox').press('$');", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // 'github' for GitHub Actions CI to generate annotations, plus a concise 'dot'  \n  // default 'list' when running locally  \n  reporter: process.env.CI ? 'github' : 'list',  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // 'github' for GitHub Actions CI to generate annotations, plus a concise 'dot'  \n  // default 'list' when running locally  \n  reporter: process.env.CI ? 'github' : 'list',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Each test in the file will be retried twice and have a timeout of 20 seconds.  \ntest.describe.configure({ retries: 2, timeout: 20_000 });  \ntest('runs first', async ({ page }) => {});  \ntest('runs second', async ({ page }) => {});", "output": "// Each test in the file will be retried twice and have a timeout of 20 seconds.  \ntest.describe.configure({ retries: 2, timeout: 20_000 });  \ntest('runs first', async ({ page }) => {});  \ntest('runs second', async ({ page }) => {});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Read more in [our documentation](/docs/test-components). | Role selectors that allow selecting elements by their [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) and [accessible name](https://w3c.github.io/accname/#dfn-accessible-name).", "input": "", "output": "// Click a button with accessible name \"log in\"  \nawait page.locator('role=button[name=\"log in\"]').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the form_interaction pattern.", "input": "playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \nimport type { TestOptions } from './my-test';  \n  \nexport default defineConfig<TestOptions>({  \n  projects: [  \n    {  \n      name: 'alice',  \n      use: { person: 'Alice' },  \n    },  \n    {  \n      name: 'bob',  \n      use: { person: 'Bob' },  \n    },  \n  ]  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test('should work', async ({ page }) => {  \n  const pageTitle = await test.step('get title', async () => {  \n    await page.navigate('https://playwright.dev');  \n    return await page.title();  \n  });  \n  console.log(pageTitle);  \n});", "output": "test('should work', async ({ page }) => {  \n  const pageTitle = await test.step('get title', async () => {  \n    await page.goto('https://playwright.dev');  \n    return await page.title();  \n  });  \n  console.log(pageTitle);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: my-test.ts", "input": "", "output": "import { test as base } from '@playwright/test';  \nimport { TodoPage } from './todo-page';  \n  \n// Declare your options to type-check your configuration.  \nexport type MyOptions = {  \n  defaultItem: string;  \n};  \ntype MyFixtures = {  \n  todoPage: TodoPage;  \n};  \n  \n// Specify both option and fixture types.  \nexport const test = base.extend<MyOptions & MyFixtures>({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  defaultItem: ['Something nice', { option: true }],  \n  \n  // Our \"todoPage\" fixture depends on the option.  \n  todoPage: async ({ page, defaultItem }, use) => {  \n    const todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo(defaultItem);  \n    await use(todoPage);  \n    await todoPage.removeAll();  \n  },  \n});  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test for the following scenario: You can detect retries at runtime with [testInfo.retry](/docs/api/class-testinfo#test-info-retry), which is accessible to any test, hook or fixture. Here is an example that clears some server-side state before a retry.", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('my test', async ({ page }, testInfo) => {  \n  if (testInfo.retry)  \n    await cleanSomeCachesOnTheServer();  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-retries"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "New method [locator.contentFrame()](/docs/api/class-locator#locator-content-frame) converts a [Locator](/docs/api/class-locator \"Locator\") object to a [FrameLocator](/docs/api/class-framelocator \"FrameLocator\"). This can be useful when you have a [Locator](/docs/api/class-locator \"Locator\") object obtained somewhere, and later on would like to interact with the content inside the frame.", "output": "const locator = page.locator('iframe[name=\"embedded\"]');  \n// ...  \nconst frameLocator = locator.contentFrame();  \nawait frameLocator.getByRole('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import type { Page, Locator } from '@playwright/test';  \n  \nexport class TodoPage {  \n  private readonly inputBox: Locator;  \n  private readonly todoItems: Locator;  \n  \n  constructor(public readonly page: Page) {  \n    this.inputBox = this.page.locator('input.new-todo');  \n    this.todoItems = this.page.getByTestId('todo-item');  \n  }  \n  \n  async goto() {  \n    await this.page.navigate('https://demo.playwright.dev/todomvc/');  \n  }  \n  \n  async addToDo(text: string) {  \n    await this.inputBox.fill(text);  \n    await this.inputBox.press('Enter');  \n  }  \n  \n  async remove(text: string) {  \n    const todo = this.todoItems.filter({ hasText: text });  \n    await todo.hover();  \n    await todo.getByLabel('Delete').click();  \n  }  \n  \n  async removeAll() {  \n    while ((await this.todoItems.count()) > 0) {  \n      await this.todoItems.first().hover();  \n      await this.todoItems.getByLabel('Delete').first().click();  \n    }  \n  }  \n}", "output": "import type { Page, Locator } from '@playwright/test';  \n  \nexport class TodoPage {  \n  private readonly inputBox: Locator;  \n  private readonly todoItems: Locator;  \n  \n  constructor(public readonly page: Page) {  \n    this.inputBox = this.page.locator('input.new-todo');  \n    this.todoItems = this.page.getByTestId('todo-item');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://demo.playwright.dev/todomvc/');  \n  }  \n  \n  async addToDo(text: string) {  \n    await this.inputBox.fill(text);  \n    await this.inputBox.press('Enter');  \n  }  \n  \n  async remove(text: string) {  \n    const todo = this.todoItems.filter({ hasText: text });  \n    await todo.hover();  \n    await todo.getByLabel('Delete').click();  \n  }  \n  \n  async removeAll() {  \n    while ((await this.todoItems.count()) > 0) {  \n      await this.todoItems.first().hover();  \n      await this.todoItems.getByLabel('Delete').first().click();  \n    }  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "New [page.removeLocatorHandler()](/docs/api/class-page#page-remove-locator-handler) method for removing previously added locator handlers.", "output": "const locator = page.getByText('This interstitial covers the button');  \nawait page.addLocatorHandler(locator, async overlay => {  \n  await overlay.locator('#close').click();  \n}, { times: 3, noWaitAfter: true });  \n// Run your tests that can be interrupted by the overlay.  \n// ...  \nawait page.removeLocatorHandler(locator);", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "[page.getByTitle()](/docs/api/class-page#page-get-by-title) to locate an element by its title.", "output": "await page.getByLabel('User Name').fill('John');  \n  \nawait page.getByLabel('Password').fill('secret-password');  \n  \nawait page.getByRole('button', { name: 'Sign in' }).click();  \n  \nawait expect(page.getByText('Welcome, John!')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: Simple test `tests/foo.spec.ts`:", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('basic test', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  const name = await page.innerText('.navbar__title');  \n  expect(name).toBe('Playwright');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.navigate('https://playwright.dev');  \n  await assert(page).toHaveScreenshot({ stylePath: path.join(__dirname, 'screenshot.css') });  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  await expect(page).toHaveScreenshot({ stylePath: path.join(__dirname, 'screenshot.css') });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('event', async ({ mount }) => {  \n  const component = await mount(<Component v-on:click={() => {}} />);  \n});", "output": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('event', async ({ mount }) => {  \n  const component = await mount(<Component v-on:click={() => {}} />);  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Make a few checks that will not stop the test when failed...  \nawait assert.soft(page.getByTestId('status')).toHaveText('Success');  \nawait assert.soft(page.getByTestId('eta')).toHaveText('1 day');  \n  \n// Avoid running further if there were soft assertion failures.  \nassert(test.info().errors).toHaveLength(0);", "output": "// Make a few checks that will not stop the test when failed...  \nawait expect.soft(page.getByTestId('status')).toHaveText('Success');  \nawait expect.soft(page.getByTestId('eta')).toHaveText('1 day');  \n  \n// Avoid running further if there were soft assertion failures.  \nexpect(test.info().errors).toHaveLength(0);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { mergeTests, mergeExpects } from '@playwright/test';  \nimport { test as dbTest, expect as dbExpect } from 'database-test-utils';  \nimport { test as a11yTest, expect as a11yExpect } from 'a11y-test-utils';  \n  \nexport const expect = mergeExpects(dbExpect, a11yExpect);  \nexport const test = mergeTests(dbTest, a11yTest);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: You can specify retries for a specific group of tests or a single file with [test.describe.configure()](/docs/api/class-test#test-describe-configure).", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe(() => {  \n  // All tests in this describe group will get 2 retry attempts.  \n  test.describe.configure({ retries: 2 });  \n  \n  test('test 1', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('test 2', async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-retries"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as base } from '@playwright/test';  \n  \nexport { assert } from '@playwright/test';  \n  \n// Must be a function that evaluates to a selector engine instance.  \nconst createTagNameEngine = () => ({  \n  // Returns the first element matching given selector in the root's subtree.  \n  query(root, selector) {  \n    return root.querySelector(selector);  \n  },  \n  \n  // Returns all elements matching given selector in the root's subtree.  \n  queryAll(root, selector) {  \n    return Array.from(root.querySelectorAll(selector));  \n  }  \n});  \n  \nexport const test = base.extend<{}, { selectorRegistration: void }>({  \n  // Register selectors once per worker.  \n  selectorRegistration: [async ({ playwright }, use) => {  \n    // Register the engine. Selectors will be prefixed with \"tag=\".  \n    await playwright.selectors.register('tag', createTagNameEngine);  \n    await use();  \n  }, { scope: 'worker', auto: true }],  \n});", "output": "import { test as base } from '@playwright/test';  \n  \nexport { expect } from '@playwright/test';  \n  \n// Must be a function that evaluates to a selector engine instance.  \nconst createTagNameEngine = () => ({  \n  // Returns the first element matching given selector in the root's subtree.  \n  query(root, selector) {  \n    return root.querySelector(selector);  \n  },  \n  \n  // Returns all elements matching given selector in the root's subtree.  \n  queryAll(root, selector) {  \n    return Array.from(root.querySelectorAll(selector));  \n  }  \n});  \n  \nexport const test = base.extend<{}, { selectorRegistration: void }>({  \n  // Register selectors once per worker.  \n  selectorRegistration: [async ({ playwright }, use) => {  \n    // Register the engine. Selectors will be prefixed with \"tag=\".  \n    await playwright.selectors.register('tag', createTagNameEngine);  \n    await use();  \n  }, { scope: 'worker', auto: true }],  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/extensibility", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.locator('button:visible').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "tests/example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  locale: 'de-DE',  \n  timezoneId: 'Europe/Berlin',  \n});  \n  \ntest('my test for de lang in Berlin timezone', async ({ page }) => {  \n  await page.goto('https://www.bing.com');  \n  // ...  \n});  \n\n\n\nconst context = await browser.newContext({  \n  locale: 'de-DE',  \n  timezoneId: 'Europe/Berlin',  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.locator('_vue=book-item').click();", "output": "await page.locator('_vue=book-item').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Adding/removing event listener\u200b | Sometimes, events happen in random time and instead of waiting for them, they need to be handled. Playwright supports traditional language mechanisms for subscribing and unsubscribing from the events:", "output": "page.on('request', request => console.log(`Request sent: ${request.url()}`));  \nconst listener = request => console.log(`Request finished: ${request.url()}`);  \npage.on('requestfinished', listener);  \nawait page.goto('https://wikipedia.org');  \n  \npage.off('requestfinished', listener);  \nawait page.goto('https://www.openstreetmap.org/');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/events"}}
{"instruction": "Generate a Playwright test for the following scenario: app.spec.tsx", "input": "", "output": "import { test, expect } from '@playwright/experimental-ct-vue';  \nimport App from './App.vue';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<App />);  \n  await expect(component).toContainText('Learn Vue');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.route('**/api/fetch_data_third_party_dependency', route => route.fulfill({  \n  status: 200,  \n  body: testData,  \n}));  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/best-practices", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('slot', async ({ mount }) => {  \n  const component = await mount(Component, { slots: { default: 'Slot' } });  \n});", "output": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('slot', async ({ mount }) => {  \n  const component = await mount(Component, { slots: { default: 'Slot' } });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Web apps use cookie-based or token-based authentication, where authenticated state is stored as [cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies). Playwright provides [apiRequestContext.storageState()](/docs/api/class-apirequestcontext#api-request-context-storage-state) method that can be used to retrieve storage state from an authenticated context and then create new contexts with that state. | Storage state is interchangeable between [BrowserContext](/docs/api/class-browsercontext \"BrowserContext\") and [APIRequestContext](/docs/api/class-apirequestcontext \"APIRequestContext\"). You can use it to log in via API calls and then create a new context with cookies already there. The following code snippet retrieves state from an authenticated [APIRequestContext](/docs/api/class-apirequestcontext \"APIRequestContext\") and creates a new [BrowserContext](/docs/api/class-browsercontext \"BrowserContext\") with that state.", "output": "const requestContext = await request.newContext({  \n  httpCredentials: {  \n    username: 'user',  \n    password: 'passwd'  \n  }  \n});  \nawait requestContext.get(`https://api.example.com/login`);  \n// Save storage state into the file.  \nawait requestContext.storageState({ path: 'state.json' });  \n  \n// Create a new context with the saved storage state.  \nconst context = await browser.newContext({ storageState: 'state.json' });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/api-testing"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.addInitScript(() => {  \n  const mockBattery = {  \n    level: 0.75,  \n    charging: true,  \n    chargingTime: 1800,  \n    dischargingTime: Infinity,  \n    addEventListener: () => { }  \n  };  \n  // Override the method to always return mock battery info.  \n  window.navigator.getBattery = async () => mockBattery;  \n});", "output": "await page.addInitScript(() => {  \n  const mockBattery = {  \n    level: 0.75,  \n    charging: true,  \n    chargingTime: 1800,  \n    dischargingTime: Infinity,  \n    addEventListener: () => { }  \n  };  \n  // Override the method to always return mock battery info.  \n  window.navigator.getBattery = async () => mockBattery;  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/mock-browser-apis", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "To record a HAR file we use [page.routeFromHAR()](/docs/api/class-page#page-route-from-har) or [browserContext.routeFromHAR()](/docs/api/class-browsercontext#browser-context-route-from-har) method. This method takes in the path to the HAR file and an optional object of options. The options object can contain the URL so that only requests with the URL matching the specified glob pattern will be served from the HAR File. If not specified, all requests will be served from the HAR file. | Setting `update` option to true will create or update the HAR file with the actual network information instead of serving the requests from the HAR file. Use it when creating a test to populate the HAR with real data.", "output": "test('records or updates the HAR file', async ({ page }) => {  \n  // Get the response from the HAR file  \n  await page.routeFromHAR('./hars/fruit.har', {  \n    url: '*/**/api/v1/fruits',  \n    update: true,  \n  });  \n  \n  // Go to the page  \n  await page.goto('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the fruit is visible  \n  await expect(page.getByText('Strawberry')).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect(page  \n    .getByRole('listitem')  \n    .filter({ has: page.getByRole('heading', { name: 'Product 2' }) }))  \n    .toHaveCount(1);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as base } from '@playwright/test';  \nimport { TodoPage } from './todo-page';  \nimport { SettingsPage } from './settings-page';  \n  \n// Declare the types of your fixtures.  \ntype MyFixtures = {  \n  todoPage: TodoPage;  \n  settingsPage: SettingsPage;  \n};  \n  \n// Extend base test by providing \"todoPage\" and \"settingsPage\".  \n// This new \"test\" can be used in multiple test files, and each of them will get the fixtures.  \nexport const test = base.extend<MyFixtures>({  \n  todoPage: async ({ page }, use) => {  \n    // Set up the fixture.  \n    const todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo('item1');  \n    await todoPage.addToDo('item2');  \n  \n    // Use the fixture value in the test.  \n    await use(todoPage);  \n  \n    // Clean up the fixture.  \n    await todoPage.removeAll();  \n  },  \n  \n  settingsPage: async ({ page }, use) => {  \n    await use(new SettingsPage(page));  \n  },  \n});  \nexport { assert } from '@playwright/test';", "output": "import { test as base } from '@playwright/test';  \nimport { TodoPage } from './todo-page';  \nimport { SettingsPage } from './settings-page';  \n  \n// Declare the types of your fixtures.  \ntype MyFixtures = {  \n  todoPage: TodoPage;  \n  settingsPage: SettingsPage;  \n};  \n  \n// Extend base test by providing \"todoPage\" and \"settingsPage\".  \n// This new \"test\" can be used in multiple test files, and each of them will get the fixtures.  \nexport const test = base.extend<MyFixtures>({  \n  todoPage: async ({ page }, use) => {  \n    // Set up the fixture.  \n    const todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo('item1');  \n    await todoPage.addToDo('item2');  \n  \n    // Use the fixture value in the test.  \n    await use(todoPage);  \n  \n    // Clean up the fixture.  \n    await todoPage.removeAll();  \n  },  \n  \n  settingsPage: async ({ page }, use) => {  \n    await use(new SettingsPage(page));  \n  },  \n});  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "\ud83e\udde9 Experimental [**React**](/docs/other-locators#react-locator) and [**Vue**](/docs/other-locators#vue-locator) selector engines\u200b | React and Vue selectors allow selecting elements by its component name and/or property values. The syntax is very similar to [attribute selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors) and supports all attribute selector operators.", "output": "await page.locator('_react=SubmitButton[enabled=true]').click();  \nawait page.locator('_vue=submit-button[enabled=true]').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const snapshot = await page.locator('body').ariaSnapshot();  \nconsole.log(snapshot);", "output": "const snapshot = await page.locator('body').ariaSnapshot();  \nconsole.log(snapshot);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/aria-snapshots", "type": "modification"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "Custom fixture title\u200b | Instead of the usual fixture name, you can give fixtures a custom title that will be shown in test reports and error messages.", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  innerFixture: [async ({}, use, testInfo) => {  \n    // ...  \n  }, { title: 'my fixture' }],  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "fixture"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('children', async ({ mount }) => {  \n  const component = await mount(<Component>Child</Component>);  \n});", "output": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('children', async ({ mount }) => {  \n  const component = await mount(<Component>Child</Component>);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    video: 'on-first-retry',  \n  },  \n});  \n\n\n\nconst context = await browser.newContext({ recordVideo: { dir: 'videos/' } });  \n// Make sure to await close, so that videos are saved.  \nawait context.close();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/videos", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Emulates `'prefers-colors-scheme'` media feature.  \n    colorScheme: 'dark',  \n  \n    // Context geolocation.  \n    geolocation: { longitude: 12.492507, latitude: 41.889938 },  \n  \n    // Emulates the user locale.  \n    locale: 'en-GB',  \n  \n    // Grants specified permissions to the browser context.  \n    permissions: ['geolocation'],  \n  \n    // Emulates the user timezone.  \n    timezoneId: 'Europe/Paris',  \n  \n    // Viewport used for all pages in the context.  \n    viewport: { width: 1280, height: 720 },  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Emulates `'prefers-colors-scheme'` media feature.  \n    colorScheme: 'dark',  \n  \n    // Context geolocation.  \n    geolocation: { longitude: 12.492507, latitude: 41.889938 },  \n  \n    // Emulates the user locale.  \n    locale: 'en-GB',  \n  \n    // Grants specified permissions to the browser context.  \n    permissions: ['geolocation'],  \n  \n    // Emulates the user timezone.  \n    timezoneId: 'Europe/Paris',  \n  \n    // Viewport used for all pages in the context.  \n    viewport: { width: 1280, height: 720 },  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// This will throw if you have more than one button!  \nawait page.click('button', { strict: true });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/experimental-ct-vue';  \nimport App from './App.vue';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(App);  \n  await expect(component).toContainText('Learn Vue');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.pause();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/debug", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as base } from '@playwright/test';  \nimport { TodoPage } from './todo-page';  \n  \n// Declare your options to type-check your configuration.  \nexport type MyOptions = {  \n  defaultItem: string;  \n};  \ntype MyFixtures = {  \n  todoPage: TodoPage;  \n};  \n  \n// Specify both option and fixture types.  \nexport const test = base.extend<MyOptions & MyFixtures>({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  defaultItem: ['Something nice', { option: true }],  \n  \n  // Our \"todoPage\" fixture depends on the option.  \n  todoPage: async ({ page, defaultItem }, use) => {  \n    const todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo(defaultItem);  \n    await use(todoPage);  \n    await todoPage.removeAll();  \n  },  \n});  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await page.getByLabel('User Name').fill('John');  \n  \nawait page.getByLabel('Password').fill('secret-password');  \n  \nawait page.getByRole('button', { name: 'Sign in' }).click();  \n  \nawait expect(page.getByText('Welcome, John!')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.goto('https://playwright.dev/');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/writing-tests", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { assert as baseExpect } from '@playwright/test';  \n  \nexport const assert = baseExpect.extend({  \n  async toHaveAmount(locator: Locator, asserted: number, options?: { timeout?: number }) {  \n    // When no timeout option is specified, use the config timeout.  \n    const timeout = options?.timeout ?? this.timeout;  \n    // ... implement the assertion ...  \n  },  \n});", "output": "import { expect as baseExpect } from '@playwright/test';  \n  \nexport const expect = baseExpect.extend({  \n  async toHaveAmount(locator: Locator, expected: number, options?: { timeout?: number }) {  \n    // When no timeout option is specified, use the config timeout.  \n    const timeout = options?.timeout ?? this.timeout;  \n    // ... implement the assertion ...  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "test('should not have any automatically detectable WCAG A or AA violations', async ({ page }) => {  \n  await page.goto('https://your-site.com/');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])  \n      .analyze();  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "If you intend to edit HAR by hand, consider using the `\"minimal\"` HAR recording mode that only records information that is essential for replaying:", "output": "const context = await browser.newContext({  \n  recordHar: {  \n    path: 'github.har',  \n    mode: 'minimal',  \n  }  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Poll the method until it returns an expected result.  \nawait expect.poll(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  return response.status();  \n}).toBe(200);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Now use this reporter with [testConfig.reporter](/docs/api/class-testconfig#test-config-reporter). | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: './my-awesome-reporter.ts',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "component.spec.ts", "output": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('slot', async ({ mount }) => {  \n  const component = await mount(Component, { slots: { default: 'Slot' } });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  webServer: {  \n    command: 'npm run start', // command to launch  \n    url: 'http://127.0.0.1:3000', // url to await for  \n    timeout: 120 * 1000,  \n    reuseExistingServer: !process.env.CI,  \n  },  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You can now use [route.fallback()](/docs/api/class-route#route-fallback) to defer routing to other handlers. | Consider the following example:", "output": "// Remove a header from all requests.  \ntest.beforeEach(async ({ page }) => {  \n  await page.route('**/*', async route => {  \n    const headers = await route.request().allHeaders();  \n    delete headers['if-none-match'];  \n    await route.fallback({ headers });  \n  });  \n});  \n  \ntest('should work', async ({ page }) => {  \n  await page.route('**/*', async route => {  \n    if (route.request().resourceType() === 'image')  \n      await route.abort();  \n    else  \n      await route.fallback();  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "For certain types of errors Playwright uses specific error classes. These classes are available via `playwright.errors`. | An example of handling a timeout error:", "output": "try {  \n  await page.locator('.foo').waitFor();  \n} catch (e) {  \n  if (e instanceof playwright.errors.TimeoutError) {  \n    // Do something if this is a timeout.  \n  }  \n}", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/api/class-playwright"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    video: {  \n      mode: 'on-first-retry',  \n      size: { width: 640, height: 480 }  \n    }  \n  },  \n});  \n\n\n\nconst context = await browser.newContext({  \n  recordVideo: {  \n    dir: 'videos/',  \n    size: { width: 640, height: 480 },  \n  }  \n});", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    video: {  \n      mode: 'on-first-retry',  \n      size: { width: 640, height: 480 }  \n    }  \n  },  \n});  \n\n\n\nconst context = await browser.newContext({  \n  recordVideo: {  \n    dir: 'videos/',  \n    size: { width: 640, height: 480 },  \n  }  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/videos", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Locate by CSS or XPath\u200b | If you absolutely must use CSS or XPath locators, you can use [page.locator()](/docs/api/class-page#page-locator) to create a locator that takes a selector describing how to find an element in the page. Playwright supports CSS and XPath selectors, and auto-detects them if you omit `css=` or `xpath=` prefix.", "output": "await page.locator('css=button').click();  \nawait page.locator('xpath=//button').click();  \n  \nawait page.locator('button').click();  \nawait page.locator('//button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Checkboxes and radio buttons\u200b | Using [locator.setChecked()](/docs/api/class-locator#locator-set-checked) is the easiest way to check and uncheck a checkbox or a radio button. This method can be used with `input[type=checkbox]`, `input[type=radio]` and `[role=checkbox]` elements.", "output": "// Check the checkbox  \nawait page.getByLabel('I agree to the terms above').check();  \n  \n// Assert the checked state  \nexpect(page.getByLabel('Subscribe to newsletter')).toBeChecked();  \n  \n// Select the radio button  \nawait page.getByLabel('XL').check();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Generate a Playwright test for the following scenario: The difference between the [Locator](/docs/api/class-locator) and [ElementHandle](/docs/api/class-elementhandle) is that the latter points to a particular element, while [Locator](/docs/api/class-locator) captures the logic of how to retrieve that element. | Also, locators are **\"strict\" by default**!", "input": "", "output": "const locator = page.locator('button');  \nawait locator.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: page.getByTestId() to locate an element based on its `data-testid` attribute (other attributes can be configured).", "input": "", "output": "await page.getByLabel('User Name').fill('John');  \n  \nawait page.getByLabel('Password').fill('secret-password');  \n  \nawait page.getByRole('button', { name: 'Sign in' }).click();  \n  \nawait expect(page.getByText('Welcome, John!')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test for the following scenario: example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  await expect(page).toHaveScreenshot({ stylePath: path.join(__dirname, 'screenshot.css') });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// <input id=name>  \nawait page.locator('#name').press('Shift+A');  \n  \n// <input id=name>  \nawait page.locator('#name').press('Shift+ArrowLeft');", "output": "// <input id=name>  \nawait page.locator('#name').press('Shift+A');  \n  \n// <input id=name>  \nawait page.locator('#name').press('Shift+ArrowLeft');", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "page.on('dialog', dialog => dialog.accept());  \nawait page.getByRole('button').click();", "output": "page.on('dialog', dialog => dialog.accept());  \nawait page.getByRole('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/dialogs", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { mergeTests, mergeExpects } from '@playwright/test';  \nimport { test as dbTest, expect as dbExpect } from 'database-test-utils';  \nimport { test as a11yTest, expect as a11yExpect } from 'a11y-test-utils';  \n  \nexport const test = mergeTests(dbTest, a11yTest);  \nexport const expect = mergeExpects(dbExpect, a11yExpect);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: We can also assert the product card to make sure there is only one:", "input": "", "output": "await expect(page  \n    .getByRole('listitem')  \n    .filter({ has: page.getByRole('heading', { name: 'Product 2' }) }))  \n    .toHaveCount(1);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.getByAltText('playwright logo').click();", "output": "await page.getByAltText('playwright logo').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "tests/example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({ userAgent: 'My user agent' });  \n  \ntest('my user agent test', async ({ page }) => {  \n  // ...  \n});  \n\n\n\nconst context = await browser.newContext({  \n  userAgent: 'My user agent'  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Then we add the [testProject.dependencies](/docs/api/class-testproject#test-project-dependencies) property to our projects that depend on the setup project and pass into the array the name of our dependency project, which we defined in the previous step: | playwright.config.ts", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  testDir: './tests',  \n  // ...  \n  projects: [  \n    {  \n      name: 'setup db',  \n      testMatch: /global\\.setup\\.ts/,  \n    },  \n    {  \n      name: 'chromium with db',  \n      use: { ...devices['Desktop Chrome'] },  \n      dependencies: ['setup db'],  \n    },  \n  ]  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Use the [code generator](/docs/codegen) to generate a locator, and then edit it as you'd like. | Every time a locator is used for an action, an up-to-date DOM element is located in the page. In the snippet below, the underlying DOM element will be located twice, once prior to every action. This means that if the DOM changes in between the calls due to re-render, the new element corresponding to the locator will be used.", "output": "const locator = page.getByRole('button', { name: 'Sign in' });  \n  \nawait locator.hover();  \nawait locator.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "navigation"}}
{"instruction": "Generate a Playwright test for the following scenario: However, other methods will target the label itself, for example [expect(locator).toHaveText()](/docs/api/class-locatorassertions#locator-assertions-to-have-text) will assert the text content of the label, not the input field.", "input": "", "output": "// Fill the input by targeting the label.  \nawait expect(page.locator('label')).toHaveText('Password');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "component.spec.tsx", "output": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('event', async ({ mount }) => {  \n  const component = await mount(<Component v-on:click={() => {}} />);  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.beforeEach(async ({ page }, testInfo) => {  \n  // Extend timeout for all tests running this hook by 30 seconds.  \n  testInfo.setTimeout(testInfo.timeout + 30_000);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Playwright also includes web-specific [async matchers](/docs/api/class-locatorassertions) that will wait until the expected condition is met. Consider the following example:", "output": "await expect(page.getByTestId('status')).toHaveText('Submitted');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "By default, [fixture](/docs/test-fixtures) shares timeout with the test. However, for slow fixtures, especially [worker-scoped](/docs/test-fixtures#worker-scoped-fixtures) ones, it is convenient to have a separate timeout. This way you can keep the overall test timeout small, and give the slow fixture more time. | example.spec.ts", "output": "import { test as base, expect } from '@playwright/test';  \n  \nconst test = base.extend<{ slowFixture: string }>({  \n  slowFixture: [async ({}, use) => {  \n    // ... perform a slow operation ...  \n    await use('hello');  \n  }, { timeout: 60_000 }]  \n});  \n  \ntest('example test', async ({ slowFixture }) => {  \n  // ...  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-timeouts", "type": "fixture"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test } from '@playwright/experimental-ct-react';  \nimport { Component } from './mycomponent';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<Component></Component>, {  \n    // Pass mock value from test into `beforeMount`.  \n    hooksConfig: {  \n      router: {  \n        query: { page: 1, per_page: 10 },  \n        asPath: '/posts'  \n      }  \n    }  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: You can also chain two locators together, for example to find a \"Save\" button inside a particular dialog:", "input": "", "output": "const saveButton = page.getByRole('button', { name: 'Save' });  \n// ...  \nconst dialog = page.getByTestId('settings-dialog');  \nawait dialog.locator(saveButton).click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test for the following scenario: A similar configuration in Next.js would look like this: | src/component.spec.jsx", "input": "", "output": "import { test } from '@playwright/experimental-ct-react';  \nimport { Component } from './mycomponent';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<Component></Component>, {  \n    // Pass mock value from test into `beforeMount`.  \n    hooksConfig: {  \n      router: {  \n        query: { page: 1, per_page: 10 },  \n        asPath: '/posts'  \n      }  \n    }  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Wait until all three buttons are visible  \nawait page.locator(':nth-match(:text(\"Buy\"), 3)').waitFor();", "output": "// Wait until all three buttons are visible  \nawait page.locator(':nth-match(:text(\"Buy\"), 3)').waitFor();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Waits for either confirmation dialog or load spinner.  \nawait page.locator(  \n    `//span[contains(@class, 'spinner__loading')]|//div[@id='confirmation']`  \n).waitFor();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Using `globalSetup` and `globalTeardown` will not produce traces or artifacts, and options like `headless` or `testIdAttribute` specified in the config file are not applied. If you want to produce traces and artifacts and respect config options, use project dependencies. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  globalSetup: require.resolve('./global-setup'),  \n  globalTeardown: require.resolve('./global-teardown'),  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "[APIRequestContext](/docs/api/class-apirequestcontext \"APIRequestContext\") now accepts [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) and `string` as query parameters\u200b | You can now pass [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) and `string` as query parameters to [APIRequestContext](/docs/api/class-apirequestcontext \"APIRequestContext\"):", "output": "test('query params', async ({ request }) => {  \n  const searchParams = new URLSearchParams();  \n  searchParams.set('userId', 1);  \n  const response = await request.get(  \n      'https://jsonplaceholder.typicode.com/posts',  \n      {  \n        params: searchParams // or as a string: 'userId=1'  \n      }  \n  );  \n  // ...  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'], channel: 'chromium' },  \n    },  \n  ],  \n});", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'], channel: 'chromium' },  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/browsers", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Click a button with accessible name \"log in\"  \nawait page.locator('role=button[name=\"log in\"]').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "For example, `text=\"Log\"` does not match `<button>Log in</button>` because `<button>` contains a single text node `\"Log in\"` that is not equal to `\"Log\"`. However, `text=\"Log\"` matches `<button> Log <span>in</span></button>`, because `<button>` contains a text node `\" Log \"`. This exact mode implies case-sensitive matching, so `text=\"Download\"` will not match `<button>download</button>`. | Quoted body follows the usual escaping rules, e.g. use `\\\"` to escape double quote in a double-quoted string: `text=\"foo\\\"bar\"`.", "output": "await page.locator('text=\"Log in\"').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "navigation"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Capture into buffer\u200b | Rather than writing into a file, you can get a buffer with the image and post-process it or pass it to a third party pixel diff facility.", "output": "const buffer = await page.screenshot();  \nconsole.log(buffer.toString('base64'));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/screenshots"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "[  \n  { name: 'Alice', expected: 'Hello, Alice!' },  \n  { name: 'Bob', expected: 'Hello, Bob!' },  \n  { name: 'Charlie', expected: 'Hello, Charlie!' },  \n].forEach(({ name, expected }) => {  \n  // You can also do it with test.describe() or with multiple tests as long the test name is unique.  \n  test(`testing with ${name}`, async ({ page }) => {  \n    await page.goto(`https://example.com/greet?name=${name}`);  \n    await expect(page.getByRole('heading')).toHaveText(expected);  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parameterize", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "page.on('request', request => console.log(`Request sent: ${request.url()}`));  \nconst listener = request => console.log(`Request finished: ${request.url()}`);  \npage.on('requestfinished', listener);  \nawait page.navigate('https://wikipedia.org');  \n  \npage.off('requestfinished', listener);  \nawait page.navigate('https://www.openstreetmap.org/');", "output": "page.on('request', request => console.log(`Request sent: ${request.url()}`));  \nconst listener = request => console.log(`Request finished: ${request.url()}`);  \npage.on('requestfinished', listener);  \nawait page.goto('https://wikipedia.org');  \n  \npage.off('requestfinished', listener);  \nawait page.goto('https://www.openstreetmap.org/');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/events", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect.poll(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  return response.status();  \n}, {  \n  // Custom expect message for reporting, optional.  \n  message: 'make sure API eventually succeeds',  \n  // Poll for 10 seconds; defaults to 5 seconds. Pass 0 to disable timeout.  \n  timeout: 10000,  \n}).toBe(200);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "expect(value).not.toEqual(0);  \nawait expect(locator).not.toContainText('some text');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Basic Configuration\u200b | Here are some of the most common configuration options.", "input": "", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Look for test files in the \"tests\" directory, relative to this configuration file.  \n  testDir: 'tests',  \n  \n  // Run all tests in parallel.  \n  fullyParallel: true,  \n  \n  // Fail the build on CI if you accidentally left test.only in the source code.  \n  forbidOnly: !!process.env.CI,  \n  \n  // Retry on CI only.  \n  retries: process.env.CI ? 2 : 0,  \n  \n  // Opt out of parallel tests on CI.  \n  workers: process.env.CI ? 1 : undefined,  \n  \n  // Reporter to use  \n  reporter: 'html',  \n  \n  use: {  \n    // Base URL to use in actions like `await page.goto('/')`.  \n    baseURL: 'http://127.0.0.1:3000',  \n  \n    // Collect trace when retrying the failed test.  \n    trace: 'on-first-retry',  \n  },  \n  // Configure projects for major browsers.  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n    },  \n  ],  \n  // Run your local dev server before starting the tests.  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n  },  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-configuration"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { mergeTests, mergeExpects } from '@playwright/test';  \nimport { test as dbTest, assert as dbExpect } from 'database-test-utils';  \nimport { test as a11yTest, assert as a11yExpect } from 'a11y-test-utils';  \n  \nexport const assert = mergeExpects(dbExpect, a11yExpect);  \nexport const test = mergeTests(dbTest, a11yTest);", "output": "import { mergeTests, mergeExpects } from '@playwright/test';  \nimport { test as dbTest, expect as dbExpect } from 'database-test-utils';  \nimport { test as a11yTest, expect as a11yExpect } from 'a11y-test-utils';  \n  \nexport const expect = mergeExpects(dbExpect, a11yExpect);  \nexport const test = mergeTests(dbTest, a11yTest);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Basic navigation\u200b | Simplest form of a navigation is opening a URL:", "input": "", "output": "// Navigate the page  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/navigations"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const { test, expect } = require('@playwright/test');  \nconst { PlaywrightDevPage } = require('./playwright-dev-page');  \n  \ntest('getting started should contain table of contents', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.getStarted();  \n  await expect(playwrightDev.tocList).toHaveText([  \n    `How to install Playwright`,  \n    `What's Installed`,  \n    `How to run the example test`,  \n    `How to open the HTML test report`,  \n    `Write tests using web first assertions, page fixtures and locators`,  \n    `Run single test, multiple tests, headed mode`,  \n    `Generate tests with Codegen`,  \n    `See a trace of your tests`  \n  ]);  \n});  \n  \ntest('should show Page Object Model article', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.pageObjectModel();  \n  await expect(page.locator('article')).toContainText('Page Object Model is a common pattern');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/pom", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Set expect timeout in the config\u200b | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  expect: {  \n    timeout: 10_000,  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "N-th element locator\u200b | You can narrow down query to the n-th match using the `nth=` locator passing a zero-based index.", "output": "// Click first button  \nawait page.locator('button').locator('nth=0').click();  \n  \n// Click last button  \nawait page.locator('button').locator('nth=-1').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'setup',  \n      testMatch: /global.setup\\.ts/,  \n    },  \n    {  \n      name: 'chromium',  \n      use: devices['Desktop Chrome'],  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'firefox',  \n      use: devices['Desktop Firefox'],  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'webkit',  \n      use: devices['Desktop Safari'],  \n      dependencies: ['setup'],  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  globalTimeout: 3_600_000,  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  globalTimeout: 3_600_000,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-timeouts", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as base } from '@playwright/test';  \nimport AxeBuilder from '@axe-core/playwright';  \n  \ntype AxeFixture = {  \n  makeAxeBuilder: () => AxeBuilder;  \n};  \n  \n// Extend base test by providing \"makeAxeBuilder\"  \n//  \n// This new \"test\" can be used in multiple test files, and each of them will get  \n// a consistently configured AxeBuilder instance.  \nexport const test = base.extend<AxeFixture>({  \n  makeAxeBuilder: async ({ page }, use, testInfo) => {  \n    const makeAxeBuilder = () => new AxeBuilder({ page })  \n        .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])  \n        .exclude('#commonly-reused-element-with-known-issue');  \n  \n    await use(makeAxeBuilder);  \n  }  \n});  \nexport { expect } from '@playwright/test';  \n\n\n\n// axe-test.js  \nconst base = require('@playwright/test');  \nconst AxeBuilder = require('@axe-core/playwright').default;  \n  \n// Extend base test by providing \"makeAxeBuilder\"  \n//  \n// This new \"test\" can be used in multiple test files, and each of them will get  \n// a consistently configured AxeBuilder instance.  \nexports.test = base.test.extend({  \n  makeAxeBuilder: async ({ page }, use, testInfo) => {  \n    const makeAxeBuilder = () => new AxeBuilder({ page })  \n        .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])  \n        .exclude('#commonly-reused-element-with-known-issue');  \n  \n    await use(makeAxeBuilder);  \n  }  \n});  \nexports.expect = base.expect;", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/accessibility-testing", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  locale: 'de-DE',  \n  timezoneId: 'Europe/Berlin',  \n});  \n  \ntest('my test for de lang in Berlin timezone', async ({ page }) => {  \n  await page.goto('https://www.bing.com');  \n  // ...  \n});  \n\n\n\nconst context = await browser.newContext({  \n  locale: 'de-DE',  \n  timezoneId: 'Europe/Berlin',  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: component.spec.ts", "input": "", "output": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(Component);  \n  await component.update({  \n    props: { msg: 'greetings' },  \n    on: { click() {} },  \n    slots: { default: 'Child' }  \n  });  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect(page.locator('text=Name'), 'should be logged in').toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport type { HooksConfig } from '../playwright';  \nimport { ProductsPage } from './pages/ProductsPage';  \n  \ntest('configure routing through hooks config', async ({ page, mount }) => {  \n  const component = await mount<HooksConfig>(<ProductsPage />, {  \n    hooksConfig: { enableRouting: true },  \n  });  \n  await expect(component.getByRole('link')).toHaveAttribute('href', '/products/42');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test('navigation menu should not have automatically detectable accessibility violations', async ({  \n  page,  \n}) => {  \n  await page.navigate('https://your-site.com/');  \n  \n  await page.getByRole('button', { name: 'Navigation Menu' }).click();  \n  \n  // It is important to waitFor() the page to be in the desired  \n  // state *before* running analyze(). Otherwise, axe might not  \n  // find all the elements your test asserts it to scan.  \n  await page.locator('#navigation-menu-flyout').waitFor();  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .include('#navigation-menu-flyout')  \n      .analyze();  \n  \n  assert(accessibilityScanResults.violations).toEqual([]);  \n});", "output": "test('navigation menu should not have automatically detectable accessibility violations', async ({  \n  page,  \n}) => {  \n  await page.goto('https://your-site.com/');  \n  \n  await page.getByRole('button', { name: 'Navigation Menu' }).click();  \n  \n  // It is important to waitFor() the page to be in the desired  \n  // state *before* running analyze(). Otherwise, axe might not  \n  // find all the elements your test expects it to scan.  \n  await page.locator('#navigation-menu-flyout').waitFor();  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .include('#navigation-menu-flyout')  \n      .analyze();  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "const product = page.getByRole('listitem').filter({ hasText: 'Product 2' });  \n  \nawait product.getByRole('button', { name: 'Add to cart' }).click();  \n  \nawait expect(product).toHaveCount(1);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "completion"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "const slowExpect = expect.configure({ timeout: 10000 });  \nawait slowExpect(locator).toHaveText('Submit');  \n  \n// Always do soft assertions.  \nconst softExpect = expect.configure({ soft: true });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: Locators are strict. This means that all operations on locators that imply some target DOM element will throw an exception if more than one element matches. For example, the following call throws if there are several buttons in the DOM: | Throws an error if more than one\u200b", "input": "", "output": "await page.getByRole('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test for the following scenario: Note that all methods that create a locator, such as [page.getByLabel()](/docs/api/class-page#page-get-by-label), are also available on the [Locator](/docs/api/class-locator \"Locator\") and [FrameLocator](/docs/api/class-framelocator \"FrameLocator\") classes, so you can chain them and iteratively narrow down your locator.", "input": "", "output": "const locator = page  \n    .frameLocator('#my-frame')  \n    .getByRole('button', { name: 'Sign in' });  \n  \nawait locator.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "test('log battery calls', async ({ page }) => {  \n  const log = [];  \n  // Expose function for pushing messages to the Node.js script.  \n  await page.exposeFunction('logCall', msg => log.push(msg));  \n  await page.addInitScript(() => {  \n    const mockBattery = {  \n      level: 0.75,  \n      charging: true,  \n      chargingTime: 1800,  \n      dischargingTime: Infinity,  \n      // Log addEventListener calls.  \n      addEventListener: (name, cb) => logCall(`addEventListener:${name}`)  \n    };  \n    // Override the method to always return mock battery info.  \n    window.navigator.getBattery = async () => {  \n      logCall('getBattery');  \n      return mockBattery;  \n    };  \n  });  \n  \n  await page.goto('/');  \n  await expect(page.locator('.battery-percentage')).toHaveText('75%');  \n  \n  // Compare actual calls with golden.  \n  expect(log).toEqual([  \n    'getBattery',  \n    'addEventListener:chargingchange',  \n    'addEventListener:levelchange'  \n  ]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock-browser-apis", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// \ud83d\udc4d  \nawait assert(page.getByText('welcome')).toBeVisible();", "output": "// \ud83d\udc4d  \nawait expect(page.getByText('welcome')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/best-practices", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: [locator.selectOption()](/docs/api/class-locator#locator-select-option) will select an option from the select box.", "input": "", "output": "// Fill the input by targeting the label.  \nawait page.getByText('Password').fill('secret');", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test for the following scenario: Playwright also includes async matchers that will wait until the expected condition is met. Using these matchers allows making the tests non-flaky and resilient. For example, this code will wait until the page gets the title containing \"Playwright\":", "input": "", "output": "await expect(page).toHaveTitle(/Playwright/);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/writing-tests"}}
{"instruction": "Generate a Playwright test for the following scenario: Run a test from a specific breakpoint\u200b | To speed up the debugging process you can add a [page.pause()](/docs/api/class-page#page-pause) method to your test. This way you won't have to step through each action of your test to get to the point where you want to debug.", "input": "", "output": "await page.pause();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/debug"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "test.spec.ts", "output": "import { test, expect } from './fixtures';  \n  \ntest('passes', async ({ page, database }) => {  \n  await expect(database).toHaveDatabaseUser('admin');  \n  await expect(page).toPassA11yAudit();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const jsHandle = await page.evaluateHandle('window');  \n//  Use jsHandle for evaluations.", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/handles", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    // All requests we send go to this API endpoint.  \n    baseURL: 'https://api.github.com',  \n    extraHTTPHeaders: {  \n      // We set this header per GitHub guidelines.  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add authorization token to all requests.  \n      // Assuming personal access token available in the environment.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    },  \n  }  \n});", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    // All requests we send go to this API endpoint.  \n    baseURL: 'https://api.github.com',  \n    extraHTTPHeaders: {  \n      // We set this header per GitHub guidelines.  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add authorization token to all requests.  \n      // Assuming personal access token available in the environment.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    },  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/api-testing", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "expect(await page.screenshot()).toMatchSnapshot({  \n  maxDiffPixels: 27, // allow no more than 27 different pixels.  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: Soft assertions\u200b | By default, failed assertion will terminate test execution. Playwright also supports _soft assertions_ : failed soft assertions **do not** terminate test execution, but mark the test as failed.", "input": "", "output": "// Make a few checks that will not stop the test when failed...  \nawait expect.soft(page.getByTestId('status')).toHaveText('Success');  \nawait expect.soft(page.getByTestId('eta')).toHaveText('1 day');  \n  \n// ... and continue the test to check more things.  \nawait page.getByRole('link', { name: 'next page' }).click();  \nawait expect.soft(page.getByRole('heading', { name: 'Make another order' })).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/test';  \n  \ntest.describe('suite', () => {  \n  test.beforeAll(async () => { /* ... */ });  \n  test('first good', async ({ page }) => { /* ... */ });  \n  test('second flaky', async ({ page }) => { /* ... */ });  \n  test('third good', async ({ page }) => { /* ... */ });  \n  test.afterAll(async () => { /* ... */ });  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-retries", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Set an exact match:", "output": "await expect(page.getByText('Welcome, John', { exact: true })).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "Setup and teardown\u200b | These tests assume that repository exists. You probably want to create a new one before running tests and delete it afterwards. Use `beforeAll` and `afterAll` hooks for that.", "output": "test.beforeAll(async ({ request }) => {  \n  // Create a new repository  \n  const response = await request.post('/user/repos', {  \n    data: {  \n      name: REPO  \n    }  \n  });  \n  expect(response.ok()).toBeTruthy();  \n});  \n  \ntest.afterAll(async ({ request }) => {  \n  // Delete the repository  \n  const response = await request.delete(`/repos/${USER}/${REPO}`);  \n  expect(response.ok()).toBeTruthy();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/api-testing", "type": "fixture"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Playwright scripts run in your Playwright environment. Your page scripts run in the browser page environment. Those environments don't intersect, they are running in different virtual machines in different processes and even potentially on different computers. | The [page.evaluate()](/docs/api/class-page#page-evaluate) API can run a JavaScript function in the context of the web page and bring results back to the Playwright environment. Browser globals like `window` and `document` can be used in `evaluate`.", "output": "const href = await page.evaluate(() => document.location.href);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/evaluating"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \nexport default function createTests() {  \n  test.use({ viewport: { width: 500, height: 500 } });  \n  \n  test('feature-b example test', async ({ page }) => {  \n    // ... test goes here  \n  });  \n}", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parallel", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: Use new options [hasNot](/docs/api/class-locator#locator-filter-option-has-not) and [hasNotText](/docs/api/class-locator#locator-filter-option-has-not-text) in [locator.filter()](/docs/api/class-locator#locator-filter) to find elements that **do not match** certain conditions.", "input": "", "output": "const rowLocator = page.locator('tr');  \nawait rowLocator  \n    .filter({ hasNotText: 'text in column 1' })  \n    .filter({ hasNot: page.getByRole('button', { name: 'column 2 button' }) })  \n    .screenshot();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Now you can use a relative path when navigating the page: | test.spec.ts", "output": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  // This will navigate to http://127.0.0.1:3000/login  \n  await page.goto('./login');  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-webserver", "type": "navigation"}}
{"instruction": "Generate a Playwright test for the following scenario: We recommend prioritizing [user-visible locators](/docs/locators#quick-guide) like text or accessible role instead of using CSS that is tied to the implementation and could break when the page changes. | Playwright can locate an element by CSS selector.", "input": "", "output": "await page.locator('css=button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test for the following scenario: Setting in the configuration file: | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Limit the number of failures on CI to save resources  \n  maxFailures: process.env.CI ? 10 : undefined,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "New options [testConfig.respectGitIgnore](/docs/api/class-testconfig#test-config-respect-git-ignore) and [testProject.respectGitIgnore](/docs/api/class-testproject#test-project-respect-git-ignore) control whether files matching `.gitignore` patterns are excluded when searching for tests. | New property `timeout` is now available for custom expect matchers. This property takes into account `playwright.config.ts` and `expect.configure()`.", "output": "import { expect as baseExpect } from '@playwright/test';  \n  \nexport const expect = baseExpect.extend({  \n  async toHaveAmount(locator: Locator, expected: number, options?: { timeout?: number }) {  \n    // When no timeout option is specified, use the config timeout.  \n    const timeout = options?.timeout ?? this.timeout;  \n    // ... implement the assertion ...  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: Use web first assertions such as `toBeVisible()` instead.", "input": "", "output": "// \ud83d\udc4d  \nawait expect(page.getByText('welcome')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/best-practices"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/test';  \n  \ntest.beforeEach(async ({ context }) => {  \n  // Runs before each test and signs in each page.  \n  await context.grantPermissions(['notifications'], { origin: 'https://skype.com' });  \n});  \n  \ntest('first', async ({ page }) => {  \n  // page has notifications permission for https://skype.com.  \n});  \n\n\n\nawait context.grantPermissions(['notifications'], { origin: 'https://skype.com' });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/emulation", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Added before v1.9 playwright.devices | Returns a dictionary of devices to be used with [browser.newContext()](/docs/api/class-browser#browser-new-context) or [browser.newPage()](/docs/api/class-browser#browser-new-page).", "output": "const { webkit, devices } = require('playwright');  \nconst iPhone = devices['iPhone 6'];  \n  \n(async () => {  \n  const browser = await webkit.launch();  \n  const context = await browser.newContext({  \n    ...iPhone  \n  });  \n  const page = await context.newPage();  \n  await page.goto('http://example.com');  \n  // other actions...  \n  await browser.close();  \n})();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/api/class-playwright"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "[  \n  { name: 'Alice', expected: 'Hello, Alice!' },  \n  { name: 'Bob', expected: 'Hello, Bob!' },  \n  { name: 'Charlie', expected: 'Hello, Charlie!' },  \n].forEach(({ name, expected }) => {  \n  test.describe(() => {  \n    test.beforeEach(async ({ page }) => {  \n      await page.goto(`https://example.com/greet?name=${name}`);  \n    });  \n    test(`testing with ${expected}`, async ({ page }) => {  \n      await expect(page.getByRole('heading')).toHaveText(expected);  \n    });  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parameterize", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest('context fetch', async ({ page }) => {  \n  const completeness = page.locator('text=Success');  \n  await completeness.waitFor();  \n  assert(await page.screenshot()).toMatchSnapshot('screen.png');  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('context fetch', async ({ page }) => {  \n  const completeness = page.locator('text=Success');  \n  await completeness.waitFor();  \n  expect(await page.screenshot()).toMatchSnapshot('screen.png');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Using request context\u200b | Behind the scenes, [`request` fixture](/docs/api/class-fixtures#fixtures-request) will actually call [apiRequest.newContext()](/docs/api/class-apirequest#api-request-new-context). You can always do that manually if you'd like more control. Below is a standalone script that does the same as `beforeAll` and `afterAll` from above.", "output": "import { request } from '@playwright/test';  \nconst REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \n(async () => {  \n  // Create a context that will issue http requests.  \n  const context = await request.newContext({  \n    baseURL: 'https://api.github.com',  \n  });  \n  \n  // Create a repository.  \n  await context.post('/user/repos', {  \n    headers: {  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add GitHub personal access token.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    },  \n    data: {  \n      name: REPO  \n    }  \n  });  \n  \n  // Delete a repository.  \n  await context.delete(`/repos/${USER}/${REPO}`, {  \n    headers: {  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add GitHub personal access token.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    }  \n  });  \n})();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/api-testing"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.locator('#nav-bar :text(\"Home\")').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  workers: 1,  \n  testMatch: 'test.list.ts',  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  workers: 1,  \n  testMatch: 'test.list.ts',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('unmount', async ({ mount }) => {  \n  const component = await mount(Component);  \n  await component.unmount();  \n});", "output": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('unmount', async ({ mount }) => {  \n  const component = await mount(Component);  \n  await component.unmount();  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: You can't pass data to your component synchronously in a callback:", "input": "", "output": "test('this will not work', async ({ mount }) => {  \n  // () => 'red' callback lives in Node. If `ColorPicker` component in the browser calls the parameter function  \n  // `colorGetter` it won't get result synchronously. It'll be able to get it via await, but that is not how  \n  // components are typically built.  \n  const component = await mount(<ColorPicker colorGetter={() => 'red'}/>);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "// \ud83d\udc4d  \nawait expect(page.getByText('welcome')).toBeVisible();  \n  \n// \ud83d\udc4e  \nexpect(await page.getByText('welcome').isVisible()).toBe(true);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/best-practices", "type": "completion"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { mergeTests, mergeExpects } from '@playwright/test';  \nimport { test as dbTest, expect as dbExpect } from 'database-test-utils';  \nimport { test as a11yTest, expect as a11yExpect } from 'a11y-test-utils';  \n  \nexport const test = mergeTests(dbTest, a11yTest);  \nexport const expect = mergeExpects(dbExpect, a11yExpect);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const { chromium, firefox, webkit } = require('playwright');  \n  \n(async () => {  \n  const browser = await chromium.launch();  // Or 'firefox' or 'webkit'.  \n  const page = await browser.newPage();  \n  await page.navigate('http://example.com');  \n  // other actions...  \n  await browser.close();  \n})();", "output": "const { chromium, firefox, webkit } = require('playwright');  \n  \n(async () => {  \n  const browser = await chromium.launch();  // Or 'firefox' or 'webkit'.  \n  const page = await browser.newPage();  \n  await page.goto('http://example.com');  \n  // other actions...  \n  await browser.close();  \n})();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/api/class-playwright", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test as setup, expect } from '@playwright/test';  \nimport path from 'path';  \n  \nconst authFile = path.join(__dirname, '../playwright/.auth/user.json');  \n  \nsetup('authenticate', async ({ page }) => {  \n  // Perform authentication steps. Replace these actions with your own.  \n  await page.goto('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('username');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n  // Wait until the page receives the cookies.  \n  //  \n  // Sometimes login flow sets cookies in the process of several redirects.  \n  // Wait for the final URL to ensure that the cookies are actually set.  \n  await page.waitForURL('https://github.com/');  \n  // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n  await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n  // End of authentication steps.  \n  \n  await page.context().storageState({ path: authFile });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/auth", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: You can now use [route.fallback()](/docs/api/class-route#route-fallback) to defer routing to other handlers. | Consider the following example:", "input": "", "output": "// Remove a header from all requests.  \ntest.beforeEach(async ({ page }) => {  \n  await page.route('**/*', async route => {  \n    const headers = await route.request().allHeaders();  \n    delete headers['if-none-match'];  \n    await route.fallback({ headers });  \n  });  \n});  \n  \ntest('should work', async ({ page }) => {  \n  await page.route('**/*', async route => {  \n    if (route.request().resourceType() === 'image')  \n      await route.abort();  \n    else  \n      await route.fallback();  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "If the result is a Promise or if the function is asynchronous evaluate will automatically wait until it's resolved:", "output": "const status = await page.evaluate(async () => {  \n  const response = await fetch(location.href);  \n  return response.status;  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/evaluating"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    launchOptions: {  \n      slowMo: 50,  \n    },  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const frameLocator = page.frameLocator('iframe[name=\"embedded\"]');  \n// ...  \nconst locator = frameLocator.owner();  \nawait assert(locator).toBeVisible();", "output": "const frameLocator = page.frameLocator('iframe[name=\"embedded\"]');  \n// ...  \nconst locator = frameLocator.owner();  \nawait expect(locator).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Press the common keyboard shortcut Control+S or Meta+S to trigger a \"Save\" operation.  \nawait page.keyboard.press('ControlOrMeta+S');", "output": "// Press the common keyboard shortcut Control+S or Meta+S to trigger a \"Save\" operation.  \nawait page.keyboard.press('ControlOrMeta+S');", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect(page.getByText('Welcome, John', { exact: true })).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test.beforeAll(async ({ request }) => {  \n  // Create a new repository  \n  const response = await request.post('/user/repos', {  \n    data: {  \n      name: REPO  \n    }  \n  });  \n  assert(response.ok()).toBeTruthy();  \n});  \n  \ntest.afterAll(async ({ request }) => {  \n  // Delete the repository  \n  const response = await request.delete(`/repos/${USER}/${REPO}`);  \n  assert(response.ok()).toBeTruthy();  \n});", "output": "test.beforeAll(async ({ request }) => {  \n  // Create a new repository  \n  const response = await request.post('/user/repos', {  \n    data: {  \n      name: REPO  \n    }  \n  });  \n  expect(response.ok()).toBeTruthy();  \n});  \n  \ntest.afterAll(async ({ request }) => {  \n  // Delete the repository  \n  const response = await request.delete(`/repos/${USER}/${REPO}`);  \n  expect(response.ok()).toBeTruthy();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/api-testing", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const { chromium } = require('playwright');  \n  \n(async () => {  \n  const pathToExtension = require('path').join(__dirname, 'my-extension');  \n  const userDataDir = '/tmp/test-user-data-dir';  \n  const browserContext = await chromium.launchPersistentContext(userDataDir, {  \n    headless: false,  \n    args: [  \n      `--disable-extensions-except=${pathToExtension}`,  \n      `--load-extension=${pathToExtension}`  \n    ]  \n  });  \n  let [backgroundPage] = browserContext.backgroundPages();  \n  if (!backgroundPage)  \n    backgroundPage = await browserContext.waitForEvent('backgroundpage');  \n  \n  // Test the background page as you would any other page.  \n  await browserContext.close();  \n})();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/chrome-extensions", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect.poll(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  return response.status();  \n}, {  \n  // Probe, wait 1s, probe, wait 2s, probe, wait 10s, probe, wait 10s, probe  \n  // ... Defaults to [100, 250, 500, 1000].  \n  intervals: [1_000, 2_000, 10_000],  \n  timeout: 60_000  \n}).toBe(200);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "page.on('dialog', dialog => console.log(dialog.message()));  \nawait page.getByRole('button').click(); // Will hang here", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/dialogs", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  viewport: { width: 1600, height: 1200 },  \n});  \n  \ntest('my test', async ({ page }) => {  \n  // ...  \n});  \n\n\n\n// Create context with given viewport  \nconst context = await browser.newContext({  \n  viewport: { width: 1280, height: 1024 }  \n});  \n  \n// Resize viewport for individual page  \nawait page.setViewportSize({ width: 1600, height: 1200 });  \n  \n// Emulate high-DPI  \nconst context = await browser.newContext({  \n  viewport: { width: 2560, height: 1440 },  \n  deviceScaleFactor: 2,  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "// Configure mock API before each test.  \ntest.beforeEach(async ({ page }) => {  \n  await page.addInitScript(() => {  \n    const mockBattery = {  \n      level: 0.90,  \n      charging: true,  \n      chargingTime: 1800, // seconds  \n      dischargingTime: Infinity,  \n      addEventListener: () => { }  \n    };  \n    // Override the method to always return mock battery info.  \n    window.navigator.getBattery = async () => mockBattery;  \n  });  \n});  \n  \ntest('show battery status', async ({ page }) => {  \n  await page.goto('/');  \n  await expect(page.locator('.battery-percentage')).toHaveText('90%');  \n  await expect(page.locator('.battery-status')).toHaveText('Adapter');  \n  await expect(page.locator('.battery-fully')).toHaveText('00:30');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock-browser-apis", "type": "completion"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  expect: {  \n    // Maximum time expect() should wait for the condition to be met.  \n    timeout: 5000,  \n  \n    toHaveScreenshot: {  \n      // An acceptable amount of pixels that could be different, unset by default.  \n      maxDiffPixels: 10,  \n    },  \n  \n    toMatchSnapshot: {  \n      // An acceptable ratio of pixels that are different to the  \n      // total amount of pixels, between 0 and 1.  \n      maxDiffPixelRatio: 0.1,  \n    },  \n  },  \n  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-configuration", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['junit', { outputFile: 'results.xml' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: note | If both \"New email\" button and security dialog appear on screen, the \"or\" locator will match both of them, possibly throwing the \"strict mode violation\" error. In this case, you can use [locator.first()](/docs/api/class-locator#locator-first) to only match one of them.", "input": "", "output": "const newEmail = page.getByRole('button', { name: 'New' });  \nconst dialog = page.getByText('Confirm security settings');  \nawait expect(newEmail.or(dialog).first()).toBeVisible();  \nif (await dialog.isVisible())  \n  await page.getByRole('button', { name: 'Dismiss' }).click();  \nawait newEmail.click();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "Box fixtures\u200b | Usually, custom fixtures are reported as separate steps in in the UI mode, Trace Viewer and various test reports. They also appear in error messages from the test runner. For frequently-used fixtures, this can mean lots of noise. You can stop the fixtures steps from being shown in the UI by \"boxing\" it.", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  helperFixture: [async ({}, use, testInfo) => {  \n    // ...  \n  }, { box: true }],  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Create a Playwright test that demonstrates the page_object pattern.", "input": "SettingsPage is similar: | settings-page.ts", "output": "import type { Page } from '@playwright/test';  \n  \nexport class SettingsPage {  \n  constructor(public readonly page: Page) {  \n  }  \n  \n  async switchToDarkMode() {  \n    // ...  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { handlers } from '@src/mocks/handlers';  \n  \ntest.beforeEach(async ({ router }) => {  \n  // install common handlers before each test  \n  await router.use(...handlers);  \n});  \n  \ntest('example test', async ({ mount }) => {  \n  // test as usual, your handlers are active  \n  // ...  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "tests/example.spec.ts", "output": "import { test } from '@playwright/test';  \n  \ntest.beforeEach(async ({ context }) => {  \n  // Runs before each test and signs in each page.  \n  await context.grantPermissions(['notifications'], { origin: 'https://skype.com' });  \n});  \n  \ntest('first', async ({ page }) => {  \n  // page has notifications permission for https://skype.com.  \n});  \n\n\n\nawait context.grantPermissions(['notifications'], { origin: 'https://skype.com' });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "For example, `article:has-text(\"Playwright\")` matches `<article><div>Playwright</div></article>`. | Note that `:has-text()` should be used together with other CSS specifiers, otherwise it will match all the elements containing specified text, including the `<body>`.", "output": "// Wrong, will match many elements including <body>  \nawait page.locator(':has-text(\"Playwright\")').click();  \n// Correct, only matches the <article> element  \nawait page.locator('article:has-text(\"Playwright\")').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from './fixtures';  \n  \ntest('amount', async () => {  \n  await expect(page.locator('.cart')).toHaveAmount(4);  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-assertions", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Fill the input by targeting the label.  \nawait page.getByText('Password').fill('secret');", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Use multiple [BrowserContext](/docs/api/class-browsercontext \"BrowserContext\")s and [Page](/docs/api/class-page \"Page\")s with different storage states in the same test. | tests/example.spec.ts", "output": "import { test } from '@playwright/test';  \n  \ntest('admin and user', async ({ browser }) => {  \n  // adminContext and all pages inside, including adminPage, are signed in as \"admin\".  \n  const adminContext = await browser.newContext({ storageState: 'playwright/.auth/admin.json' });  \n  const adminPage = await adminContext.newPage();  \n  \n  // userContext and all pages inside, including userPage, are signed in as \"user\".  \n  const userContext = await browser.newContext({ storageState: 'playwright/.auth/user.json' });  \n  const userPage = await userContext.newPage();  \n  \n  // ... interact with both adminPage and userPage ...  \n  \n  await adminContext.close();  \n  await userContext.close();  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "However, other methods will target the label itself, for example [expect(locator).toHaveText()](/docs/api/class-locatorassertions#locator-assertions-to-have-text) will assert the text content of the label, not the input field.", "output": "// Fill the input by targeting the label.  \nawait expect(page.locator('label')).toHaveText('Password');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  assert(response.status()).toBe(200);  \n}).toPass({  \n  // Probe, wait 1s, probe, wait 2s, probe, wait 10s, probe, wait 10s, probe  \n  // ... Defaults to [100, 250, 500, 1000].  \n  intervals: [1_000, 2_000, 10_000],  \n  timeout: 60_000  \n});", "output": "await expect(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  expect(response.status()).toBe(200);  \n}).toPass({  \n  // Probe, wait 1s, probe, wait 2s, probe, wait 10s, probe, wait 10s, probe  \n  // ... Defaults to [100, 250, 500, 1000].  \n  intervals: [1_000, 2_000, 10_000],  \n  timeout: 60_000  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import type { Page, Locator } from '@playwright/test';  \n  \nexport class TodoPage {  \n  private readonly inputBox: Locator;  \n  private readonly todoItems: Locator;  \n  \n  constructor(public readonly page: Page) {  \n    this.inputBox = this.page.locator('input.new-todo');  \n    this.todoItems = this.page.getByTestId('todo-item');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://demo.playwright.dev/todomvc/');  \n  }  \n  \n  async addToDo(text: string) {  \n    await this.inputBox.fill(text);  \n    await this.inputBox.press('Enter');  \n  }  \n  \n  async remove(text: string) {  \n    const todo = this.todoItems.filter({ hasText: text });  \n    await todo.hover();  \n    await todo.getByLabel('Delete').click();  \n  }  \n  \n  async removeAll() {  \n    while ((await this.todoItems.count()) > 0) {  \n      await this.todoItems.first().hover();  \n      await this.todoItems.getByLabel('Delete').first().click();  \n    }  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const path = await page.video().path();", "output": "const path = await page.video().path();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/videos", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Before  \n  \nimport { type PlaywrightTestConfig, devices } from '@playwright/experimental-ct-react';  \nconst config: PlaywrightTestConfig = {  \n  // ... config goes here ...  \n};  \nexport default config;", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Fixture timeout\u200b | By default, fixture shares timeout with the test. However, for slow fixtures, especially worker-scoped ones, it is convenient to have a separate timeout. This way you can keep the overall test timeout small, and give the slow fixture more time.", "input": "", "output": "import { test as base, expect } from '@playwright/test';  \n  \nconst test = base.extend<{ slowFixture: string }>({  \n  slowFixture: [async ({}, use) => {  \n    // ... perform a slow operation ...  \n    await use('hello');  \n  }, { timeout: 60000 }]  \n});  \n  \ntest('example test', async ({ slowFixture }) => {  \n  // ...  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as setup } from '@playwright/test';  \n  \nsetup('create new database', async ({ }) => {  \n  console.log('creating new database...');  \n  // Initialize the database  \n});", "output": "import { test as setup } from '@playwright/test';  \n  \nsetup('create new database', async ({ }) => {  \n  console.log('creating new database...');  \n  // Initialize the database  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// select the first button among all buttons  \nawait button.click('button >> nth=0');  \n// or if you are using locators, you can use first(), nth() and last()  \nawait page.locator('button').first().click();  \n  \n// click a visible button  \nawait button.click('button >> visible=true');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('children', async ({ mount }) => {  \n  const component = await mount(<Component>Child</Component>);  \n});", "output": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('children', async ({ mount }) => {  \n  const component = await mount(<Component>Child</Component>);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: You can override options for a specific project using the `project` option in the Playwright config.", "input": "", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        locale: 'de-DE',  \n      },  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import type { Page } from '@playwright/test';  \n  \nexport class SettingsPage {  \n  constructor(public readonly page: Page) {  \n  }  \n  \n  async switchToDarkMode() {  \n    // ...  \n  }  \n}", "output": "import type { Page } from '@playwright/test';  \n  \nexport class SettingsPage {  \n  constructor(public readonly page: Page) {  \n  }  \n  \n  async switchToDarkMode() {  \n    // ...  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Note that all methods that create a locator, such as [page.getByLabel()](/docs/api/class-page#page-get-by-label), are also available on the [Locator](/docs/api/class-locator \"Locator\") and [FrameLocator](/docs/api/class-framelocator \"FrameLocator\") classes, so you can chain them and iteratively narrow down your locator.", "output": "const locator = page  \n    .frameLocator('#my-frame')  \n    .getByRole('button', { name: 'Sign in' });  \n  \nawait locator.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "navigation"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "`data-test`", "output": "// Fill an input with the id \"username\"  \nawait page.locator('id=username').fill('value');  \n  \n// Click an element with data-test-id \"submit\"  \nawait page.locator('data-test-id=submit').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport App from './App';  \n  \n// Let's test component in a dark scheme!  \ntest.use({ colorScheme: 'dark' });  \n  \ntest('should render', async ({ mount }) => {  \n  const component = await mount(<App></App>);  \n  \n  // As with any Playwright test, assert locator text.  \n  await expect(component).toContainText('React');  \n  // Or do a screenshot \ud83d\ude80  \n  await expect(component).toHaveScreenshot();  \n  // Or use any Playwright method  \n  await component.click();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: Configuration for the expect assertion library. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  expect: {  \n    // Maximum time expect() should wait for the condition to be met.  \n    timeout: 5000,  \n  \n    toHaveScreenshot: {  \n      // An acceptable amount of pixels that could be different, unset by default.  \n      maxDiffPixels: 10,  \n    },  \n  \n    toMatchSnapshot: {  \n      // An acceptable ratio of pixels that are different to the  \n      // total amount of pixels, between 0 and 1.  \n      maxDiffPixelRatio: 0.1,  \n    },  \n  },  \n  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-configuration"}}
{"instruction": "Generate a Playwright test for the following scenario: New method [locator.contentFrame()](/docs/api/class-locator#locator-content-frame) converts a [Locator](/docs/api/class-locator \"Locator\") object to a [FrameLocator](/docs/api/class-framelocator \"FrameLocator\"). This can be useful when you have a [Locator](/docs/api/class-locator \"Locator\") object obtained somewhere, and later on would like to interact with the content inside the frame.", "input": "", "output": "const locator = page.locator('iframe[name=\"embedded\"]');  \n// ...  \nconst frameLocator = locator.contentFrame();  \nawait frameLocator.getByRole('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test('log battery calls', async ({ page }) => {  \n  const log = [];  \n  // Expose function for pushing messages to the Node.js script.  \n  await page.exposeFunction('logCall', msg => log.push(msg));  \n  await page.addInitScript(() => {  \n    const mockBattery = {  \n      level: 0.75,  \n      charging: true,  \n      chargingTime: 1800,  \n      dischargingTime: Infinity,  \n      // Log addEventListener calls.  \n      addEventListener: (name, cb) => logCall(`addEventListener:${name}`)  \n    };  \n    // Override the method to always return mock battery info.  \n    window.navigator.getBattery = async () => {  \n      logCall('getBattery');  \n      return mockBattery;  \n    };  \n  });  \n  \n  await page.navigate('/');  \n  await assert(page.locator('.battery-percentage')).toHaveText('75%');  \n  \n  // Compare actual calls with golden.  \n  assert(log).toEqual([  \n    'getBattery',  \n    'addEventListener:chargingchange',  \n    'addEventListener:levelchange'  \n  ]);  \n});", "output": "test('log battery calls', async ({ page }) => {  \n  const log = [];  \n  // Expose function for pushing messages to the Node.js script.  \n  await page.exposeFunction('logCall', msg => log.push(msg));  \n  await page.addInitScript(() => {  \n    const mockBattery = {  \n      level: 0.75,  \n      charging: true,  \n      chargingTime: 1800,  \n      dischargingTime: Infinity,  \n      // Log addEventListener calls.  \n      addEventListener: (name, cb) => logCall(`addEventListener:${name}`)  \n    };  \n    // Override the method to always return mock battery info.  \n    window.navigator.getBattery = async () => {  \n      logCall('getBattery');  \n      return mockBattery;  \n    };  \n  });  \n  \n  await page.goto('/');  \n  await expect(page.locator('.battery-percentage')).toHaveText('75%');  \n  \n  // Compare actual calls with golden.  \n  expect(log).toEqual([  \n    'getBattery',  \n    'addEventListener:chargingchange',  \n    'addEventListener:levelchange'  \n  ]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock-browser-apis", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: An example test illustrating the initial context options are set:", "input": "", "output": "test('should inherit use options on context when using built-in browser fixture', async ({  \n  browser,  \n}) => {  \n  const context = await browser.newContext();  \n  const page = await context.newPage();  \n  expect(await page.evaluate(() => navigator.userAgent)).toBe('some custom ua');  \n  expect(await page.evaluate(() => window.innerWidth)).toBe(100);  \n  await context.close();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-use-options"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  await expect(page).toHaveScreenshot();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Negating matchers\u200b | In general, we can expect the opposite to be true by adding a `.not` to the front of the matchers:", "output": "expect(value).not.toEqual(0);  \nawait expect(locator).not.toContainText('some text');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const rows = page.getByRole('listitem');  \nconst count = await rows.count();  \nfor (let i = 0; i < count; ++i)  \n  console.log(await rows.nth(i).textContent());", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert(page  \n    .getByRole('listitem')  \n    .filter({ hasNot: page.getByText('Product 2') }))  \n    .toHaveCount(1);", "output": "await expect(page  \n    .getByRole('listitem')  \n    .filter({ hasNot: page.getByText('Product 2') }))  \n    .toHaveCount(1);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "// Remove a header from all requests.  \ntest.beforeEach(async ({ page }) => {  \n  await page.route('**/*', async route => {  \n    const headers = await route.request().allHeaders();  \n    delete headers['if-none-match'];  \n    await route.fallback({ headers });  \n  });  \n});  \n  \ntest('should work', async ({ page }) => {  \n  await page.route('**/*', async route => {  \n    if (route.request().resourceType() === 'image')  \n      await route.abort();  \n    else  \n      await route.fallback();  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Set the test id to use a custom data attribute for your tests. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    testIdAttribute: 'data-pw'  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/experimental-ct-svelte';  \nimport App from './App.svelte';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(App);  \n  await assert(component).toContainText('Learn Svelte');  \n});", "output": "import { test, expect } from '@playwright/experimental-ct-svelte';  \nimport App from './App.svelte';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(App);  \n  await expect(component).toContainText('Learn Svelte');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect(page.getByTestId('status')).toHaveText('Submitted');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "completion"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "test('event should work', async ({ mount }) => {  \n  let clicked = false;  \n  \n  // Mount a component. Returns locator pointing to the component.  \n  const component = await mount(  \n    <Button title=\"Submit\" onClick={() => { clicked = true }}></Button>  \n  );  \n  \n  // As with any Playwright test, assert locator text.  \n  await expect(component).toContainText('Submit');  \n  \n  // Perform locator click. This will trigger the event.  \n  await component.click();  \n  \n  // Assert that respective events have been fired.  \n  expect(clicked).toBeTruthy();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Take a look at the following example to see how to write a test. | tests/example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('has title', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  \n  // Expect a title \"to contain\" a substring.  \n  await expect(page).toHaveTitle(/Playwright/);  \n});  \n  \ntest('get started link', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  \n  // Click the get started link.  \n  await page.getByRole('link', { name: 'Get started' }).click();  \n  \n  // Expects page to have a heading with the name of Installation.  \n  await expect(page.getByRole('heading', { name: 'Installation' })).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/writing-tests"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Mock API requests\u200b | The following code will intercept all the calls to `*/**/api/v1/fruits` and will return a custom response instead. No requests to the API will be made. The test goes to the URL that uses the mocked route and asserts that mock data is present on the page.", "output": "test(\"mocks a fruit and doesn't call api\", async ({ page }) => {  \n  // Mock the api call before navigating  \n  await page.route('*/**/api/v1/fruits', async route => {  \n    const json = [{ name: 'Strawberry', id: 21 }];  \n    await route.fulfill({ json });  \n  });  \n  // Go to the page  \n  await page.goto('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the Strawberry fruit is visible  \n  await expect(page.getByText('Strawberry')).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  webServer: [  \n    {  \n      command: 'npm run start',  \n      url: 'http://127.0.0.1:3000',  \n      timeout: 120 * 1000,  \n      reuseExistingServer: !process.env.CI,  \n    },  \n    {  \n      command: 'npm run backend',  \n      url: 'http://127.0.0.1:3333',  \n      timeout: 120 * 1000,  \n      reuseExistingServer: !process.env.CI,  \n    }  \n  ],  \n  use: {  \n    baseURL: 'http://localhost:3000/',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Library", "output": "import { test } from '@playwright/test';  \n  \ntest('example test', async ({ page, context }) => {  \n  // \"context\" is an isolated BrowserContext, created for this specific test.  \n  // \"page\" belongs to this context.  \n});  \n  \ntest('another test', async ({ page, context }) => {  \n  // \"context\" and \"page\" in this second test are completely  \n  // isolated from the first test.  \n});  \n\n\n\nconst browser = await chromium.launch();  \nconst context = await browser.newContext();  \nconst page = await context.newPage();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/browser-contexts"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Note that resulting matches are sorted by their distance to the anchor element, so you can use [locator.first()](/docs/api/class-locator#locator-first) to pick the closest one. This is only useful if you have something like a list of similar elements, where the closest is obviously the right one. However, using [locator.first()](/docs/api/class-locator#locator-first) in other cases most likely won't work as expected - it will not target the element you are searching for, but some other element that happens to be the closest like a random empty `<div>`, or an element that is scrolled out and is not currently visible.", "output": "// Fill an input to the right of \"Username\".  \nawait page.locator('input:right-of(:text(\"Username\"))').fill('value');  \n  \n// Click a button near the promo card.  \nawait page.locator('button:near(.promo-card)').click();  \n  \n// Click the radio input in the list closest to the \"Label 3\".  \nawait page.locator('[type=radio]:left-of(:text(\"Label 3\"))').first().click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "navigation"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Soft assertions\u200b | By default, failed assertion will terminate test execution. Playwright also supports _soft assertions_ : failed soft assertions **do not** terminate test execution, but mark the test as failed.", "output": "// Make a few checks that will not stop the test when failed...  \nawait expect.soft(page.getByTestId('status')).toHaveText('Success');  \nawait expect.soft(page.getByTestId('eta')).toHaveText('1 day');  \n  \n// ... and continue the test to check more things.  \nawait page.getByRole('link', { name: 'next page' }).click();  \nawait expect.soft(page.getByRole('heading', { name: 'Make another order' })).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "test('gets the json from HAR and checks the new fruit has been added', async ({ page }) => {  \n  // Replay API requests from HAR.  \n  // Either use a matching response from the HAR,  \n  // or abort the request if nothing matches.  \n  await page.routeFromHAR('./hars/fruit.har', {  \n    url: '*/**/api/v1/fruits',  \n    update: false,  \n  });  \n  \n  // Go to the page  \n  await page.goto('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the Playwright fruit is visible  \n  await expect(page.getByText('Playwright', { exact: true })).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: If the page opens a pop-up (e.g. pages opened by `target=\"_blank\"` links), you can get a reference to it by listening to the `popup` event on the page. | This event is emitted in addition to the `browserContext.on('page')` event, but only for popups relevant to this page.", "input": "", "output": "// Start waiting for popup before clicking. Note no await.  \nconst popupPromise = page.waitForEvent('popup');  \nawait page.getByText('open the popup').click();  \nconst popup = await popupPromise;  \n// Interact with the new popup normally.  \nawait popup.getByRole('button').click();  \nconsole.log(await popup.title());", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/pages"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const base = require('@playwright/test');  \n  \nexports.test = base.test.extend({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  person: ['John', { option: true }],  \n});", "output": "const base = require('@playwright/test');  \n  \nexports.test = base.test.extend({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  person: ['John', { option: true }],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parameterize", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "for (const row of await page.getByRole('listitem').all())  \n  console.log(await row.textContent());", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: New [locator.and()](/docs/api/class-locator#locator-and) to create a locator that matches both locators.", "input": "", "output": "const button = page.getByRole('button').and(page.getByTitle('Subscribe'));", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: You don't have to configure anything to mock network requests. Just define a custom [Route](/docs/api/class-route \"Route\") that mocks network for a browser context. | example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.beforeEach(async ({ context }) => {  \n  // Block any css requests for each test in this file.  \n  await context.route(/.css$/, route => route.abort());  \n});  \n  \ntest('loads page without css', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  // ... test goes here  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "We can also assert the product card to make sure there is only one:", "output": "await expect(page  \n    .getByRole('listitem')  \n    .filter({ has: page.getByRole('heading', { name: 'Product 2' }) }))  \n    .toHaveCount(1);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "You can also opt in for fully-parallel mode for just a few projects: | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // runs all tests in all files of a specific project in parallel  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n      fullyParallel: true,  \n    },  \n  ]  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Locate the element by its role of `button` with name \"Sign in\".", "output": "await page.getByRole('button', { name: 'Sign in' }).click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "navigation"}}
{"instruction": "Generate a Playwright test for the following scenario: Once this is done you can navigate the page and check its UI state:", "input": "", "output": "// Configure mock API before each test.  \ntest.beforeEach(async ({ page }) => {  \n  await page.addInitScript(() => {  \n    const mockBattery = {  \n      level: 0.90,  \n      charging: true,  \n      chargingTime: 1800, // seconds  \n      dischargingTime: Infinity,  \n      addEventListener: () => { }  \n    };  \n    // Override the method to always return mock battery info.  \n    window.navigator.getBattery = async () => mockBattery;  \n  });  \n});  \n  \ntest('show battery status', async ({ page }) => {  \n  await page.goto('/');  \n  await expect(page.locator('.battery-percentage')).toHaveText('90%');  \n  await expect(page.locator('.battery-status')).toHaveText('Adapter');  \n  await expect(page.locator('.battery-fully')).toHaveText('00:30');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock-browser-apis"}}
{"instruction": "Generate a Playwright test for the following scenario: Create `playwright/fixtures.ts` file that will [override `storageState` fixture](/docs/test-fixtures#overriding-fixtures) to authenticate once per worker. Use [testInfo.parallelIndex](/docs/api/class-testinfo#test-info-parallel-index) to differentiate between workers. | playwright/fixtures.ts", "input": "", "output": "import { test as baseTest, expect } from '@playwright/test';  \nimport fs from 'fs';  \nimport path from 'path';  \n  \nexport * from '@playwright/test';  \nexport const test = baseTest.extend<{}, { workerStorageState: string }>({  \n  // Use the same storage state for all tests in this worker.  \n  storageState: ({ workerStorageState }, use) => use(workerStorageState),  \n  \n  // Authenticate once per worker with a worker-scoped fixture.  \n  workerStorageState: [async ({ browser }, use) => {  \n    // Use parallelIndex as a unique identifier for each worker.  \n    const id = test.info().parallelIndex;  \n    const fileName = path.resolve(test.info().project.outputDir, `.auth/${id}.json`);  \n  \n    if (fs.existsSync(fileName)) {  \n      // Reuse existing authentication state if any.  \n      await use(fileName);  \n      return;  \n    }  \n  \n    // Important: make sure we authenticate in a clean environment by unsetting storage state.  \n    const page = await browser.newPage({ storageState: undefined });  \n  \n    // Acquire a unique account, for example create a new one.  \n    // Alternatively, you can have a list of precreated accounts for testing.  \n    // Make sure that accounts are unique, so that multiple team members  \n    // can run tests at the same time without interference.  \n    const account = await acquireAccount(id);  \n  \n    // Perform authentication steps. Replace these actions with your own.  \n    await page.goto('https://github.com/login');  \n    await page.getByLabel('Username or email address').fill(account.username);  \n    await page.getByLabel('Password').fill(account.password);  \n    await page.getByRole('button', { name: 'Sign in' }).click();  \n    // Wait until the page receives the cookies.  \n    //  \n    // Sometimes login flow sets cookies in the process of several redirects.  \n    // Wait for the final URL to ensure that the cookies are actually set.  \n    await page.waitForURL('https://github.com/');  \n    // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n    await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n    // End of authentication steps.  \n  \n    await page.context().storageState({ path: fileName });  \n    await page.close();  \n    await use(fileName);  \n  }, { scope: 'worker' }],  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.beforeEach(async ({ context }) => {  \n  // Block any css requests for each test in this file.  \n  await context.route(/.css$/, route => route.abort());  \n});  \n  \ntest('loads page without css', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  // ... test goes here  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/network", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Now **disable parallel execution** by setting workers to one, and specify your test list file. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  workers: 1,  \n  testMatch: 'test.list.ts',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Generate a Playwright test for the following scenario: Use a regular expression:", "input": "", "output": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: /Product 2/ })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "Now, each test file should import `test` from our fixtures file instead of `@playwright/test`. No changes are needed in the config. | tests/example.spec.ts", "output": "// Important: import our fixtures.  \nimport { test, expect } from '../playwright/fixtures';  \n  \ntest('test', async ({ page }) => {  \n  // page is authenticated  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/auth", "type": "fixture"}}
{"instruction": "Generate a Playwright test for the following scenario: Extensions only work in Chrome / Chromium launched with a persistent context. Use custom browser args at your own risk, as some of them may break Playwright functionality. | The following is code for getting a handle to the [background page](https://developer.chrome.com/extensions/background_pages) of a [Manifest v2](https://developer.chrome.com/docs/extensions/mv2/) extension whose source is located in `./my-extension`:", "input": "", "output": "const { chromium } = require('playwright');  \n  \n(async () => {  \n  const pathToExtension = require('path').join(__dirname, 'my-extension');  \n  const userDataDir = '/tmp/test-user-data-dir';  \n  const browserContext = await chromium.launchPersistentContext(userDataDir, {  \n    headless: false,  \n    args: [  \n      `--disable-extensions-except=${pathToExtension}`,  \n      `--load-extension=${pathToExtension}`  \n    ]  \n  });  \n  let [backgroundPage] = browserContext.backgroundPages();  \n  if (!backgroundPage)  \n    backgroundPage = await browserContext.waitForEvent('backgroundpage');  \n  \n  // Test the background page as you would any other page.  \n  await browserContext.close();  \n})();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/chrome-extensions"}}
{"instruction": "Generate a Playwright test for the following scenario: The [locator.ariaSnapshot()](/docs/api/class-locator#locator-aria-snapshot) method allows you to programmatically create a YAML representation of accessible elements within a locator\u2019s scope, especially helpful for generating snapshots dynamically during test execution. | **Example** :", "input": "", "output": "const snapshot = await page.locator('body').ariaSnapshot();  \nconsole.log(snapshot);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/aria-snapshots"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \nexport default function createTests() {  \n  test.use({ viewport: { width: 500, height: 500 } });  \n  \n  test('feature-b example test', async ({ page }) => {  \n    // ... test goes here  \n  });  \n}", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parallel", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('event', async ({ mount }) => {  \n  const component = await mount(Component, { on: { click() {} } });  \n});", "output": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('event', async ({ mount }) => {  \n  const component = await mount(Component, { on: { click() {} } });  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  assert: {  \n    toHaveScreenshot: { maxDiffPixels: 100 },  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  expect: {  \n    toHaveScreenshot: { maxDiffPixels: 100 },  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest('context fetch', async ({ page }) => {  \n  // Do a GET request on behalf of page  \n  const response = await page.request.get('http://example.com/foo.json');  \n  // ...  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('context fetch', async ({ page }) => {  \n  // Do a GET request on behalf of page  \n  const response = await page.request.get('http://example.com/foo.json');  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Here is the easiest way to obtain a [JSHandle](/docs/api/class-jshandle \"JSHandle\").", "output": "const jsHandle = await page.evaluateHandle('window');  \n//  Use jsHandle for evaluations.", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/handles"}}
{"instruction": "Generate a Playwright test for the following scenario: component.spec.tsx", "input": "", "output": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('children', async ({ mount }) => {  \n  const component = await mount(<Component>Child</Component>);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Instead, create a _fingerprint_ of the violation(s) in question that contains only enough information to uniquely identify the issue, and use a snapshot of the fingerprint:", "output": "// This is less fragile than snapshotting the entire violations array.  \nexpect(violationFingerprints(accessibilityScanResults)).toMatchSnapshot();  \n  \n// my-test-utils.js  \nfunction violationFingerprints(accessibilityScanResults) {  \n  const violationFingerprints = accessibilityScanResults.violations.map(violation => ({  \n    rule: violation.id,  \n    // These are CSS selectors which uniquely identify each element with  \n    // a violation of the rule in question.  \n    targets: violation.nodes.map(node => node.target),  \n  }));  \n  \n  return JSON.stringify(violationFingerprints, null, 2);  \n}", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { mergeTests } from '@playwright/test';  \nimport { test as dbTest } from 'database-test-utils';  \nimport { test as a11yTest } from 'a11y-test-utils';  \n  \nexport const test = mergeTests(dbTest, a11yTest);", "output": "import { mergeTests } from '@playwright/test';  \nimport { test as dbTest } from 'database-test-utils';  \nimport { test as a11yTest } from 'a11y-test-utils';  \n  \nexport const test = mergeTests(dbTest, a11yTest);", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect(page  \n    .getByRole('listitem'))  \n    .toHaveText(['apple', 'banana', 'orange']);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "component.spec.tsx", "output": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('unmount', async ({ mount }) => {  \n  const component = await mount(<Component/>);  \n  await component.unmount();  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "Below we'll create an `account` fixture that will be shared by all tests in the same worker, and override the `page` fixture to login into this account for each test. To generate unique accounts, we'll use the [workerInfo.workerIndex](/docs/api/class-workerinfo#worker-info-worker-index) that is available to any test or fixture. Note the tuple-like syntax for the worker fixture - we have to pass `{scope: 'worker'}` so that test runner sets up this fixture once per worker. | my-test.ts", "output": "import { test as base } from '@playwright/test';  \n  \ntype Account = {  \n  username: string;  \n  password: string;  \n};  \n  \n// Note that we pass worker fixture types as a second template parameter.  \nexport const test = base.extend<{}, { account: Account }>({  \n  account: [async ({ browser }, use, workerInfo) => {  \n    // Unique username.  \n    const username = 'user' + workerInfo.workerIndex;  \n    const password = 'verysecure';  \n  \n    // Create the account with Playwright.  \n    const page = await browser.newPage();  \n    await page.goto('/signup');  \n    await page.getByLabel('User Name').fill(username);  \n    await page.getByLabel('Password').fill(password);  \n    await page.getByText('Sign up').click();  \n    // Make sure everything is ok.  \n    await expect(page.getByTestId('result')).toHaveText('Success');  \n    // Do not forget to cleanup.  \n    await page.close();  \n  \n    // Use the account value.  \n    await use({ username, password });  \n  }, { scope: 'worker' }],  \n  \n  page: async ({ page, account }, use) => {  \n    // Sign in with our account.  \n    const { username, password } = account;  \n    await page.goto('/signin');  \n    await page.getByLabel('User Name').fill(username);  \n    await page.getByLabel('Password').fill(password);  \n    await page.getByText('Sign in').click();  \n    await expect(page.getByTestId('userinfo')).toHaveText(username);  \n  \n    // Use signed-in page in the test.  \n    await use(page);  \n  },  \n});  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/experimental-ct-react';  \nimport App from './App';  \n  \n// Let's test component in a dark scheme!  \ntest.use({ colorScheme: 'dark' });  \n  \ntest('should render', async ({ mount }) => {  \n  const component = await mount(<App></App>);  \n  \n  // As with any Playwright test, assert locator text.  \n  await assert(component).toContainText('React');  \n  // Or do a screenshot \ud83d\ude80  \n  await assert(component).toHaveScreenshot();  \n  // Or use any Playwright method  \n  await component.click();  \n});", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport App from './App';  \n  \n// Let's test component in a dark scheme!  \ntest.use({ colorScheme: 'dark' });  \n  \ntest('should render', async ({ mount }) => {  \n  const component = await mount(<App></App>);  \n  \n  // As with any Playwright test, assert locator text.  \n  await expect(component).toContainText('React');  \n  // Or do a screenshot \ud83d\ude80  \n  await expect(component).toHaveScreenshot();  \n  // Or use any Playwright method  \n  await component.click();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Negating matchers\u200b | In general, we can expect the opposite to be true by adding a `.not` to the front of the matchers:", "input": "", "output": "expect(value).not.toEqual(0);  \nawait expect(locator).not.toContainText('some text');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['json', { outputFile: 'results.json' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: If you would like to annotate your tests with something more substantial than a tag, you can do that when declaring a test. Annotations have a `type` and a `description` for more context and available in reporter API. Playwright's built-in HTML reporter shows all annotations, except those where `type` starts with `_` symbol. | For example, to annotate a test with an issue url:", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('test login page', {  \n  annotation: {  \n    type: 'issue',  \n    description: 'https://github.com/microsoft/playwright/issues/23180',  \n  },  \n}, async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Interactions\u200b | Performing actions starts with locating the elements. Playwright uses [Locators API](/docs/locators) for that. Locators represent a way to find element(s) on the page at any moment, learn more about the [different types](/docs/locators) of locators available. Playwright will wait for the element to be [actionable](/docs/actionability) prior to performing the action, so there is no need to wait for it to become available.", "output": "// Create a locator.  \nconst getStarted = page.getByRole('link', { name: 'Get started' });  \n  \n// Click it.  \nawait getStarted.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/writing-tests", "type": "navigation"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "Now, each test file should import `test` from our fixtures file instead of `@playwright/test`. No changes are needed in the config. | tests/example.spec.ts", "output": "// Important: import our fixtures.  \nimport { test, expect } from '../playwright/fixtures';  \n  \ntest('test', async ({ page }) => {  \n  // page is authenticated  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Scrolls automatically so that button is visible  \nawait page.getByRole('button').click();", "output": "// Scrolls automatically so that button is visible  \nawait page.getByRole('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.getByText('Details').click();  \n\n\n\n<x-details role=button aria-expanded=true aria-controls=inner-details>  \n  <div>Title</div>  \n  #shadow-root  \n    <div id=inner-details>Details</div>  \n</x-details>", "output": "await page.getByText('Details').click();  \n\n\n\n<x-details role=button aria-expanded=true aria-controls=inner-details>  \n  <div>Title</div>  \n  #shadow-root  \n    <div id=inner-details>Details</div>  \n</x-details>", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from './webView2Test';  \n  \ntest('test WebView2', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  const getStarted = page.getByText('Get Started');  \n  await expect(getStarted).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/webview2", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// WRONG: THIS SNIPPET DOES NOT WORK SINCE v1.18.  \n  \n// fixtures.js  \nconst test = base.extend({  \n  myParameter: 'default',  \n});  \n  \n// playwright.config.js  \nmodule.exports = {  \n  use: {  \n    myParameter: 'value',  \n  },  \n};", "output": "// WRONG: THIS SNIPPET DOES NOT WORK SINCE v1.18.  \n  \n// fixtures.js  \nconst test = base.extend({  \n  myParameter: 'default',  \n});  \n  \n// playwright.config.js  \nmodule.exports = {  \n  use: {  \n    myParameter: 'value',  \n  },  \n};", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest.describe('group', {  \n  tag: '@report',  \n}, () => {  \n  test('test report header', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('test full report', {  \n    tag: ['@slow', '@vrt'],  \n  }, async ({ page }) => {  \n    // ...  \n  });  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('group', {  \n  tag: '@report',  \n}, () => {  \n  test('test report header', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('test full report', {  \n    tag: ['@slow', '@vrt'],  \n  }, async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Retry blocks of code until all assertions pass:", "output": "await expect(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  await expect(response).toBeOK();  \n}).toPass();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  fullyParallel: true,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Wait for popup window:", "input": "", "output": "// Start waiting for popup before clicking. Note no await.  \nconst popupPromise = page.waitForEvent('popup');  \nawait page.getByText('open the popup').click();  \nconst popup = await popupPromise;  \nawait popup.goto('https://wikipedia.org');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/events"}}
{"instruction": "Generate a Playwright test for the following scenario: my-test.js", "input": "", "output": "const base = require('@playwright/test');  \n  \nexports.test = base.test.extend({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  person: ['John', { option: true }],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "You can locate the element by its test id:", "output": "await page.getByTestId('directions').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// A primitive value.  \nawait page.evaluate(num => num, 42);  \n  \n// An array.  \nawait page.evaluate(array => array.length, [1, 2, 3]);  \n  \n// An object.  \nawait page.evaluate(object => object.foo, { foo: 'bar' });  \n  \n// A single handle.  \nconst button = await page.evaluateHandle('window.button');  \nawait page.evaluate(button => button.textContent, button);  \n  \n// Alternative notation using JSHandle.evaluate.  \nawait button.evaluate((button, from) => button.textContent.substring(from), 5);  \n  \n// Object with multiple handles.  \nconst button1 = await page.evaluateHandle('window.button1');  \nconst button2 = await page.evaluateHandle('window.button2');  \nawait page.evaluate(  \n    o => o.button1.textContent + o.button2.textContent,  \n    { button1, button2 });  \n  \n// Object destructuring works. Note that property names must match  \n// between the destructured object and the argument.  \n// Also note the required parenthesis.  \nawait page.evaluate(  \n    ({ button1, button2 }) => button1.textContent + button2.textContent,  \n    { button1, button2 });  \n  \n// Array works as well. Arbitrary names can be used for destructuring.  \n// Note the required parenthesis.  \nawait page.evaluate(  \n    ([b1, b2]) => b1.textContent + b2.textContent,  \n    [button1, button2]);  \n  \n// Any mix of serializables and handles works.  \nawait page.evaluate(  \n    x => x.button1.textContent + x.list[0].textContent + String(x.foo),  \n    { button1, list: [button2], foo: null });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/evaluating", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Grants specified permissions to the browser context.  \n    permissions: ['notifications'],  \n  },  \n});  \n\n\n\nconst context = await browser.newContext({  \n  permissions: ['notifications'],  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/emulation", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Folder for test artifacts such as screenshots, videos, traces, etc.  \n  outputDir: 'test-results',  \n  \n  // path to the global setup files.  \n  globalSetup: require.resolve('./global-setup'),  \n  \n  // path to the global teardown files.  \n  globalTeardown: require.resolve('./global-teardown'),  \n  \n  // Each test is given 30 seconds.  \n  timeout: 30000,  \n  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-configuration", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Capture into buffer\u200b | Rather than writing into a file, you can get a buffer with the image and post-process it or pass it to a third party pixel diff facility.", "input": "", "output": "const buffer = await page.screenshot();  \nconsole.log(buffer.toString('base64'));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/screenshots"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const locator = page.locator('iframe[name=\"embedded\"]');  \n// ...  \nconst frameLocator = locator.contentFrame();  \nawait frameLocator.getByRole('button').click();", "output": "const locator = page.locator('iframe[name=\"embedded\"]');  \n// ...  \nconst frameLocator = locator.contentFrame();  \nawait frameLocator.getByRole('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "XPath union\u200b | Pipe operator (`|`) can be used to specify multiple selectors in XPath. It will match all elements that can be selected by one of the selectors in that list.", "output": "// Waits for either confirmation dialog or load spinner.  \nawait page.locator(  \n    `//span[contains(@class, 'spinner__loading')]|//div[@id='confirmation']`  \n).waitFor();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test for the following scenario: component.spec.ts", "input": "", "output": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(Component);  \n  await component.update({  \n    props: { msg: 'greetings' },  \n    on: { click() {} },  \n    slots: { default: 'Child' }  \n  });  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test for the following scenario: If your application contains many different preexisting violations of a specific rule, you can use [`AxeBuilder.disableRules()`](https://github.com/dequelabs/axe-core-npm/blob/develop/packages/playwright/README.md#axebuilderdisablerulesrules-stringarray) to temporarily disable individual rules until you're able to fix the issues. | You can find the rule IDs to pass to `disableRules()` in the `id` property of the violations you want to suppress. A [complete list of axe's rules](https://github.com/dequelabs/axe-core/blob/master/doc/rule-descriptions.md) can be found in `axe-core`'s documentation.", "input": "", "output": "test('should not have any accessibility violations outside of rules with known issues', async ({  \n  page,  \n}) => {  \n  await page.goto('https://your-site.com/page-with-known-issues');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .disableRules(['duplicate-id'])  \n      .analyze();  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You can also tag all tests in a group or provide multiple tags:", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('group', {  \n  tag: '@report',  \n}, () => {  \n  test('test report header', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('test full report', {  \n    tag: ['@slow', '@vrt'],  \n  }, async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: /Product 2/ })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Conditionally skip a test\u200b | You can skip certain test based on the condition.", "output": "test('skip this test', async ({ page, browserName }) => {  \n  test.skip(browserName === 'firefox', 'Still working on it');  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-annotations"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "example.spec.ts", "output": "import { test as base } from '@playwright/test';  \nimport { TodoPage } from './todo-page';  \n  \n// Extend basic test by providing a \"todoPage\" fixture.  \nconst test = base.extend<{ todoPage: TodoPage }>({  \n  todoPage: async ({ page }, use) => {  \n    const todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo('item1');  \n    await todoPage.addToDo('item2');  \n    await use(todoPage);  \n    await todoPage.removeAll();  \n  },  \n});  \n  \ntest('should add an item', async ({ todoPage }) => {  \n  await todoPage.addToDo('my item');  \n  // ...  \n});  \n  \ntest('should remove an item', async ({ todoPage }) => {  \n  await todoPage.remove('item1');  \n  // ...  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "For example, `text=\"Log\"` does not match `<button>Log in</button>` because `<button>` contains a single text node `\"Log in\"` that is not equal to `\"Log\"`. However, `text=\"Log\"` matches `<button> Log <span>in</span></button>`, because `<button>` contains a text node `\" Log \"`. This exact mode implies case-sensitive matching, so `text=\"Download\"` will not match `<button>download</button>`. | Quoted body follows the usual escaping rules, e.g. use `\\\"` to escape double quote in a double-quoted string: `text=\"foo\\\"bar\"`.", "output": "await page.locator('text=\"Log in\"').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test for the following scenario: Playwright Test comes with the built-in `request` fixture that respects configuration options like `baseURL` or `extraHTTPHeaders` we specified and is ready to send some requests. | Now we can add a few tests that will create new issues in the repository.", "input": "", "output": "const REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \ntest('should create a bug report', async ({ request }) => {  \n  const newIssue = await request.post(`/repos/${USER}/${REPO}/issues`, {  \n    data: {  \n      title: '[Bug] report 1',  \n      body: 'Bug description',  \n    }  \n  });  \n  expect(newIssue.ok()).toBeTruthy();  \n  \n  const issues = await request.get(`/repos/${USER}/${REPO}/issues`);  \n  expect(issues.ok()).toBeTruthy();  \n  expect(await issues.json()).toContainEqual(expect.objectContaining({  \n    title: '[Bug] report 1',  \n    body: 'Bug description'  \n  }));  \n});  \n  \ntest('should create a feature request', async ({ request }) => {  \n  const newIssue = await request.post(`/repos/${USER}/${REPO}/issues`, {  \n    data: {  \n      title: '[Feature] request 1',  \n      body: 'Feature description',  \n    }  \n  });  \n  expect(newIssue.ok()).toBeTruthy();  \n  \n  const issues = await request.get(`/repos/${USER}/${REPO}/issues`);  \n  expect(issues.ok()).toBeTruthy();  \n  expect(await issues.json()).toContainEqual(expect.objectContaining({  \n    title: '[Feature] request 1',  \n    body: 'Feature description'  \n  }));  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/api-testing"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "You can also chain two locators together, for example to find a \"Save\" button inside a particular dialog:", "output": "const saveButton = page.getByRole('button', { name: 'Save' });  \n// ...  \nconst dialog = page.getByTestId('settings-dialog');  \nawait dialog.locator(saveButton).click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.locator(  \n    '#tsf > div:nth-child(2) > div.A8SBwf > div.RNNXgb > div > div.a4bIc > input'  \n).click();  \n  \nawait page  \n    .locator('//*[@id=\"tsf\"]/div[2]/div[1]/div[1]/div/div[2]/input')  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    screenshot: {  \n      mode: 'only-on-failure',  \n      fullPage: true,  \n    }  \n  }  \n});", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    screenshot: {  \n      mode: 'only-on-failure',  \n      fullPage: true,  \n    }  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test('\u2026', async ({ mount, page, context }) => {  \n  // \u2026  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You can match it using the following snapshot template:", "output": "await expect(page.locator('body')).toMatchAriaSnapshot(`  \n  - heading \"title\"  \n`);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/aria-snapshots"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "test('records or updates the HAR file', async ({ page }) => {  \n  // Get the response from the HAR file  \n  await page.routeFromHAR('./hars/fruit.har', {  \n    url: '*/**/api/v1/fruits',  \n    update: true,  \n  });  \n  \n  // Go to the page  \n  await page.goto('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the fruit is visible  \n  await expect(page.getByText('Strawberry')).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest.beforeAll(async () => {  \n  // Set timeout for this hook.  \n  test.setTimeout(60000);  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.beforeAll(async () => {  \n  // Set timeout for this hook.  \n  test.setTimeout(60000);  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-timeouts", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  colorScheme: 'dark' // or 'light'  \n});  \n  \ntest('my test with dark mode', async ({ page }) => {  \n  // ...  \n});  \n\n\n\n// Create context with dark mode  \nconst context = await browser.newContext({  \n  colorScheme: 'dark' // or 'light'  \n});  \n  \n// Create page with dark mode  \nconst page = await browser.newPage({  \n  colorScheme: 'dark' // or 'light'  \n});  \n  \n// Change color scheme for the page  \nawait page.emulateMedia({ colorScheme: 'dark' });  \n  \n// Change media for page  \nawait page.emulateMedia({ media: 'print' });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: You can also [filter locators](/docs/locators#filtering-locators) by text or by another locator.", "input": "", "output": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: 'Product 2' })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/best-practices"}}
{"instruction": "Generate a Playwright test for the following scenario: component.spec.tsx", "input": "", "output": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('unmount', async ({ mount }) => {  \n  const component = await mount(<Component/>);  \n  await component.unmount();  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "const { test } = require('@playwright/test');  \nconst { TodoPage } = require('./todo-page');  \n  \ntest.describe('todo tests', () => {  \n  let todoPage;  \n  \n  test.beforeEach(async ({ page }) => {  \n    todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo('item1');  \n    await todoPage.addToDo('item2');  \n  });  \n  \n  test.afterEach(async () => {  \n    await todoPage.removeAll();  \n  });  \n  \n  test('should add an item', async () => {  \n    await todoPage.addToDo('my item');  \n    // ...  \n  });  \n  \n  test('should remove an item', async () => {  \n    await todoPage.remove('item1');  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-fixtures", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// \ud83d\udc4d  \nawait expect(page.getByText('welcome')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/best-practices", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "N-th element locator\u200b | You can narrow down query to the n-th match using the `nth=` locator passing a zero-based index.", "output": "// Click first button  \nawait page.locator('button').locator('nth=0').click();  \n  \n// Click last button  \nawait page.locator('button').locator('nth=-1').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Select one file  \nawait page.getByLabel('Upload file').setInputFiles(path.join(__dirname, 'myfile.pdf'));  \n  \n// Select multiple files  \nawait page.getByLabel('Upload files').setInputFiles([  \n  path.join(__dirname, 'file1.txt'),  \n  path.join(__dirname, 'file2.txt'),  \n]);  \n  \n// Select a directory  \nawait page.getByLabel('Upload directory').setInputFiles(path.join(__dirname, 'mydir'));  \n  \n// Remove all the selected files  \nawait page.getByLabel('Upload file').setInputFiles([]);  \n  \n// Upload buffer from memory  \nawait page.getByLabel('Upload file').setInputFiles({  \n  name: 'file.txt',  \n  mimeType: 'text/plain',  \n  buffer: Buffer.from('this is test')  \n});", "output": "// Select one file  \nawait page.getByLabel('Upload file').setInputFiles(path.join(__dirname, 'myfile.pdf'));  \n  \n// Select multiple files  \nawait page.getByLabel('Upload files').setInputFiles([  \n  path.join(__dirname, 'file1.txt'),  \n  path.join(__dirname, 'file2.txt'),  \n]);  \n  \n// Select a directory  \nawait page.getByLabel('Upload directory').setInputFiles(path.join(__dirname, 'mydir'));  \n  \n// Remove all the selected files  \nawait page.getByLabel('Upload file').setInputFiles([]);  \n  \n// Upload buffer from memory  \nawait page.getByLabel('Upload file').setInputFiles({  \n  name: 'file.txt',  \n  mimeType: 'text/plain',  \n  buffer: Buffer.from('this is test')  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/input", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert(page.getByRole('heading', { name: 'Sign up' })).toBeVisible();  \n  \nawait page.getByRole('checkbox', { name: 'Subscribe' }).check();  \n  \nawait page.getByRole('button', { name: /submit/i }).click();", "output": "await expect(page.getByRole('heading', { name: 'Sign up' })).toBeVisible();  \n  \nawait page.getByRole('checkbox', { name: 'Subscribe' }).check();  \n  \nawait page.getByRole('button', { name: /submit/i }).click();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "Establishing preconditions\u200b | The following test creates a new issue via API and then navigates to the list of all issues in the project to check that it appears at the top of the list.", "output": "import { test, expect } from '@playwright/test';  \n  \nconst REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \n// Request context is reused by all tests in the file.  \nlet apiContext;  \n  \ntest.beforeAll(async ({ playwright }) => {  \n  apiContext = await playwright.request.newContext({  \n    // All requests we send go to this API endpoint.  \n    baseURL: 'https://api.github.com',  \n    extraHTTPHeaders: {  \n      // We set this header per GitHub guidelines.  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add authorization token to all requests.  \n      // Assuming personal access token available in the environment.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    },  \n  });  \n});  \n  \ntest.afterAll(async ({ }) => {  \n  // Dispose all responses.  \n  await apiContext.dispose();  \n});  \n  \ntest('last created issue should be first in the list', async ({ page }) => {  \n  const newIssue = await apiContext.post(`/repos/${USER}/${REPO}/issues`, {  \n    data: {  \n      title: '[Feature] request 1',  \n    }  \n  });  \n  expect(newIssue.ok()).toBeTruthy();  \n  \n  await page.goto(`https://github.com/${USER}/${REPO}/issues`);  \n  const firstIssue = page.locator(`a[data-hovercard-type='issue']`).first();  \n  await expect(firstIssue).toHaveText('[Feature] request 1');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/api-testing"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test.describe('chromium only', () => {  \n  test.skip(({ browserName }) => browserName !== 'chromium', 'Chromium only!');  \n  \n  test.beforeAll(async () => {  \n    // This hook is only run in Chromium.  \n  });  \n  \n  test('test 1', async ({ page }) => {  \n    // This test is only run in Chromium.  \n  });  \n  \n  test('test 2', async ({ page }) => {  \n    // This test is only run in Chromium.  \n  });  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-annotations", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('basic test', async ({ page }) => {  \n  await page.goto('https://playwright.dev', { timeout: 30000 });  \n  await page.getByText('Get Started').click({ timeout: 10000 });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: Test inactivity monitoring\u200b | Inactivity monitoring is a common feature in web applications that logs out users after a period of inactivity. Testing this feature can be tricky because you need to wait for a long time to see the effect. With the help of the clock, you can speed up time and test this feature quickly.", "input": "", "output": "<div id=\"remaining-time\" data-testid=\"remaining-time\"></div>  \n<script>  \n  const endTime = Date.now() + 5 * 60_000;  \n  const renderTime = () => {  \n    const diffInSeconds = Math.round((endTime - Date.now()) / 1000);  \n    if (diffInSeconds <= 0) {  \n      document.getElementById('remaining-time').textContent =  \n        'You have been logged out due to inactivity.';  \n    } else {  \n      document.getElementById('remaining-time').textContent =  \n        `You will be logged out in ${diffInSeconds} seconds.`;  \n    }  \n    setTimeout(renderTime, 1000);  \n  };  \n  renderTime();  \n</script>  \n<button type=\"button\">Interaction</button>  \n\n\n\n// Initial time does not matter for the test, so we can pick current time.  \nawait page.clock.install();  \nawait page.goto('http://localhost:3333');  \n// Interact with the page  \nawait page.getByRole('button').click();  \n  \n// Fast forward time 5 minutes as if the user did not do anything.  \n// Fast forward is like closing the laptop lid and opening it after 5 minutes.  \n// All the timers due will fire once immediately, as in the real browser.  \nawait page.clock.fastForward('05:00');  \n  \n// Check that the user was logged out automatically.  \nawait expect(page.getByText('You have been logged out due to inactivity.')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/clock"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({ locale: 'fr-FR' });  \n  \ntest('example', async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-use-options", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You can locate each element by its implicit role:", "output": "await expect(page.getByRole('heading', { name: 'Sign up' })).toBeVisible();  \n  \nawait page.getByRole('checkbox', { name: 'Subscribe' }).check();  \n  \nawait page.getByRole('button', { name: /submit/i }).click();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.locator('text=/Log\\\\s*in/i').click();", "output": "await page.locator('text=/Log\\\\s*in/i').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Basic Configuration\u200b | Here are some of the most common configuration options.", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Look for test files in the \"tests\" directory, relative to this configuration file.  \n  testDir: 'tests',  \n  \n  // Run all tests in parallel.  \n  fullyParallel: true,  \n  \n  // Fail the build on CI if you accidentally left test.only in the source code.  \n  forbidOnly: !!process.env.CI,  \n  \n  // Retry on CI only.  \n  retries: process.env.CI ? 2 : 0,  \n  \n  // Opt out of parallel tests on CI.  \n  workers: process.env.CI ? 1 : undefined,  \n  \n  // Reporter to use  \n  reporter: 'html',  \n  \n  use: {  \n    // Base URL to use in actions like `await page.goto('/')`.  \n    baseURL: 'http://127.0.0.1:3000',  \n  \n    // Collect trace when retrying the failed test.  \n    trace: 'on-first-retry',  \n  },  \n  // Configure projects for major browsers.  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n    },  \n  ],  \n  // Run your local dev server before starting the tests.  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n  },  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-configuration", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Configure mock API before each test.  \ntest.beforeEach(async ({ page }) => {  \n  await page.addInitScript(() => {  \n    const mockBattery = {  \n      level: 0.90,  \n      charging: true,  \n      chargingTime: 1800, // seconds  \n      dischargingTime: Infinity,  \n      addEventListener: () => { }  \n    };  \n    // Override the method to always return mock battery info.  \n    window.navigator.getBattery = async () => mockBattery;  \n  });  \n});  \n  \ntest('show battery status', async ({ page }) => {  \n  await page.navigate('/');  \n  await assert(page.locator('.battery-percentage')).toHaveText('90%');  \n  await assert(page.locator('.battery-status')).toHaveText('Adapter');  \n  await assert(page.locator('.battery-fully')).toHaveText('00:30');  \n});", "output": "// Configure mock API before each test.  \ntest.beforeEach(async ({ page }) => {  \n  await page.addInitScript(() => {  \n    const mockBattery = {  \n      level: 0.90,  \n      charging: true,  \n      chargingTime: 1800, // seconds  \n      dischargingTime: Infinity,  \n      addEventListener: () => { }  \n    };  \n    // Override the method to always return mock battery info.  \n    window.navigator.getBattery = async () => mockBattery;  \n  });  \n});  \n  \ntest('show battery status', async ({ page }) => {  \n  await page.goto('/');  \n  await expect(page.locator('.battery-percentage')).toHaveText('90%');  \n  await expect(page.locator('.battery-status')).toHaveText('Adapter');  \n  await expect(page.locator('.battery-fully')).toHaveText('00:30');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock-browser-apis", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Get by nth item\u200b | If you have a list of identical elements, and the only way to distinguish between them is the order, you can choose a specific element from a list with [locator.first()](/docs/api/class-locator#locator-first), [locator.last()](/docs/api/class-locator#locator-last) or [locator.nth()](/docs/api/class-locator#locator-nth).", "output": "const banana = await page.getByRole('listitem').nth(1);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test for the following scenario: Add to cart", "input": "", "output": "<ul>  \n  <li>  \n    <h3>Product 1</h3>  \n    <button>Add to cart</button>  \n  </li>  \n  <li>  \n    <h3>Product 2</h3>  \n    <button>Add to cart</button>  \n  </li>  \n</ul>  \n\n\n\nawait page  \n    .getByRole('listitem')  \n    .filter({ has: page.getByRole('heading', { name: 'Product 2' }) })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.getByRole('link', { name: 'Get started' }).click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/writing-tests", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Emulate the user Locale and Timezone which can be set globally for all tests in the config and then overridden for particular tests. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Emulates the user locale.  \n    locale: 'en-GB',  \n  \n    // Emulates the user timezone.  \n    timezoneId: 'Europe/Paris',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Generate a Playwright test for the following scenario: [electronApplication.on('console')](/docs/api/class-electronapplication#electron-application-event-console) event is emitted when Electron main process calls console API methods.", "input": "", "output": "electronApp.on('console', async msg => {  \n  const values = [];  \n  for (const arg of msg.args())  \n    values.push(await arg.jsonValue());  \n  console.log(...values);  \n});  \nawait electronApp.evaluate(() => console.log('hello', 5, { foo: 'bar' }));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: example.spec.ts", "input": "", "output": "import { test, expect } from './webView2Test';  \n  \ntest('test WebView2', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  const getStarted = page.getByText('Get Started');  \n  await expect(getStarted).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/webview2"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.screenshot({ path: 'screenshot.png' });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/screenshots", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "You can also [filter locators](/docs/locators#filtering-locators) by text or by another locator.", "output": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: 'Product 2' })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/best-practices", "type": "navigation"}}
{"instruction": "Generate a Playwright test for the following scenario: If the result is a Promise or if the function is asynchronous evaluate will automatically wait until it's resolved:", "input": "", "output": "const status = await page.evaluate(async () => {  \n  const response = await fetch(location.href);  \n  return response.status;  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/evaluating"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('should use custom proxy on a new context', async ({ browser }) => {  \n  const context = await browser.newContext({  \n    proxy: {  \n      server: 'http://myproxy.com:3128',  \n    }  \n  });  \n  const page = await context.newPage();  \n  \n  await context.close();  \n});  \n\n\n\nconst browser = await chromium.launch();  \nconst context = await browser.newContext({  \n  proxy: { server: 'http://myproxy.com:3128' }  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/network", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend<{}, { forEachWorker: void }>({  \n  forEachWorker: [async ({}, use) => {  \n    // This code runs before all the tests in the worker process.  \n    console.log(`Starting test worker ${test.info().workerIndex}`);  \n    await use();  \n    // This code runs after all the tests in the worker process.  \n    console.log(`Stopping test worker ${test.info().workerIndex}`);  \n  }, { scope: 'worker', auto: true }],  // automatically starts for every worker.  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const parent = page.getByText('Hello').locator('xpath=..');", "output": "const parent = page.getByText('Hello').locator('xpath=..');", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Create new array in page.  \nconst myArrayHandle = await page.evaluateHandle(() => {  \n  window.myArray = [1];  \n  return myArray;  \n});  \n  \n// Get the length of the array.  \nconst length = await page.evaluate(a => a.length, myArrayHandle);  \n  \n// Add one more element to the array using the handle  \nawait page.evaluate(arg => arg.myArray.push(arg.newElement), {  \n  myArray: myArrayHandle,  \n  newElement: 2  \n});  \n  \n// Release the object when it's no longer needed.  \nawait myArrayHandle.dispose();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/handles", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: XPath union\u200b | Pipe operator (`|`) can be used to specify multiple selectors in XPath. It will match all elements that can be selected by one of the selectors in that list.", "input": "", "output": "// Waits for either confirmation dialog or load spinner.  \nawait page.locator(  \n    `//span[contains(@class, 'spinner__loading')]|//div[@id='confirmation']`  \n).waitFor();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test for the following scenario: You can create a custom reporter by implementing a class with some of the reporter methods. Learn more about the [Reporter](/docs/api/class-reporter \"Reporter\") API. | my-awesome-reporter.ts", "input": "", "output": "import type {  \n  FullConfig, FullResult, Reporter, Suite, TestCase, TestResult  \n} from '@playwright/test/reporter';  \n  \nclass MyReporter implements Reporter {  \n  onBegin(config: FullConfig, suite: Suite) {  \n    console.log(`Starting the run with ${suite.allTests().length} tests`);  \n  }  \n  \n  onTestBegin(test: TestCase, result: TestResult) {  \n    console.log(`Starting test ${test.title}`);  \n  }  \n  \n  onTestEnd(test: TestCase, result: TestResult) {  \n    console.log(`Finished test ${test.title}: ${result.status}`);  \n  }  \n  \n  onEnd(result: FullResult) {  \n    console.log(`Finished the run: ${result.status}`);  \n  }  \n}  \n  \nexport default MyReporter;", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Generate a Playwright test for the following scenario: Using dependencies allows global setup to produce traces and other artifacts, see the setup steps in the test report and more. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'setup',  \n      testMatch: /global.setup\\.ts/,  \n    },  \n    {  \n      name: 'chromium',  \n      use: devices['Desktop Chrome'],  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'firefox',  \n      use: devices['Desktop Firefox'],  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'webkit',  \n      use: devices['Desktop Safari'],  \n      dependencies: ['setup'],  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Now you can use a relative path when navigating the page: | test.spec.ts", "output": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  // This will navigate to http://127.0.0.1:3000/login  \n  await page.goto('./login');  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-webserver"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  await expect(response).toBeOK();  \n}).toPass();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    video: {  \n      mode: 'on-first-retry',  \n      size: { width: 640, height: 480 }  \n    }  \n  },  \n});  \n\n\n\nconst context = await browser.newContext({  \n  recordVideo: {  \n    dir: 'videos/',  \n    size: { width: 640, height: 480 },  \n  }  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/videos"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as baseTest, expect } from '@playwright/test';  \nimport fs from 'fs';  \nimport path from 'path';  \n  \nexport * from '@playwright/test';  \nexport const test = baseTest.extend<{}, { workerStorageState: string }>({  \n  // Use the same storage state for all tests in this worker.  \n  storageState: ({ workerStorageState }, use) => use(workerStorageState),  \n  \n  // Authenticate once per worker with a worker-scoped fixture.  \n  workerStorageState: [async ({ browser }, use) => {  \n    // Use parallelIndex as a unique identifier for each worker.  \n    const id = test.info().parallelIndex;  \n    const fileName = path.resolve(test.info().project.outputDir, `.auth/${id}.json`);  \n  \n    if (fs.existsSync(fileName)) {  \n      // Reuse existing authentication state if any.  \n      await use(fileName);  \n      return;  \n    }  \n  \n    // Important: make sure we authenticate in a clean environment by unsetting storage state.  \n    const page = await browser.newPage({ storageState: undefined });  \n  \n    // Acquire a unique account, for example create a new one.  \n    // Alternatively, you can have a list of precreated accounts for testing.  \n    // Make sure that accounts are unique, so that multiple team members  \n    // can run tests at the same time without interference.  \n    const account = await acquireAccount(id);  \n  \n    // Perform authentication steps. Replace these actions with your own.  \n    await page.goto('https://github.com/login');  \n    await page.getByLabel('Username or email address').fill(account.username);  \n    await page.getByLabel('Password').fill(account.password);  \n    await page.getByRole('button', { name: 'Sign in' }).click();  \n    // Wait until the page receives the cookies.  \n    //  \n    // Sometimes login flow sets cookies in the process of several redirects.  \n    // Wait for the final URL to ensure that the cookies are actually set.  \n    await page.waitForURL('https://github.com/');  \n    // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n    await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n    // End of authentication steps.  \n  \n    await page.context().storageState({ path: fileName });  \n    await page.close();  \n    await use(fileName);  \n  }, { scope: 'worker' }],  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/auth", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Read more in [our documentation](/docs/locators#locate-by-role). | New [locator.filter()](/docs/api/class-locator#locator-filter) API to filter an existing locator", "output": "const buttons = page.locator('role=button');  \n// ...  \nconst submitButton = buttons.filter({ hasText: 'Submit' });  \nawait submitButton.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "navigation"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  expect(response.status()).toBe(200);  \n}).toPass({  \n  // Probe, wait 1s, probe, wait 2s, probe, wait 10s, probe, wait 10s, probe  \n  // ... Defaults to [100, 250, 500, 1000].  \n  intervals: [1_000, 2_000, 10_000],  \n  timeout: 60_000  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "completion"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Set the base URL and storage state for all tests: | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Base URL to use in actions like `await page.goto('/')`.  \n    baseURL: 'http://127.0.0.1:3000',  \n  \n    // Populates context with given storage state.  \n    storageState: 'state.json',  \n  },  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-use-options", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/test';  \n  \ntest.describe('suite', () => {  \n  test.beforeAll(async () => { /* ... */ });  \n  test('first good', async ({ page }) => { /* ... */ });  \n  test('second flaky', async ({ page }) => { /* ... */ });  \n  test('third good', async ({ page }) => { /* ... */ });  \n  test.afterAll(async () => { /* ... */ });  \n});", "output": "import { test } from '@playwright/test';  \n  \ntest.describe('suite', () => {  \n  test.beforeAll(async () => { /* ... */ });  \n  test('first good', async ({ page }) => { /* ... */ });  \n  test('second flaky', async ({ page }) => { /* ... */ });  \n  test('third good', async ({ page }) => { /* ... */ });  \n  test.afterAll(async () => { /* ... */ });  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-retries", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: If you are uploading attachments from data folder to other location, you can use `attachmentsBaseURL` option to let html report where to look for them. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['html', { attachmentsBaseURL: 'https://external-storage.com/' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await browserContext.route('**/api/login', route => route.fulfill({  \n  status: 200,  \n  body: 'accept',  \n}));  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from './webView2Test';  \n  \ntest('test WebView2', async ({ page }) => {  \n  await page.navigate('https://playwright.dev');  \n  const getStarted = page.getByText('Get Started');  \n  await assert(getStarted).toBeVisible();  \n});", "output": "import { test, expect } from './webView2Test';  \n  \ntest('test WebView2', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  const getStarted = page.getByText('Get Started');  \n  await expect(getStarted).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/webview2", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "**Accessibility assertions** | [expect(locator).toHaveAccessibleName()](/docs/api/class-locatorassertions#locator-assertions-to-have-accessible-name) checks if the element has the specified accessible name:", "output": "const locator = page.getByRole('button');  \nawait expect(locator).toHaveAccessibleName('Submit');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: `/Log\\s*in/i` \\- body can be a [JavaScript-like regex](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp) wrapped in `/` symbols. For example, `text=/Log\\s*in/i` matches `<button>Login</button>` and `<button>log IN</button>`.", "input": "", "output": "await page.locator('text=/Log\\\\s*in/i').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Remove a header from all requests.  \ntest.beforeEach(async ({ page }) => {  \n  await page.route('**/*', async route => {  \n    const headers = await route.request().allHeaders();  \n    delete headers['if-none-match'];  \n    await route.fallback({ headers });  \n  });  \n});  \n  \ntest('should work', async ({ page }) => {  \n  await page.route('**/*', async route => {  \n    if (route.request().resourceType() === 'image')  \n      await route.abort();  \n    else  \n      await route.fallback();  \n  });  \n});", "output": "// Remove a header from all requests.  \ntest.beforeEach(async ({ page }) => {  \n  await page.route('**/*', async route => {  \n    const headers = await route.request().allHeaders();  \n    delete headers['if-none-match'];  \n    await route.fallback({ headers });  \n  });  \n});  \n  \ntest('should work', async ({ page }) => {  \n  await page.route('**/*', async route => {  \n    if (route.request().resourceType() === 'image')  \n      await route.abort();  \n    else  \n      await route.fallback();  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "<ul>  \n  <li>  \n    <h3>Product 1</h3>  \n    <button>Add to cart</button>  \n  </li>  \n  <li>  \n    <h3>Product 2</h3>  \n    <button>Add to cart</button>  \n  </li>  \n</ul>  \n\n\n\nawait page  \n    .getByRole('listitem')  \n    .filter({ has: page.getByRole('heading', { name: 'Product 2' }) })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  await expect(page).toHaveScreenshot({ stylePath: path.join(__dirname, 'screenshot.css') });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: In the configuration file: | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Limit the number of workers on CI, use default locally  \n  workers: process.env.CI ? 2 : undefined,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const locator = page.getByText('This interstitial covers the button');  \nawait page.addLocatorHandler(locator, async overlay => {  \n  await overlay.locator('#close').click();  \n}, { times: 3, noWaitAfter: true });  \n// Run your tests that can be interrupted by the overlay.  \n// ...  \nawait page.removeLocatorHandler(locator);", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('should use custom proxy on a new context', async ({ browser }) => {  \n  const context = await browser.newContext({  \n    proxy: {  \n      server: 'http://myproxy.com:3128',  \n    }  \n  });  \n  const page = await context.newPage();  \n  \n  await context.close();  \n});  \n\n\n\nconst browser = await chromium.launch();  \nconst context = await browser.newContext({  \n  proxy: { server: 'http://myproxy.com:3128' }  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/network", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: 'dot',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: 'list',  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: 'list',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { mergeTests } from '@playwright/test';  \nimport { test as dbTest } from 'database-test-utils';  \nimport { test as a11yTest } from 'a11y-test-utils';  \n  \nexport const test = mergeTests(dbTest, a11yTest);", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Behavior Change\u200b | A bunch of Playwright APIs already support the `waitUntil: 'domcontentloaded'` option. For example:", "input": "", "output": "await page.goto('https://playwright.dev', {  \n  waitUntil: 'domcontentloaded',  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as base } from '@playwright/test';  \nimport fs from 'fs';  \nimport os from 'os';  \nimport path from 'path';  \nimport childProcess from 'child_process';  \n  \nconst EXECUTABLE_PATH = path.join(  \n    __dirname,  \n    '../../webview2-app/bin/Debug/net8.0-windows/webview2.exe',  \n);  \n  \nexport const test = base.extend({  \n  browser: async ({ playwright }, use, testInfo) => {  \n    const cdpPort = 10000 + testInfo.workerIndex;  \n    // Make sure that the executable exists and is executable  \n    fs.accessSync(EXECUTABLE_PATH, fs.constants.X_OK);  \n    const userDataDir = path.join(  \n        fs.realpathSync.native(os.tmpdir()),  \n        `playwright-webview2-tests/user-data-dir-${testInfo.workerIndex}`,  \n    );  \n    const webView2Process = childProcess.spawn(EXECUTABLE_PATH, [], {  \n      shell: true,  \n      env: {  \n        ...process.env,  \n        WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS: `--remote-debugging-port=${cdpPort}`,  \n        WEBVIEW2_USER_DATA_FOLDER: userDataDir,  \n      }  \n    });  \n    await new Promise<void>(resolve => webView2Process.stdout.on('data', data => {  \n      if (data.toString().includes('WebView2 initialized'))  \n        resolve();  \n    }));  \n    const browser = await playwright.chromium.connectOverCDP(`http://127.0.0.1:${cdpPort}`);  \n    await use(browser);  \n    await browser.close();  \n    childProcess.execSync(`taskkill /pid ${webView2Process.pid} /T /F`);  \n    fs.rmdirSync(userDataDir, { recursive: true });  \n  },  \n  context: async ({ browser }, use) => {  \n    const context = browser.contexts()[0];  \n    await use(context);  \n  },  \n  page: async ({ context }, use) => {  \n    const page = context.pages()[0];  \n    await use(page);  \n  },  \n});  \n  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/webview2", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.screenshot({ path: 'screenshot.png', fullPage: true });", "output": "await page.screenshot({ path: 'screenshot.png', fullPage: true });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/screenshots", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Now we can use `toHaveAmount` in the test. | example.spec.ts", "input": "", "output": "import { test, expect } from './fixtures';  \n  \ntest('amount', async () => {  \n  await expect(page.locator('.cart')).toHaveAmount(4);  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  await test.step('Log in', async () => {  \n    // ...  \n  });  \n  await test.step('news feed', async () => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Then test the component via testing the story: | input-media.spec.tsx", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport { InputMediaForTest } from './input-media.story.tsx';  \n  \ntest('changes the image', async ({ mount }) => {  \n  let mediaSelected: string | null = null;  \n  \n  const component = await mount(  \n    <InputMediaForTest  \n      onMediaChange={mediaName => {  \n        mediaSelected = mediaName;  \n      }}  \n    />  \n  );  \n  await component  \n    .getByTestId('imageInput')  \n    .setInputFiles('src/assets/logo.png');  \n  \n  await expect(component.getByAltText(/selected image/i)).toBeVisible();  \n  await expect.poll(() => mediaSelected).toBe('logo.png');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const { test } = require('@playwright/test');  \nconst { TodoPage } = require('./todo-page');  \n  \ntest.describe('todo tests', () => {  \n  let todoPage;  \n  \n  test.beforeEach(async ({ page }) => {  \n    todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo('item1');  \n    await todoPage.addToDo('item2');  \n  });  \n  \n  test.afterEach(async () => {  \n    await todoPage.removeAll();  \n  });  \n  \n  test('should add an item', async () => {  \n    await todoPage.addToDo('my item');  \n    // ...  \n  });  \n  \n  test('should remove an item', async () => {  \n    await todoPage.remove('item1');  \n    // ...  \n  });  \n});", "output": "const { test } = require('@playwright/test');  \nconst { TodoPage } = require('./todo-page');  \n  \ntest.describe('todo tests', () => {  \n  let todoPage;  \n  \n  test.beforeEach(async ({ page }) => {  \n    todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo('item1');  \n    await todoPage.addToDo('item2');  \n  });  \n  \n  test.afterEach(async () => {  \n    await todoPage.removeAll();  \n  });  \n  \n  test('should add an item', async () => {  \n    await todoPage.addToDo('my item');  \n    // ...  \n  });  \n  \n  test('should remove an item', async () => {  \n    await todoPage.remove('item1');  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Replaying from HAR\u200b | Now that you have the HAR file recorded and modified the mock data, it can be used to serve matching responses in the test. For this, just turn off or simply remove the `update` option. This will run the test against the HAR file instead of hitting the API.", "input": "", "output": "test('gets the json from HAR and checks the new fruit has been added', async ({ page }) => {  \n  // Replay API requests from HAR.  \n  // Either use a matching response from the HAR,  \n  // or abort the request if nothing matches.  \n  await page.routeFromHAR('./hars/fruit.har', {  \n    url: '*/**/api/v1/fruits',  \n    update: false,  \n  });  \n  \n  // Go to the page  \n  await page.goto('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the Playwright fruit is visible  \n  await expect(page.getByText('Playwright', { exact: true })).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "// Make a few checks that will not stop the test when failed...  \nawait expect.soft(page.locator('#status')).toHaveText('Success');  \nawait expect.soft(page.locator('#eta')).toHaveText('1 day');  \n  \n// ... and continue the test to check more things.  \nawait page.locator('#next-page').click();  \nawait expect.soft(page.locator('#title')).toHaveText('Make another order');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "XPath and CSS selectors can be tied to the DOM structure or implementation. These selectors can break when the DOM structure changes. Long CSS or XPath chains below are an example of a **bad practice** that leads to unstable tests:", "output": "await page.locator(  \n    '#tsf > div:nth-child(2) > div.A8SBwf > div.RNNXgb > div > div.a4bIc > input'  \n).click();  \n  \nawait page  \n    .locator('//*[@id=\"tsf\"]/div[2]/div[1]/div[1]/div/div[2]/input')  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest('basic test', async ({ page }) => {  \n  await page.navigate('https://playwright.dev', { timeout: 30000 });  \n  await page.getByText('Get Started').click({ timeout: 10000 });  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('basic test', async ({ page }) => {  \n  await page.goto('https://playwright.dev', { timeout: 30000 });  \n  await page.getByText('Get Started').click({ timeout: 10000 });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "// Check the checkbox  \nawait page.getByLabel('I agree to the terms above').check();  \n  \n// Assert the checked state  \nexpect(page.getByLabel('Subscribe to newsletter')).toBeChecked();  \n  \n// Select the radio button  \nawait page.getByLabel('XL').check();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/input", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'], channel: 'chromium' },  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/browsers", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: example.spec.ts", "input": "", "output": "import { test, type Page } from '@playwright/test';  \n  \ntest.describe.configure({ mode: 'serial' });  \n  \nlet page: Page;  \n  \ntest.beforeAll(async ({ browser }) => {  \n  page = await browser.newPage();  \n});  \n  \ntest.afterAll(async () => {  \n  await page.close();  \n});  \n  \ntest('runs first', async () => {  \n  await page.goto('https://playwright.dev/');  \n});  \n  \ntest('runs second', async () => {  \n  await page.getByText('Get Started').click();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-retries"}}
{"instruction": "Create a Playwright test that demonstrates the page_object pattern.", "input": "Click to expand the code for the `TodoPage` and `SettingsPage` | todo-page.ts", "output": "import type { Page, Locator } from '@playwright/test';  \n  \nexport class TodoPage {  \n  private readonly inputBox: Locator;  \n  private readonly todoItems: Locator;  \n  \n  constructor(public readonly page: Page) {  \n    this.inputBox = this.page.locator('input.new-todo');  \n    this.todoItems = this.page.getByTestId('todo-item');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://demo.playwright.dev/todomvc/');  \n  }  \n  \n  async addToDo(text: string) {  \n    await this.inputBox.fill(text);  \n    await this.inputBox.press('Enter');  \n  }  \n  \n  async remove(text: string) {  \n    const todo = this.todoItems.filter({ hasText: text });  \n    await todo.hover();  \n    await todo.getByLabel('Delete').click();  \n  }  \n  \n  async removeAll() {  \n    while ((await this.todoItems.count()) > 0) {  \n      await this.todoItems.first().hover();  \n      await this.todoItems.getByLabel('Delete').first().click();  \n    }  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.getByLabel('User Name').fill('John');  \n  \nawait page.getByLabel('Password').fill('secret-password');  \n  \nawait page.getByRole('button', { name: 'Sign in' }).click();  \n  \nawait assert(page.getByText('Welcome, John!')).toBeVisible();", "output": "await page.getByLabel('User Name').fill('John');  \n  \nawait page.getByLabel('Password').fill('secret-password');  \n  \nawait page.getByRole('button', { name: 'Sign in' }).click();  \n  \nawait expect(page.getByText('Welcome, John!')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['json', { outputFile: 'results.json' }]],  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['json', { outputFile: 'results.json' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "To click `<x-details>`:", "output": "await page.locator('x-details', { hasText: 'Details' }).click();  \n\n\n\n<x-details role=button aria-expanded=true aria-controls=inner-details>  \n  <div>Title</div>  \n  #shadow-root  \n    <div id=inner-details>Details</div>  \n</x-details>", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "navigation"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Evaluation Argument\u200b | Playwright evaluation methods like [page.evaluate()](/docs/api/class-page#page-evaluate) take a single optional argument. This argument can be a mix of [Serializable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description \"Serializable\") values and [JSHandle](/docs/api/class-jshandle \"JSHandle\") instances. Handles are automatically converted to the value they represent.", "output": "// A primitive value.  \nawait page.evaluate(num => num, 42);  \n  \n// An array.  \nawait page.evaluate(array => array.length, [1, 2, 3]);  \n  \n// An object.  \nawait page.evaluate(object => object.foo, { foo: 'bar' });  \n  \n// A single handle.  \nconst button = await page.evaluateHandle('window.button');  \nawait page.evaluate(button => button.textContent, button);  \n  \n// Alternative notation using JSHandle.evaluate.  \nawait button.evaluate((button, from) => button.textContent.substring(from), 5);  \n  \n// Object with multiple handles.  \nconst button1 = await page.evaluateHandle('window.button1');  \nconst button2 = await page.evaluateHandle('window.button2');  \nawait page.evaluate(  \n    o => o.button1.textContent + o.button2.textContent,  \n    { button1, button2 });  \n  \n// Object destructuring works. Note that property names must match  \n// between the destructured object and the argument.  \n// Also note the required parenthesis.  \nawait page.evaluate(  \n    ({ button1, button2 }) => button1.textContent + button2.textContent,  \n    { button1, button2 });  \n  \n// Array works as well. Arbitrary names can be used for destructuring.  \n// Note the required parenthesis.  \nawait page.evaluate(  \n    ([b1, b2]) => b1.textContent + b2.textContent,  \n    [button1, button2]);  \n  \n// Any mix of serializables and handles works.  \nawait page.evaluate(  \n    x => x.button1.textContent + x.list[0].textContent + String(x.foo),  \n    { button1, list: [button2], foo: null });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/evaluating"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  // page is authenticated  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/auth", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const frameLocator = page.frameLocator('iframe[name=\"embedded\"]');  \n// ...  \nconst locator = frameLocator.owner();  \nawait expect(locator).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test as base, chromium, type BrowserContext } from '@playwright/test';  \nimport path from 'path';  \n  \nexport const test = base.extend<{  \n  context: BrowserContext;  \n  extensionId: string;  \n}>({  \n  context: async ({ }, use) => {  \n    const pathToExtension = path.join(__dirname, 'my-extension');  \n    const context = await chromium.launchPersistentContext('', {  \n      headless: false,  \n      args: [  \n        `--disable-extensions-except=${pathToExtension}`,  \n        `--load-extension=${pathToExtension}`,  \n      ],  \n    });  \n    await use(context);  \n    await context.close();  \n  },  \n  extensionId: async ({ context }, use) => {  \n    /*  \n    // for manifest v2:  \n    let [background] = context.backgroundPages()  \n    if (!background)  \n      background = await context.waitForEvent('backgroundpage')  \n    */  \n  \n    // for manifest v3:  \n    let [background] = context.serviceWorkers();  \n    if (!background)  \n      background = await context.waitForEvent('serviceworker');  \n  \n    const extensionId = background.url().split('/')[2];  \n    await use(extensionId);  \n  },  \n});  \nexport const expect = test.expect;", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/chrome-extensions", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Alternatively, you can record HAR programmatically:", "output": "const context = await browser.newContext({  \n  recordHar: { path: 'github.har.zip' }  \n});  \n// ... do stuff ...  \nawait context.close();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: example.spec.ts", "input": "", "output": "import { test as base } from '@playwright/test';  \nimport { TodoPage } from './todo-page';  \n  \n// Extend basic test by providing a \"todoPage\" fixture.  \nconst test = base.extend<{ todoPage: TodoPage }>({  \n  todoPage: async ({ page }, use) => {  \n    const todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo('item1');  \n    await todoPage.addToDo('item2');  \n    await use(todoPage);  \n    await todoPage.removeAll();  \n  },  \n});  \n  \ntest('should add an item', async ({ todoPage }) => {  \n  await todoPage.addToDo('my item');  \n  // ...  \n});  \n  \ntest('should remove an item', async ({ todoPage }) => {  \n  await todoPage.remove('item1');  \n  // ...  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test for the following scenario: Waiting for navigation\u200b | Clicking an element could trigger multiple navigations. In these cases, it is recommended to explicitly [page.waitForURL()](/docs/api/class-page#page-wait-for-url) to a specific url.", "input": "", "output": "await page.getByText('Click me').click();  \nawait page.waitForURL('**/login');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/navigations"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Wait until all three buttons are visible  \nawait page.locator(':nth-match(:text(\"Buy\"), 3)').waitFor();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: `expect` now supports lots of new web-first assertions. | Consider the following example:", "input": "", "output": "await expect(page.locator('.status')).toHaveText('Submitted');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: JavaScript", "input": "", "output": "import { chromium, devices } from 'playwright';  \nimport assert from 'node:assert';  \n  \n(async () => {  \n  // Setup  \n  const browser = await chromium.launch();  \n  const context = await browser.newContext(devices['iPhone 11']);  \n  const page = await context.newPage();  \n  \n  // The actual interesting bit  \n  await context.route('**.jpg', route => route.abort());  \n  await page.goto('https://example.com/');  \n  \n  assert(await page.title() === 'Example Domain'); // \ud83d\udc4e not a Web First assertion  \n  \n  // Teardown  \n  await context.close();  \n  await browser.close();  \n})();  \n\n\n\nconst assert = require('node:assert');  \nconst { chromium, devices } = require('playwright');  \n  \n(async () => {  \n  // Setup  \n  const browser = await chromium.launch();  \n  const context = await browser.newContext(devices['iPhone 11']);  \n  const page = await context.newPage();  \n  \n  // The actual interesting bit  \n  await context.route('**.jpg', route => route.abort());  \n  await page.goto('https://example.com/');  \n  \n  assert(await page.title() === 'Example Domain'); // \ud83d\udc4e not a Web First assertion  \n  \n  // Teardown  \n  await context.close();  \n  await browser.close();  \n})();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/library"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Print dialogs\u200b | In order to assert that a print dialog via [`window.print`](https://developer.mozilla.org/en-US/docs/Web/API/Window/print) was triggered, you can use the following snippet:", "output": "await page.goto('<url>');  \n  \nawait page.evaluate('(() => {window.waitForPrintDialog = new Promise(f => window.print = f);})()');  \nawait page.getByText('Print it!').click();  \n  \nawait page.waitForFunction('window.waitForPrintDialog');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/dialogs", "type": "navigation"}}
{"instruction": "Generate a Playwright test for the following scenario: Locate an item by the role of \"listitem\" and then filter by the text of \"orange\" and then click it.", "input": "", "output": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: 'orange' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.locator('_vue=book-item').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Set test timeout in the config\u200b | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  timeout: 120_000,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-timeouts"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  testDir: './tests',  \n  // ...  \n  projects: [  \n    {  \n      name: 'setup db',  \n      testMatch: /global\\.setup\\.ts/,  \n    },  \n    {  \n      name: 'chromium with db',  \n      use: { ...devices['Desktop Chrome'] },  \n      dependencies: ['setup db'],  \n    },  \n  ]  \n});", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  testDir: './tests',  \n  // ...  \n  projects: [  \n    {  \n      name: 'setup db',  \n      testMatch: /global\\.setup\\.ts/,  \n    },  \n    {  \n      name: 'chromium with db',  \n      use: { ...devices['Desktop Chrome'] },  \n      dependencies: ['setup db'],  \n    },  \n  ]  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "try {  \n  await page.locator('.foo').waitFor();  \n} catch (e) {  \n  if (e instanceof playwright.errors.TimeoutError) {  \n    // Do something if this is a timeout.  \n  }  \n}", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/api/class-playwright", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Overriding fixtures\u200b | In addition to creating your own fixtures, you can also override existing fixtures to fit your needs. Consider the following example which overrides the `page` fixture by automatically navigating to some `baseURL`:", "input": "", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  page: async ({ baseURL, page }, use) => {  \n    await page.goto(baseURL);  \n    await use(page);  \n  },  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-fixtures"}}
