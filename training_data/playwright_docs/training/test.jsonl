{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest.use({ userAgent: 'My user agent' });  \n  \ntest('my user agent test', async ({ page }) => {  \n  // ...  \n});  \n\n\n\nconst context = await browser.newContext({  \n  userAgent: 'My user agent'  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({ userAgent: 'My user agent' });  \n  \ntest('my user agent test', async ({ page }) => {  \n  // ...  \n});  \n\n\n\nconst context = await browser.newContext({  \n  userAgent: 'My user agent'  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const locator = page.getByRole('button');  \nawait expect(locator).toHaveAccessibleName('Submit');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Use the `webserver` property in your Playwright config to launch a development web server during the tests. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Run your local dev server before starting the tests  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n    stdout: 'ignore',  \n    stderr: 'pipe',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-webserver"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "const button = page.getByRole('button');  \n  \n// Make sure at least some part of element intersects viewport.  \nawait expect(button).toBeInViewport();  \n  \n// Make sure element is fully outside of viewport.  \nawait expect(button).not.toBeInViewport();  \n  \n// Make sure that at least half of the element intersects viewport.  \nawait expect(button).toBeInViewport({ ratio: 0.5 });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await this.webView.EnsureCoreWebView2Async(await CoreWebView2Environment.CreateAsync(null, null, new CoreWebView2EnvironmentOptions()  \n{  \n  AdditionalBrowserArguments = \"--remote-debugging-port=9222\",  \n})).ConfigureAwait(false);", "output": "await this.webView.EnsureCoreWebView2Async(await CoreWebView2Environment.CreateAsync(null, null, new CoreWebView2EnvironmentOptions()  \n{  \n  AdditionalBrowserArguments = \"--remote-debugging-port=9222\",  \n})).ConfigureAwait(false);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/webview2", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.routeWebSocket('wss://example.com/ws', ws => {  \n  ws.onMessage(message => {  \n    if (message === 'request')  \n      ws.send('response');  \n  });  \n});", "output": "await page.routeWebSocket('wss://example.com/ws', ws => {  \n  ws.onMessage(message => {  \n    if (message === 'request')  \n      ws.send('response');  \n  });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/mock", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from './fixtures';  \nimport { expect } from '@playwright/test';  \n  \ntest('basic', async ({ }) => {  \n  // ...  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You can locate the element by the text it contains:", "output": "await expect(page.getByText('Welcome, John')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  tsconfig: './tsconfig.test.json',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-typescript", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Fixtures can also be overridden where the base fixture is completely replaced with something different. For example, we could override the [testOptions.storageState](/docs/api/class-testoptions#test-options-storage-state) fixture to provide our own data.", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  storageState: async ({}, use) => {  \n    const cookie = await getAuthCookie();  \n    await use({ cookies: [cookie] });  \n  },  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test for the following scenario: Navigation\u200b | Most of the tests will start with navigating page to the URL. After that, test will be able to interact with the page elements.", "input": "", "output": "await page.goto('https://playwright.dev/');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/writing-tests"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from './webView2Test';  \n  \ntest('test WebView2', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  const getStarted = page.getByText('Get Started');  \n  await expect(getStarted).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/webview2", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the form_interaction pattern.", "input": "Text input\u200b | Using [locator.fill()](/docs/api/class-locator#locator-fill) is the easiest way to fill out the form fields. It focuses the element and triggers an `input` event with the entered text. It works for `<input>`, `<textarea>` and `[contenteditable]` elements.", "output": "// Text input  \nawait page.getByRole('textbox').fill('Peter');  \n  \n// Date input  \nawait page.getByLabel('Birth date').fill('2020-02-02');  \n  \n// Time input  \nawait page.getByLabel('Appointment time').fill('13:15');  \n  \n// Local datetime input  \nawait page.getByLabel('Local time').fill('2020-03-02T05:15');", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Set action and navigation timeouts in the config\u200b | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    actionTimeout: 10 * 1000,  \n    navigationTimeout: 30 * 1000,  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-timeouts"}}
{"instruction": "Generate a Playwright test for the following scenario: Built-in fixtures\u200b | You have already used test fixtures in your first test.", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('basic test', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  \n  await expect(page).toHaveTitle(/Playwright/);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect(page.getByTitle('Issues count')).toHaveText('25 issues');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test('should not have any automatically detectable WCAG A or AA violations', async ({ page }) => {  \n  await page.navigate('https://your-site.com/');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])  \n      .analyze();  \n  \n  assert(accessibilityScanResults.violations).toEqual([]);  \n});", "output": "test('should not have any automatically detectable WCAG A or AA violations', async ({ page }) => {  \n  await page.goto('https://your-site.com/');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])  \n      .analyze();  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { chromium, devices } from 'playwright';  \nimport assert from 'node:assert';  \n  \n(async () => {  \n  // Setup  \n  const browser = await chromium.launch();  \n  const context = await browser.newContext(devices['iPhone 11']);  \n  const page = await context.newPage();  \n  \n  // The actual interesting bit  \n  await context.route('**.jpg', route => route.abort());  \n  await page.goto('https://example.com/');  \n  \n  assert(await page.title() === 'Example Domain'); // \ud83d\udc4e not a Web First assertion  \n  \n  // Teardown  \n  await context.close();  \n  await browser.close();  \n})();  \n\n\n\nconst assert = require('node:assert');  \nconst { chromium, devices } = require('playwright');  \n  \n(async () => {  \n  // Setup  \n  const browser = await chromium.launch();  \n  const context = await browser.newContext(devices['iPhone 11']);  \n  const page = await context.newPage();  \n  \n  // The actual interesting bit  \n  await context.route('**.jpg', route => route.abort());  \n  await page.goto('https://example.com/');  \n  \n  assert(await page.title() === 'Example Domain'); // \ud83d\udc4e not a Web First assertion  \n  \n  // Teardown  \n  await context.close();  \n  await browser.close();  \n})();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/library", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Establishing preconditions\u200b | The following test creates a new issue via API and then navigates to the list of all issues in the project to check that it appears at the top of the list.", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \nconst REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \n// Request context is reused by all tests in the file.  \nlet apiContext;  \n  \ntest.beforeAll(async ({ playwright }) => {  \n  apiContext = await playwright.request.newContext({  \n    // All requests we send go to this API endpoint.  \n    baseURL: 'https://api.github.com',  \n    extraHTTPHeaders: {  \n      // We set this header per GitHub guidelines.  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add authorization token to all requests.  \n      // Assuming personal access token available in the environment.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    },  \n  });  \n});  \n  \ntest.afterAll(async ({ }) => {  \n  // Dispose all responses.  \n  await apiContext.dispose();  \n});  \n  \ntest('last created issue should be first in the list', async ({ page }) => {  \n  const newIssue = await apiContext.post(`/repos/${USER}/${REPO}/issues`, {  \n    data: {  \n      title: '[Feature] request 1',  \n    }  \n  });  \n  expect(newIssue.ok()).toBeTruthy();  \n  \n  await page.goto(`https://github.com/${USER}/${REPO}/issues`);  \n  const firstIssue = page.locator(`a[data-hovercard-type='issue']`).first();  \n  await expect(firstIssue).toHaveText('[Feature] request 1');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/api-testing"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect(locator).toMatchAriaSnapshot('');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/aria-snapshots", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as setup } from '@playwright/test';  \n  \nconst authFile = 'playwright/.auth/user.json';  \n  \nsetup('authenticate', async ({ request }) => {  \n  // Send authentication request. Replace with your own.  \n  await request.post('https://github.com/login', {  \n    form: {  \n      'user': 'user',  \n      'password': 'password'  \n    }  \n  });  \n  await request.storageState({ path: authFile });  \n});", "output": "import { test as setup } from '@playwright/test';  \n  \nconst authFile = 'playwright/.auth/user.json';  \n  \nsetup('authenticate', async ({ request }) => {  \n  // Send authentication request. Replace with your own.  \n  await request.post('https://github.com/login', {  \n    form: {  \n      'user': 'user',  \n      'password': 'password'  \n    }  \n  });  \n  await request.storageState({ path: authFile });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/auth", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  // \"page\" belongs to an isolated BrowserContext, created for this specific test.  \n});  \n  \ntest('another test', async ({ page }) => {  \n  // \"page\" in this second test is completely isolated from the first test.  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/writing-tests", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test(\"mocks a fruit and doesn't call api\", async ({ page }) => {  \n  // Mock the api call before navigating  \n  await page.route('*/**/api/v1/fruits', async route => {  \n    const json = [{ name: 'Strawberry', id: 21 }];  \n    await route.fulfill({ json });  \n  });  \n  // Go to the page  \n  await page.goto('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the Strawberry fruit is visible  \n  await expect(page.getByText('Strawberry')).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the form_interaction pattern.", "input": "You can create a custom reporter by implementing a class with some of the reporter methods. Learn more about the [Reporter](/docs/api/class-reporter \"Reporter\") API. | my-awesome-reporter.ts", "output": "import type {  \n  FullConfig, FullResult, Reporter, Suite, TestCase, TestResult  \n} from '@playwright/test/reporter';  \n  \nclass MyReporter implements Reporter {  \n  onBegin(config: FullConfig, suite: Suite) {  \n    console.log(`Starting the run with ${suite.allTests().length} tests`);  \n  }  \n  \n  onTestBegin(test: TestCase, result: TestResult) {  \n    console.log(`Starting test ${test.title}`);  \n  }  \n  \n  onTestEnd(test: TestCase, result: TestResult) {  \n    console.log(`Finished test ${test.title}: ${result.status}`);  \n  }  \n  \n  onEnd(result: FullResult) {  \n    console.log(`Finished the run: ${result.status}`);  \n  }  \n}  \n  \nexport default MyReporter;", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Generate a Playwright test for the following scenario: Conditionally skip a test\u200b | You can skip certain test based on the condition.", "input": "", "output": "test('skip this test', async ({ page, browserName }) => {  \n  test.skip(browserName === 'firefox', 'Still working on it');  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-annotations"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // runs all tests in all files of a specific project in parallel  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n      fullyParallel: true,  \n    },  \n  ]  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // runs all tests in all files of a specific project in parallel  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n      fullyParallel: true,  \n    },  \n  ]  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test('records or updates the HAR file', async ({ page }) => {  \n  // Get the response from the HAR file  \n  await page.routeFromHAR('./hars/fruit.har', {  \n    url: '*/**/api/v1/fruits',  \n    update: true,  \n  });  \n  \n  // Go to the page  \n  await page.goto('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the fruit is visible  \n  await expect(page.getByText('Strawberry')).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: This will also set the default timeouts of Playwright to 0 (= no timeout). | To debug your tests using the browser developer tools, start by setting a breakpoint in your test to pause the execution using the [page.pause()](/docs/api/class-page#page-pause) method.", "input": "", "output": "await page.pause();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/debug"}}
{"instruction": "Generate a Playwright test for the following scenario: Fixtures can also be overridden where the base fixture is completely replaced with something different. For example, we could override the [testOptions.storageState](/docs/api/class-testoptions#test-options-storage-state) fixture to provide our own data.", "input": "", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  storageState: async ({}, use) => {  \n    const cookie = await getAuthCookie();  \n    await use({ cookies: [cookie] });  \n  },  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Note that resulting matches are sorted by their distance to the anchor element, so you can use [locator.first()](/docs/api/class-locator#locator-first) to pick the closest one. This is only useful if you have something like a list of similar elements, where the closest is obviously the right one. However, using [locator.first()](/docs/api/class-locator#locator-first) in other cases most likely won't work as expected - it will not target the element you are searching for, but some other element that happens to be the closest like a random empty `<div>`, or an element that is scrolled out and is not currently visible.", "output": "// Fill an input to the right of \"Username\".  \nawait page.locator('input:right-of(:text(\"Username\"))').fill('value');  \n  \n// Click a button near the promo card.  \nawait page.locator('button:near(.promo-card)').click();  \n  \n// Click the radio input in the list closest to the \"Label 3\".  \nawait page.locator('[type=radio]:left-of(:text(\"Label 3\"))').first().click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Matching two locators simultaneously\u200b | Method [locator.and()](/docs/api/class-locator#locator-and) narrows down an existing locator by matching an additional locator. For example, you can combine [page.getByRole()](/docs/api/class-page#page-get-by-role) and [page.getByTitle()](/docs/api/class-page#page-get-by-title) to match by both role and title.", "output": "const button = page.getByRole('button').and(page.getByTitle('Subscribe'));", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Introduction\u200b | Here is a quick way to capture a screenshot and save it into a file:", "output": "await page.screenshot({ path: 'screenshot.png' });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/screenshots"}}
{"instruction": "Generate a Playwright test for the following scenario: example.spec.js", "input": "", "output": "const { test, expect } = require('@playwright/test');  \nconst { PlaywrightDevPage } = require('./playwright-dev-page');  \n  \ntest('getting started should contain table of contents', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.getStarted();  \n  await expect(playwrightDev.tocList).toHaveText([  \n    `How to install Playwright`,  \n    `What's Installed`,  \n    `How to run the example test`,  \n    `How to open the HTML test report`,  \n    `Write tests using web first assertions, page fixtures and locators`,  \n    `Run single test, multiple tests, headed mode`,  \n    `Generate tests with Codegen`,  \n    `See a trace of your tests`  \n  ]);  \n});  \n  \ntest('should show Page Object Model article', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.pageObjectModel();  \n  await expect(page.locator('article')).toContainText('Page Object Model is a common pattern');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/pom"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(<Component/>);  \n  await component.update(  \n      <Component msg=\"greetings\" onClick={() => {}}>Child</Component>  \n  );  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: In configuration file, pass options directly: | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['junit', { outputFile: 'results.xml' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \nimport { username, password } from '@myhelper/credentials';  \n  \ntest('example', async ({ page }) => {  \n  await page.getByLabel('User Name').fill(username);  \n  await page.getByLabel('Password').fill(password);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-typescript", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.getByRole('button').click();", "output": "await page.getByRole('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "This will only find a second button, because it is visible, and then click it.", "output": "await page.locator('button:visible').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['html', { outputFolder: 'my-report' }]],  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['html', { outputFolder: 'my-report' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test('this will not work', async ({ mount }) => {  \n  // () => 'red' callback lives in Node. If `ColorPicker` component in the browser calls the parameter function  \n  // `colorGetter` it won't get result synchronously. It'll be able to get it via await, but that is not how  \n  // components are typically built.  \n  const component = await mount(<ColorPicker colorGetter={() => 'red'}/>);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Handling new pages\u200b | The `page` event on browser contexts can be used to get new pages that are created in the context. This can be used to handle new pages opened by `target=\"_blank\"` links.", "output": "// Start waiting for new page before clicking. Note no await.  \nconst pagePromise = context.waitForEvent('page');  \nawait page.getByText('open new tab').click();  \nconst newPage = await pagePromise;  \n// Interact with the new page normally.  \nawait newPage.getByRole('button').click();  \nconsole.log(await newPage.title());", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/pages"}}
{"instruction": "Generate a Playwright test for the following scenario: You can chain methods that create a locator, like [page.getByText()](/docs/api/class-page#page-get-by-text) or [locator.getByRole()](/docs/api/class-locator#locator-get-by-role), to narrow down the search to a particular part of the page. | In this example we first create a locator called product by locating its role of `listitem`. We then filter by text. We can use the product locator again to get by role of button and click it and then use an assertion to make sure there is only one product with the text \"Product 2\".", "input": "", "output": "const product = page.getByRole('listitem').filter({ hasText: 'Product 2' });  \n  \nawait product.getByRole('button', { name: 'Add to cart' }).click();  \n  \nawait expect(product).toHaveCount(1);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test for the following scenario: And then import the fixtures in all your tests: | mytest.spec.ts", "input": "", "output": "import { test } from './fixtures';  \nimport { expect } from '@playwright/test';  \n  \ntest('basic', async ({ }) => {  \n  // ...  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test for the following scenario: \ud83e\udde9 Experimental [**React**](/docs/other-locators#react-locator) and [**Vue**](/docs/other-locators#vue-locator) selector engines\u200b | React and Vue selectors allow selecting elements by its component name and/or property values. The syntax is very similar to [attribute selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors) and supports all attribute selector operators.", "input": "", "output": "await page.locator('_react=SubmitButton[enabled=true]').click();  \nawait page.locator('_vue=submit-button[enabled=true]').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Here is a global setup example that authenticates once and reuses authentication state in tests. It uses the `baseURL` and `storageState` options from the configuration file. | global-setup.ts", "output": "import { chromium, type FullConfig } from '@playwright/test';  \n  \nasync function globalSetup(config: FullConfig) {  \n  const { baseURL, storageState } = config.projects[0].use;  \n  const browser = await chromium.launch();  \n  const page = await browser.newPage();  \n  await page.goto(baseURL!);  \n  await page.getByLabel('User Name').fill('user');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByText('Sign in').click();  \n  await page.context().storageState({ path: storageState as string });  \n  await browser.close();  \n}  \n  \nexport default globalSetup;", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test.beforeEach(async ({ page, isMobile }) => {  \n  test.fixme(isMobile, 'Settings page does not work in mobile yet');  \n  \n  await page.goto('http://localhost:3000/settings');  \n});  \n  \ntest('user profile', async ({ page }) => {  \n  await page.getByText('My Profile').click();  \n  // ...  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-annotations", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "<div id=\"current-time\" data-testid=\"current-time\"></div>  \n<script>  \n  const renderTime = () => {  \n    document.getElementById('current-time').textContent =  \n        new Date().toLocaleString();  \n  };  \n  setInterval(renderTime, 1000);  \n</script>  \n\n\n\n// Initialize clock with some time before the test time and let the page load  \n// naturally. `Date.now` will progress as the timers fire.  \nawait page.clock.install({ time: new Date('2024-02-02T08:00:00') });  \nawait page.navigate('http://localhost:3333');  \n  \n// Pretend that the user closed the laptop lid and opened it again at 10am,  \n// Pause the time once reached that point.  \nawait page.clock.pauseAt(new Date('2024-02-02T10:00:00'));  \n  \n// Assert the page state.  \nawait assert(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \n// Close the laptop lid again and open it at 10:30am.  \nawait page.clock.fastForward('30:00');  \nawait assert(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:30:00 AM');", "output": "<div id=\"current-time\" data-testid=\"current-time\"></div>  \n<script>  \n  const renderTime = () => {  \n    document.getElementById('current-time').textContent =  \n        new Date().toLocaleString();  \n  };  \n  setInterval(renderTime, 1000);  \n</script>  \n\n\n\n// Initialize clock with some time before the test time and let the page load  \n// naturally. `Date.now` will progress as the timers fire.  \nawait page.clock.install({ time: new Date('2024-02-02T08:00:00') });  \nawait page.goto('http://localhost:3333');  \n  \n// Pretend that the user closed the laptop lid and opened it again at 10am,  \n// Pause the time once reached that point.  \nawait page.clock.pauseAt(new Date('2024-02-02T10:00:00'));  \n  \n// Assert the page state.  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \n// Close the laptop lid again and open it at 10:30am.  \nawait page.clock.fastForward('30:00');  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:30:00 AM');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/clock", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: playwright.config.ts", "input": "", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        // It is important to define the `viewport` property after destructuring `devices`,  \n        // since devices also define the `viewport` for that device.  \n        viewport: { width: 1280, height: 720 },  \n      },  \n    },  \n  ]  \n});  \n\n\n\n// Create context with given viewport  \nconst context = await browser.newContext({  \n  viewport: { width: 1280, height: 1024 }  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const jsHandle = await page.evaluateHandle('window');  \n//  Use jsHandle for evaluations.", "output": "const jsHandle = await page.evaluateHandle('window');  \n//  Use jsHandle for evaluations.", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/handles", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "You can specify a single tsconfig file in the config file, that will be used for loading test files, reporters, etc. However, it will not be used while loading the playwright config itself or any files imported from it. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  tsconfig: './tsconfig.test.json',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-typescript"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const parent = page.getByText('Hello').locator('xpath=..');", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "We recommend prioritizing [user-visible locators](/docs/locators#quick-guide) like text or accessible role instead of using CSS that is tied to the implementation and could break when the page changes. | Playwright can locate an element by CSS selector.", "output": "await page.locator('css=button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "navigation"}}
{"instruction": "Generate a Playwright test for the following scenario: **Array as an option value** | If the value of your option is an array, for example `[{ name: 'Alice' }, { name: 'Bob' }]`, you'll need to wrap it into an extra array when providing the value. This is best illustrated with an example.", "input": "", "output": "type Person = { name: string };  \nconst test = base.extend<{ persons: Person[] }>({  \n  // Declare the option, default value is an empty array.  \n  persons: [[], { option: true }],  \n});  \n  \n// Option value is an array of persons.  \nconst actualPersons = [{ name: 'Alice' }, { name: 'Bob' }];  \ntest.use({  \n  // CORRECT: Wrap the value into an array and pass the scope.  \n  persons: [actualPersons, { scope: 'test' }],  \n});  \n  \ntest.use({  \n  // WRONG: passing an array value directly will not work.  \n  persons: actualPersons,  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "If your tests need to run behind a proxy, you can specify this in the config and the `request` fixture will pick it up automatically: | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    proxy: {  \n      server: 'http://my-proxy:8080',  \n      username: 'user',  \n      password: 'secret'  \n    },  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/api-testing"}}
{"instruction": "Generate a Playwright test for the following scenario: [expect(locator).toHaveRole()](/docs/api/class-locatorassertions#locator-assertions-to-have-role) checks if the element has the specified ARIA role:", "input": "", "output": "const locator = page.getByTestId('save-button');  \nawait expect(locator).toHaveRole('button');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "<div id=\"remaining-time\" data-testid=\"remaining-time\"></div>  \n<script>  \n  const endTime = Date.now() + 5 * 60_000;  \n  const renderTime = () => {  \n    const diffInSeconds = Math.round((endTime - Date.now()) / 1000);  \n    if (diffInSeconds <= 0) {  \n      document.getElementById('remaining-time').textContent =  \n        'You have been logged out due to inactivity.';  \n    } else {  \n      document.getElementById('remaining-time').textContent =  \n        `You will be logged out in ${diffInSeconds} seconds.`;  \n    }  \n    setTimeout(renderTime, 1000);  \n  };  \n  renderTime();  \n</script>  \n<button type=\"button\">Interaction</button>  \n\n\n\n// Initial time does not matter for the test, so we can pick current time.  \nawait page.clock.install();  \nawait page.goto('http://localhost:3333');  \n// Interact with the page  \nawait page.getByRole('button').click();  \n  \n// Fast forward time 5 minutes as if the user did not do anything.  \n// Fast forward is like closing the laptop lid and opening it after 5 minutes.  \n// All the timers due will fire once immediately, as in the real browser.  \nawait page.clock.fastForward('05:00');  \n  \n// Check that the user was logged out automatically.  \nawait expect(page.getByText('You have been logged out due to inactivity.')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/clock", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Locators Update\u200b | Use [locator.or()](/docs/api/class-locator#locator-or) to create a locator that matches either of the two locators. Consider a scenario where you'd like to click on a \"New email\" button, but sometimes a security settings dialog shows up instead. In this case, you can wait for either a \"New email\" button, or a dialog and act accordingly:", "input": "", "output": "const newEmail = page.getByRole('button', { name: 'New email' });  \nconst dialog = page.getByText('Confirm security settings');  \nawait expect(newEmail.or(dialog)).toBeVisible();  \nif (await dialog.isVisible())  \n  await page.getByRole('button', { name: 'Dismiss' }).click();  \nawait newEmail.click();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test.describe(() => {  \n  test.use({ colorScheme: 'dark' });  \n  \n  test('one', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('two', async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: 'dot',  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: 'dot',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, type Page } from '@playwright/test';  \n  \n// Annotate entire file as serial.  \ntest.describe.configure({ mode: 'serial' });  \n  \nlet page: Page;  \n  \ntest.beforeAll(async ({ browser }) => {  \n  page = await browser.newPage();  \n});  \n  \ntest.afterAll(async () => {  \n  await page.close();  \n});  \n  \ntest('runs first', async () => {  \n  await page.navigate('https://playwright.dev/');  \n});  \n  \ntest('runs second', async () => {  \n  await page.getByText('Get Started').click();  \n});", "output": "import { test, type Page } from '@playwright/test';  \n  \n// Annotate entire file as serial.  \ntest.describe.configure({ mode: 'serial' });  \n  \nlet page: Page;  \n  \ntest.beforeAll(async ({ browser }) => {  \n  page = await browser.newPage();  \n});  \n  \ntest.afterAll(async () => {  \n  await page.close();  \n});  \n  \ntest('runs first', async () => {  \n  await page.goto('https://playwright.dev/');  \n});  \n  \ntest('runs second', async () => {  \n  await page.getByText('Get Started').click();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-parallel", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "However, in rare cases you might need to manually scroll. For example, you might want to force an \"infinite list\" to load more elements, or position the page for a specific screenshot. In such a case, the most reliable way is to find an element that you want to make visible at the bottom, and scroll it into view.", "output": "// Scroll the footer into view, forcing an \"infinite list\" to load more content  \nawait page.getByText('Footer text').scrollIntoViewIfNeeded();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "New [page.removeLocatorHandler()](/docs/api/class-page#page-remove-locator-handler) method for removing previously added locator handlers.", "output": "const locator = page.getByText('This interstitial covers the button');  \nawait page.addLocatorHandler(locator, async overlay => {  \n  await overlay.locator('#close').click();  \n}, { times: 3, noWaitAfter: true });  \n// Run your tests that can be interrupted by the overlay.  \n// ...  \nawait page.removeLocatorHandler(locator);", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "navigation"}}
{"instruction": "Generate a Playwright test for the following scenario: component.spec.tsx", "input": "", "output": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('children', async ({ mount }) => {  \n  const component = await mount(<Component>Child</Component>);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Emulates the user locale.  \n    locale: 'en-GB',  \n  \n    // Emulates the user timezone.  \n    timezoneId: 'Europe/Paris',  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Emulates the user locale.  \n    locale: 'en-GB',  \n  \n    // Emulates the user timezone.  \n    timezoneId: 'Europe/Paris',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/emulation", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.route('**/title.html', async route => {  \n  // Fetch original response.  \n  const response = await route.fetch();  \n  // Add a prefix to the title.  \n  let body = await response.text();  \n  body = body.replace('<title>', '<title>My prefix:');  \n  await route.fulfill({  \n    // Pass all fields from the response.  \n    response,  \n    // Override response body.  \n    body,  \n    // Force content type to be html.  \n    headers: {  \n      ...response.headers(),  \n      'content-type': 'text/html'  \n    }  \n  });  \n});", "output": "await page.route('**/title.html', async route => {  \n  // Fetch original response.  \n  const response = await route.fetch();  \n  // Add a prefix to the title.  \n  let body = await response.text();  \n  body = body.replace('<title>', '<title>My prefix:');  \n  await route.fulfill({  \n    // Pass all fields from the response.  \n    response,  \n    // Override response body.  \n    body,  \n    // Force content type to be html.  \n    headers: {  \n      ...response.headers(),  \n      'content-type': 'text/html'  \n    }  \n  });  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/network", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert(page.locator('.status')).toHaveText('Submitted');", "output": "await expect(page.locator('.status')).toHaveText('Submitted');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert(page  \n    .getByRole('listitem'))  \n    .toHaveText(['apple', 'banana', 'orange']);", "output": "await expect(page  \n    .getByRole('listitem'))  \n    .toHaveText(['apple', 'banana', 'orange']);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "CSS: elements matching one of the conditions\u200b | Comma-separated list of CSS selectors will match all elements that can be selected by one of the selectors in that list.", "output": "// Clicks a <button> that has either a \"Log in\" or \"Sign in\" text.  \nawait page.locator('button:has-text(\"Log in\"), button:has-text(\"Sign in\")').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "navigation"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "To take a screenshot of the row with \"Mary\" and \"Say goodbye\":", "output": "const rowLocator = page.getByRole('listitem');  \n  \nawait rowLocator  \n    .filter({ hasText: 'Mary' })  \n    .filter({ has: page.getByRole('button', { name: 'Say goodbye' }) })  \n    .screenshot({ path: 'screenshot.png' });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "If you want to have hooks for each test, you can put them inside a `describe()` \\- so they are executed for each iteration / each individual test: | example.spec.ts", "output": "[  \n  { name: 'Alice', expected: 'Hello, Alice!' },  \n  { name: 'Bob', expected: 'Hello, Bob!' },  \n  { name: 'Charlie', expected: 'Hello, Charlie!' },  \n].forEach(({ name, expected }) => {  \n  test.describe(() => {  \n    test.beforeEach(async ({ page }) => {  \n      await page.goto(`https://example.com/greet?name=${name}`);  \n    });  \n    test(`testing with ${expected}`, async ({ page }) => {  \n      await expect(page.getByRole('heading')).toHaveText(expected);  \n    });  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Tick through time manually, firing all the timers consistently\u200b | In rare cases, you may want to tick through time manually, firing all timers and animation frames in the process to achieve a fine-grained control over the passage of time.", "output": "<div id=\"current-time\" data-testid=\"current-time\"></div>  \n<script>  \n  const renderTime = () => {  \n    document.getElementById('current-time').textContent =  \n        new Date().toLocaleString();  \n  };  \n  setInterval(renderTime, 1000);  \n</script>  \n\n\n\n// Initialize clock with a specific time, let the page load naturally.  \nawait page.clock.install({ time: new Date('2024-02-02T08:00:00') });  \nawait page.goto('http://localhost:3333');  \n  \n// Pause the time flow, stop the timers, you now have manual control  \n// over the page time.  \nawait page.clock.pauseAt(new Date('2024-02-02T10:00:00'));  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \n// Tick through time manually, firing all timers in the process.  \n// In this case, time will be updated in the screen 2 times.  \nawait page.clock.runFor(2000);  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:02 AM');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/clock"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/experimental-ct-react';  \nimport HelloWorld from './HelloWorld';  \n  \ntest.use({ viewport: { width: 500, height: 500 } });  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<HelloWorld msg=\"greetings\" />);  \n  await assert(component).toContainText('Greetings');  \n});  \n\n\n\nimport { test, assert } from '@playwright/experimental-ct-vue';  \nimport HelloWorld from './HelloWorld.vue';  \n  \ntest.use({ viewport: { width: 500, height: 500 } });  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(HelloWorld, {  \n    props: {  \n      msg: 'Greetings',  \n    },  \n  });  \n  await assert(component).toContainText('Greetings');  \n});  \n\n\n\nimport { test, assert } from '@playwright/experimental-ct-svelte';  \nimport HelloWorld from './HelloWorld.svelte';  \n  \ntest.use({ viewport: { width: 500, height: 500 } });  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(HelloWorld, {  \n    props: {  \n      msg: 'Greetings',  \n    },  \n  });  \n  await assert(component).toContainText('Greetings');  \n});", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport HelloWorld from './HelloWorld';  \n  \ntest.use({ viewport: { width: 500, height: 500 } });  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<HelloWorld msg=\"greetings\" />);  \n  await expect(component).toContainText('Greetings');  \n});  \n\n\n\nimport { test, expect } from '@playwright/experimental-ct-vue';  \nimport HelloWorld from './HelloWorld.vue';  \n  \ntest.use({ viewport: { width: 500, height: 500 } });  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(HelloWorld, {  \n    props: {  \n      msg: 'Greetings',  \n    },  \n  });  \n  await expect(component).toContainText('Greetings');  \n});  \n\n\n\nimport { test, expect } from '@playwright/experimental-ct-svelte';  \nimport HelloWorld from './HelloWorld.svelte';  \n  \ntest.use({ viewport: { width: 500, height: 500 } });  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(HelloWorld, {  \n    props: {  \n      msg: 'Greetings',  \n    },  \n  });  \n  await expect(component).toContainText('Greetings');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "async function login(page) {  \n  await test.step('login', async () => {  \n    // ...  \n  }, { box: true });  // Note the \"box\" option here.  \n}  \n\n\n\nError: Timed out 5000ms waiting for assert(locator).toBeVisible()  \n  ... error details omitted ...  \n  \n  14 |   await page.navigate('https://github.com/login');  \n> 15 |   await login(page);  \n     |         ^  \n  16 | });", "output": "async function login(page) {  \n  await test.step('login', async () => {  \n    // ...  \n  }, { box: true });  // Note the \"box\" option here.  \n}  \n\n\n\nError: Timed out 5000ms waiting for expect(locator).toBeVisible()  \n  ... error details omitted ...  \n  \n  14 |   await page.goto('https://github.com/login');  \n> 15 |   await login(page);  \n     |         ^  \n  16 | });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect(page).toHaveScreenshot('landing.png');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "const locator = page.getByRole('button');  \nawait expect(locator).toHaveAccessibleDescription('Upload a photo');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as base } from '@playwright/test';  \n  \nexport type TestOptions = {  \n  person: string;  \n};  \n  \nexport const test = base.extend<TestOptions>({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  person: ['John', { option: true }],  \n  \n  // Override default \"page\" fixture.  \n  page: async ({ page, person }, use) => {  \n    await page.goto('/chat');  \n    // We use \"person\" parameter as a \"name\" for the chat room.  \n    await page.getByLabel('User Name').fill(person);  \n    await page.getByText('Enter chat room').click();  \n    // Each test will get a \"page\" that already has the person name.  \n    await use(page);  \n  },  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-parameterize", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const banana = await page.getByRole('listitem').nth(1);", "output": "const banana = await page.getByRole('listitem').nth(1);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { assert, type Locator, type Page } from '@playwright/test';  \n  \nexport class PlaywrightDevPage {  \n  readonly page: Page;  \n  readonly getStartedLink: Locator;  \n  readonly gettingStartedHeader: Locator;  \n  readonly pomLink: Locator;  \n  readonly tocList: Locator;  \n  \n  constructor(page: Page) {  \n    this.page = page;  \n    this.getStartedLink = page.locator('a', { hasText: 'Get started' });  \n    this.gettingStartedHeader = page.locator('h1', { hasText: 'Installation' });  \n    this.pomLink = page.locator('li', {  \n      hasText: 'Guides',  \n    }).locator('a', {  \n      hasText: 'Page Object Model',  \n    });  \n    this.tocList = page.locator('article div.markdown ul > li > a');  \n  }  \n  \n  async goto() {  \n    await this.page.navigate('https://playwright.dev');  \n  }  \n  \n  async getStarted() {  \n    await this.getStartedLink.first().click();  \n    await assert(this.gettingStartedHeader).toBeVisible();  \n  }  \n  \n  async pageObjectModel() {  \n    await this.getStarted();  \n    await this.pomLink.click();  \n  }  \n}", "output": "import { expect, type Locator, type Page } from '@playwright/test';  \n  \nexport class PlaywrightDevPage {  \n  readonly page: Page;  \n  readonly getStartedLink: Locator;  \n  readonly gettingStartedHeader: Locator;  \n  readonly pomLink: Locator;  \n  readonly tocList: Locator;  \n  \n  constructor(page: Page) {  \n    this.page = page;  \n    this.getStartedLink = page.locator('a', { hasText: 'Get started' });  \n    this.gettingStartedHeader = page.locator('h1', { hasText: 'Installation' });  \n    this.pomLink = page.locator('li', {  \n      hasText: 'Guides',  \n    }).locator('a', {  \n      hasText: 'Page Object Model',  \n    });  \n    this.tocList = page.locator('article div.markdown ul > li > a');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://playwright.dev');  \n  }  \n  \n  async getStarted() {  \n    await this.getStartedLink.first().click();  \n    await expect(this.gettingStartedHeader).toBeVisible();  \n  }  \n  \n  async pageObjectModel() {  \n    await this.getStarted();  \n    await this.pomLink.click();  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/pom", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: In this case, `:nth-match(:text(\"Buy\"), 3)` will select the third button from the snippet above. Note that index is one-based.", "input": "", "output": "// Click the third \"Buy\" button  \nawait page.locator(':nth-match(:text(\"Buy\"), 3)').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test for the following scenario: New options [testConfig.respectGitIgnore](/docs/api/class-testconfig#test-config-respect-git-ignore) and [testProject.respectGitIgnore](/docs/api/class-testproject#test-project-respect-git-ignore) control whether files matching `.gitignore` patterns are excluded when searching for tests. | New property `timeout` is now available for custom expect matchers. This property takes into account `playwright.config.ts` and `expect.configure()`.", "input": "", "output": "import { expect as baseExpect } from '@playwright/test';  \n  \nexport const expect = baseExpect.extend({  \n  async toHaveAmount(locator: Locator, expected: number, options?: { timeout?: number }) {  \n    // When no timeout option is specified, use the config timeout.  \n    const timeout = options?.timeout ?? this.timeout;  \n    // ... implement the assertion ...  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: After that, specify `storageState` for each test file or test group, **instead of** setting it in the config. | tests/example.spec.ts", "input": "", "output": "import { test } from '@playwright/test';  \n  \ntest.use({ storageState: 'playwright/.auth/admin.json' });  \n  \ntest('admin test', async ({ page }) => {  \n  // page is authenticated as admin  \n});  \n  \ntest.describe(() => {  \n  test.use({ storageState: 'playwright/.auth/user.json' });  \n  \n  test('user test', async ({ page }) => {  \n    // page is authenticated as a user  \n  });  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "For example, this could be used to setup App router in Vue.js: | src/component.spec.ts", "output": "import { test } from '@playwright/experimental-ct-vue';  \nimport { Component } from './mycomponent';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(Component, {  \n    hooksConfig: {  \n      /* anything to configure your app */  \n    }  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Delete header  \nawait page.route('**/*', async route => {  \n  const headers = route.request().headers();  \n  delete headers['X-Secret'];  \n  await route.continue({ headers });  \n});  \n  \n// Continue requests as POST.  \nawait page.route('**/*', route => route.continue({ method: 'POST' }));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/network", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Then we create a `global.teardown.ts` file in the tests directory of your project. This will be used to delete the data from the database after all tests have run. | tests/global.teardown.ts", "output": "import { test as teardown } from '@playwright/test';  \n  \nteardown('delete database', async ({ }) => {  \n  console.log('deleting test database...');  \n  // Delete the database  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('event', async ({ mount }) => {  \n  const component = await mount(<Component v-on:click={() => {}} />);  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "// Get the element handle  \nconst elementHandle = page.waitForSelector('#box');  \n  \n// Assert bounding box for the element  \nconst boundingBox = await elementHandle.boundingBox();  \nexpect(boundingBox.width).toBe(100);  \n  \n// Assert attribute for the element  \nconst classNames = await elementHandle.getAttribute('class');  \nexpect(classNames.includes('highlighted')).toBeTruthy();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/handles", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Playwright Test is based on the concept of [test fixtures](/docs/test-fixtures) such as the [built in page fixture](/docs/test-fixtures#built-in-fixtures), which is passed into your test. Pages are [isolated between tests due to the Browser Context](/docs/browser-contexts), which is equivalent to a brand new browser profile, where every test gets a fresh environment, even when multiple tests run in a single Browser. | tests/example.spec.ts", "output": "import { test } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  // \"page\" belongs to an isolated BrowserContext, created for this specific test.  \n});  \n  \ntest('another test', async ({ page }) => {  \n  // \"page\" in this second test is completely isolated from the first test.  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/writing-tests"}}
{"instruction": "Generate a Playwright test for the following scenario: The proper way to make a fixture parametrized in the config file is to specify `option: true` when defining the fixture. For example,", "input": "", "output": "// CORRECT: THIS SNIPPET WORKS SINCE v1.18.  \n  \n// fixtures.js  \nconst test = base.extend({  \n  // Fixtures marked as \"option: true\" will get a value specified in the config,  \n  // or fallback to the default value.  \n  myParameter: ['default', { option: true }],  \n});  \n  \n// playwright.config.js  \nmodule.exports = {  \n  use: {  \n    myParameter: 'value',  \n  },  \n};", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "tests/example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  colorScheme: 'dark' // or 'light'  \n});  \n  \ntest('my test with dark mode', async ({ page }) => {  \n  // ...  \n});  \n\n\n\n// Create context with dark mode  \nconst context = await browser.newContext({  \n  colorScheme: 'dark' // or 'light'  \n});  \n  \n// Create page with dark mode  \nconst page = await browser.newPage({  \n  colorScheme: 'dark' // or 'light'  \n});  \n  \n// Change color scheme for the page  \nawait page.emulateMedia({ colorScheme: 'dark' });  \n  \n// Change media for page  \nawait page.emulateMedia({ media: 'print' });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Generate a Playwright test for the following scenario: Use [expect(locator).toHaveText()](/docs/api/class-locatorassertions#locator-assertions-to-have-text) to ensure that the list has the text \"apple\", \"banana\" and \"orange\".", "input": "", "output": "await expect(page  \n    .getByRole('listitem'))  \n    .toHaveText(['apple', 'banana', 'orange']);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test('should inherit use options on context when using built-in browser fixture', async ({  \n  browser,  \n}) => {  \n  const context = await browser.newContext();  \n  const page = await context.newPage();  \n  assert(await page.evaluate(() => navigator.userAgent)).toBe('some custom ua');  \n  assert(await page.evaluate(() => window.innerWidth)).toBe(100);  \n  await context.close();  \n});", "output": "test('should inherit use options on context when using built-in browser fixture', async ({  \n  browser,  \n}) => {  \n  const context = await browser.newContext();  \n  const page = await context.newPage();  \n  expect(await page.evaluate(() => navigator.userAgent)).toBe('some custom ua');  \n  expect(await page.evaluate(() => window.innerWidth)).toBe(100);  \n  await context.close();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-use-options", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'setup',  \n      testMatch: '**/*.setup.ts',  \n    },  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'firefox',  \n      use: { ...devices['Desktop Firefox'] },  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'webkit',  \n      use: { ...devices['Desktop Safari'] },  \n      dependencies: ['setup'],  \n    },  \n  ],  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'setup',  \n      testMatch: '**/*.setup.ts',  \n    },  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'firefox',  \n      use: { ...devices['Desktop Firefox'] },  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'webkit',  \n      use: { ...devices['Desktop Safari'] },  \n      dependencies: ['setup'],  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-projects", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Extensions only work in Chrome / Chromium launched with a persistent context. Use custom browser args at your own risk, as some of them may break Playwright functionality. | The following is code for getting a handle to the [background page](https://developer.chrome.com/extensions/background_pages) of a [Manifest v2](https://developer.chrome.com/docs/extensions/mv2/) extension whose source is located in `./my-extension`:", "output": "const { chromium } = require('playwright');  \n  \n(async () => {  \n  const pathToExtension = require('path').join(__dirname, 'my-extension');  \n  const userDataDir = '/tmp/test-user-data-dir';  \n  const browserContext = await chromium.launchPersistentContext(userDataDir, {  \n    headless: false,  \n    args: [  \n      `--disable-extensions-except=${pathToExtension}`,  \n      `--load-extension=${pathToExtension}`  \n    ]  \n  });  \n  let [backgroundPage] = browserContext.backgroundPages();  \n  if (!backgroundPage)  \n    backgroundPage = await browserContext.waitForEvent('backgroundpage');  \n  \n  // Test the background page as you would any other page.  \n  await browserContext.close();  \n})();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/chrome-extensions"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  webServer: [  \n    {  \n      command: 'npm run start',  \n      url: 'http://127.0.0.1:3000',  \n      timeout: 120 * 1000,  \n      reuseExistingServer: !process.env.CI,  \n    },  \n    {  \n      command: 'npm run backend',  \n      url: 'http://127.0.0.1:3333',  \n      timeout: 120 * 1000,  \n      reuseExistingServer: !process.env.CI,  \n    }  \n  ],  \n  use: {  \n    baseURL: 'http://localhost:3000/',  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  webServer: [  \n    {  \n      command: 'npm run start',  \n      url: 'http://127.0.0.1:3000',  \n      timeout: 120 * 1000,  \n      reuseExistingServer: !process.env.CI,  \n    },  \n    {  \n      command: 'npm run backend',  \n      url: 'http://127.0.0.1:3333',  \n      timeout: 120 * 1000,  \n      reuseExistingServer: !process.env.CI,  \n    }  \n  ],  \n  use: {  \n    baseURL: 'http://localhost:3000/',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "[test.beforeEach()](/docs/api/class-test#test-before-each) and [test.afterEach()](/docs/api/class-test#test-after-each) hooks run before/after each test declared in the same file and same [test.describe()](/docs/api/class-test#test-describe) block (if any). If you want to declare hooks that run before/after each test globally, you can declare them as auto fixtures like this: | fixtures.ts", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend<{ forEachTest: void }>({  \n  forEachTest: [async ({ page }, use) => {  \n    // This code runs before every test.  \n    await page.goto('http://localhost:8000');  \n    await use();  \n    // This code runs after every test.  \n    console.log('Last URL:', page.url());  \n  }, { auto: true }],  // automatically starts for every test.  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Here is an example fixture that automatically attaches debug logs when the test fails, so we can later review the logs in the reporter. Note how it uses [TestInfo](/docs/api/class-testinfo \"TestInfo\") object that is available in each test/fixture to retrieve metadata about the test being run. | my-test.ts", "output": "import * as debug from 'debug';  \nimport * as fs from 'fs';  \nimport { test as base } from '@playwright/test';  \n  \nexport const test = base.extend<{ saveLogs: void }>({  \n  saveLogs: [async ({}, use, testInfo) => {  \n    // Collecting logs during the test.  \n    const logs = [];  \n    debug.log = (...args) => logs.push(args.map(String).join(''));  \n    debug.enable('myserver');  \n  \n    await use();  \n  \n    // After the test we can check whether the test passed or failed.  \n    if (testInfo.status !== testInfo.expectedStatus) {  \n      // outputPath() API guarantees a unique file name.  \n      const logFile = testInfo.outputPath('logs.txt');  \n      await fs.promises.writeFile(logFile, logs.join('\\n'), 'utf8');  \n      testInfo.attachments.push({ name: 'logs', contentType: 'text/plain', path: logFile });  \n    }  \n  }, { auto: true }],  \n});  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.getByLabel('Password').fill('secret');", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        // It is important to define the `viewport` property after destructuring `devices`,  \n        // since devices also define the `viewport` for that device.  \n        viewport: { width: 1280, height: 720 },  \n      },  \n    },  \n  ]  \n});  \n\n\n\n// Create context with given viewport  \nconst context = await browser.newContext({  \n  viewport: { width: 1280, height: 1024 }  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/emulation", "type": "website_test"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "my-test.ts", "output": "import { test as base } from '@playwright/test';  \n  \nexport type TestOptions = {  \n  person: string;  \n};  \n  \nexport const test = base.extend<TestOptions>({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  person: ['John', { option: true }],  \n  \n  // Override default \"page\" fixture.  \n  page: async ({ page, person }, use) => {  \n    await page.goto('/chat');  \n    // We use \"person\" parameter as a \"name\" for the chat room.  \n    await page.getByLabel('User Name').fill(person);  \n    await page.getByText('Enter chat room').click();  \n    // Each test will get a \"page\" that already has the person name.  \n    await use(page);  \n  },  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-parameterize", "type": "fixture"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "New property [testInfo.tags](/docs/api/class-testinfo#test-info-tags) exposes test tags during test execution.", "output": "test('example', async ({ page }) => {  \n  console.log(test.info().tags);  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the form_interaction pattern.", "input": "Abort requests\u200b | You can abort requests using [page.route()](/docs/api/class-page#page-route) and [route.abort()](/docs/api/class-route#route-abort).", "output": "await page.route('**/*.{png,jpg,jpeg}', route => route.abort());  \n  \n// Abort based on the request type  \nawait page.route('**/*', route => {  \n  return route.request().resourceType() === 'image' ? route.abort() : route.continue();  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['html', { attachmentsBaseURL: 'https://external-storage.com/' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Emulate the users `\"colorScheme\"`. Supported values are 'light' and 'dark'. You can also emulate the media type with [page.emulateMedia()](/docs/api/class-page#page-emulate-media). | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    colorScheme: 'dark',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport HelloWorld from './HelloWorld';  \n  \ntest.use({ viewport: { width: 500, height: 500 } });  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<HelloWorld msg=\"greetings\" />);  \n  await expect(component).toContainText('Greetings');  \n});  \n\n\n\nimport { test, expect } from '@playwright/experimental-ct-vue';  \nimport HelloWorld from './HelloWorld.vue';  \n  \ntest.use({ viewport: { width: 500, height: 500 } });  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(HelloWorld, {  \n    props: {  \n      msg: 'Greetings',  \n    },  \n  });  \n  await expect(component).toContainText('Greetings');  \n});  \n\n\n\nimport { test, expect } from '@playwright/experimental-ct-svelte';  \nimport HelloWorld from './HelloWorld.svelte';  \n  \ntest.use({ viewport: { width: 500, height: 500 } });  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(HelloWorld, {  \n    props: {  \n      msg: 'Greetings',  \n    },  \n  });  \n  await expect(component).toContainText('Greetings');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: Modify requests\u200b", "input": "", "output": "// Delete header  \nawait page.route('**/*', async route => {  \n  const headers = route.request().headers();  \n  delete headers['X-Secret'];  \n  await route.continue({ headers });  \n});  \n  \n// Continue requests as POST.  \nawait page.route('**/*', route => route.continue({ method: 'POST' }));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "[expect(locator).toHaveAccessibleDescription()](/docs/api/class-locatorassertions#locator-assertions-to-have-accessible-description) checks if the element has the specified accessible description:", "output": "const locator = page.getByRole('button');  \nawait expect(locator).toHaveAccessibleDescription('Upload a photo');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect(page.getByRole('button')).toHaveAttribute('disabled', '');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Available options to configure networking: | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Whether to automatically download all the attachments.  \n    acceptDownloads: false,  \n  \n    // An object containing additional HTTP headers to be sent with every request.  \n    extraHTTPHeaders: {  \n      'X-My-Header': 'value',  \n    },  \n  \n    // Credentials for HTTP authentication.  \n    httpCredentials: {  \n      username: 'user',  \n      password: 'pass',  \n    },  \n  \n    // Whether to ignore HTTPS errors during navigation.  \n    ignoreHTTPSErrors: true,  \n  \n    // Whether to emulate network being offline.  \n    offline: true,  \n  \n    // Proxy settings used for all pages in the test.  \n    proxy: {  \n      server: 'http://myproxy.com:3128',  \n      bypass: 'localhost',  \n    },  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options"}}
{"instruction": "Generate a Playwright test for the following scenario: Vue", "input": "", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport HelloWorld from './HelloWorld';  \n  \ntest.use({ viewport: { width: 500, height: 500 } });  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<HelloWorld msg=\"greetings\" />);  \n  await expect(component).toContainText('Greetings');  \n});  \n\n\n\nimport { test, expect } from '@playwright/experimental-ct-vue';  \nimport HelloWorld from './HelloWorld.vue';  \n  \ntest.use({ viewport: { width: 500, height: 500 } });  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(HelloWorld, {  \n    props: {  \n      msg: 'Greetings',  \n    },  \n  });  \n  await expect(component).toContainText('Greetings');  \n});  \n\n\n\nimport { test, expect } from '@playwright/experimental-ct-svelte';  \nimport HelloWorld from './HelloWorld.svelte';  \n  \ntest.use({ viewport: { width: 500, height: 500 } });  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(HelloWorld, {  \n    props: {  \n      msg: 'Greetings',  \n    },  \n  });  \n  await expect(component).toContainText('Greetings');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test for the following scenario: src/pages/ProductsPage.spec.tsx", "input": "", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport type { HooksConfig } from '../playwright';  \nimport { ProductsPage } from './pages/ProductsPage';  \n  \ntest('configure routing through hooks config', async ({ page, mount }) => {  \n  const component = await mount<HooksConfig>(<ProductsPage />, {  \n    hooksConfig: { enableRouting: true },  \n  });  \n  await expect(component.getByRole('link')).toHaveAttribute('href', '/products/42');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test for the following scenario: In this example we add a custom `toHaveAmount` function. Custom matcher should return a `pass` flag indicating whether the assertion passed, and a `message` callback that's used when the assertion fails. | fixtures.ts", "input": "", "output": "import { expect as baseExpect } from '@playwright/test';  \nimport type { Page, Locator } from '@playwright/test';  \n  \nexport { test } from '@playwright/test';  \n  \nexport const expect = baseExpect.extend({  \n  async toHaveAmount(locator: Locator, expected: number, options?: { timeout?: number }) {  \n    const assertionName = 'toHaveAmount';  \n    let pass: boolean;  \n    let matcherResult: any;  \n    try {  \n      await baseExpect(locator).toHaveAttribute('data-amount', String(expected), options);  \n      pass = true;  \n    } catch (e: any) {  \n      matcherResult = e.matcherResult;  \n      pass = false;  \n    }  \n  \n    const message = pass  \n      ? () => this.utils.matcherHint(assertionName, undefined, undefined, { isNot: this.isNot }) +  \n          '\\n\\n' +  \n          `Locator: ${locator}\\n` +  \n          `Expected: not ${this.utils.printExpected(expected)}\\n` +  \n          (matcherResult ? `Received: ${this.utils.printReceived(matcherResult.actual)}` : '')  \n      : () =>  this.utils.matcherHint(assertionName, undefined, undefined, { isNot: this.isNot }) +  \n          '\\n\\n' +  \n          `Locator: ${locator}\\n` +  \n          `Expected: ${this.utils.printExpected(expected)}\\n` +  \n          (matcherResult ? `Received: ${this.utils.printReceived(matcherResult.actual)}` : '');  \n  \n    return {  \n      message,  \n      pass,  \n      name: assertionName,  \n      expected,  \n      actual: matcherResult?.actual,  \n    };  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You can't pass complex live objects to your component. Only plain JavaScript objects and built-in types like strings, numbers, dates etc. can be passed.", "output": "test('this will work', async ({ mount }) => {  \n  const component = await mount(<ProcessViewer process={{ name: 'playwright' }}/>);  \n});  \n  \ntest('this will not work', async ({ mount }) => {  \n  // `process` is a Node object, we can't pass it to the browser and expect it to work.  \n  const component = await mount(<ProcessViewer process={process}/>);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test for the following scenario: Overview\u200b | A WebView2 control can be instructed to listen to incoming CDP connections by setting either the `WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS` environment variable with `--remote-debugging-port=9222` or calling [EnsureCoreWebView2Async](https://docs.microsoft.com/en-us/dotnet/api/microsoft.web.webview2.wpf.webview2.ensurecorewebview2async?view=webview2-dotnet-1.0.1343.22) with the `--remote-debugging-port=9222` argument. This will start the WebView2 process with the Chrome DevTools Protocol enabled which allows the automation by Playwright. 9222 is an example port in this case, but any other unused port can be used as well.", "input": "", "output": "await this.webView.EnsureCoreWebView2Async(await CoreWebView2Environment.CreateAsync(null, null, new CoreWebView2EnvironmentOptions()  \n{  \n  AdditionalBrowserArguments = \"--remote-debugging-port=9222\",  \n})).ConfigureAwait(false);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/webview2"}}
{"instruction": "Generate a Playwright test for the following scenario: component.spec.ts", "input": "", "output": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('unmount', async ({ mount }) => {  \n  const component = await mount(Component);  \n  await component.unmount();  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { assert as baseExpect } from '@playwright/test';  \nimport type { Page, Locator } from '@playwright/test';  \n  \nexport { test } from '@playwright/test';  \n  \nexport const assert = baseExpect.extend({  \n  async toHaveAmount(locator: Locator, asserted: number, options?: { timeout?: number }) {  \n    const assertionName = 'toHaveAmount';  \n    let pass: boolean;  \n    let matcherResult: any;  \n    try {  \n      await baseExpect(locator).toHaveAttribute('data-amount', String(asserted), options);  \n      pass = true;  \n    } catch (e: any) {  \n      matcherResult = e.matcherResult;  \n      pass = false;  \n    }  \n  \n    const message = pass  \n      ? () => this.utils.matcherHint(assertionName, undefined, undefined, { isNot: this.isNot }) +  \n          '\\n\\n' +  \n          `Locator: ${locator}\\n` +  \n          `Expected: not ${this.utils.printExpected(asserted)}\\n` +  \n          (matcherResult ? `Received: ${this.utils.printReceived(matcherResult.actual)}` : '')  \n      : () =>  this.utils.matcherHint(assertionName, undefined, undefined, { isNot: this.isNot }) +  \n          '\\n\\n' +  \n          `Locator: ${locator}\\n` +  \n          `Expected: ${this.utils.printExpected(asserted)}\\n` +  \n          (matcherResult ? `Received: ${this.utils.printReceived(matcherResult.actual)}` : '');  \n  \n    return {  \n      message,  \n      pass,  \n      name: assertionName,  \n      asserted,  \n      actual: matcherResult?.actual,  \n    };  \n  },  \n});", "output": "import { expect as baseExpect } from '@playwright/test';  \nimport type { Page, Locator } from '@playwright/test';  \n  \nexport { test } from '@playwright/test';  \n  \nexport const expect = baseExpect.extend({  \n  async toHaveAmount(locator: Locator, expected: number, options?: { timeout?: number }) {  \n    const assertionName = 'toHaveAmount';  \n    let pass: boolean;  \n    let matcherResult: any;  \n    try {  \n      await baseExpect(locator).toHaveAttribute('data-amount', String(expected), options);  \n      pass = true;  \n    } catch (e: any) {  \n      matcherResult = e.matcherResult;  \n      pass = false;  \n    }  \n  \n    const message = pass  \n      ? () => this.utils.matcherHint(assertionName, undefined, undefined, { isNot: this.isNot }) +  \n          '\\n\\n' +  \n          `Locator: ${locator}\\n` +  \n          `Expected: not ${this.utils.printExpected(expected)}\\n` +  \n          (matcherResult ? `Received: ${this.utils.printReceived(matcherResult.actual)}` : '')  \n      : () =>  this.utils.matcherHint(assertionName, undefined, undefined, { isNot: this.isNot }) +  \n          '\\n\\n' +  \n          `Locator: ${locator}\\n` +  \n          `Expected: ${this.utils.printExpected(expected)}\\n` +  \n          (matcherResult ? `Received: ${this.utils.printReceived(matcherResult.actual)}` : '');  \n  \n    return {  \n      message,  \n      pass,  \n      name: assertionName,  \n      expected,  \n      actual: matcherResult?.actual,  \n    };  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: First we add a new project with the name 'setup db'. We then give it a [testProject.testMatch](/docs/api/class-testproject#test-project-test-match) property in order to match the file called `global.setup.ts`: | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  testDir: './tests',  \n  // ...  \n  projects: [  \n    {  \n      name: 'setup db',  \n      testMatch: /global\\.setup\\.ts/,  \n    },  \n    // {  \n    //   other project  \n    // }  \n  ]  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "New options `host` and `port` for the html reporter.", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['html', { host: 'localhost', port: '9223' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: This will find both buttons and throw a [strictness](/docs/locators#strictness) violation error:", "input": "", "output": "await page.locator('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Delete header  \nawait page.route('**/*', async route => {  \n  const headers = route.request().headers();  \n  delete headers['X-Secret'];  \n  await route.continue({ headers });  \n});  \n  \n// Continue requests as POST.  \nawait page.route('**/*', route => route.continue({ method: 'POST' }));", "output": "// Delete header  \nawait page.route('**/*', async route => {  \n  const headers = route.request().headers();  \n  delete headers['X-Secret'];  \n  await route.continue({ headers });  \n});  \n  \n// Continue requests as POST.  \nawait page.route('**/*', route => route.continue({ method: 'POST' }));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/network", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  workers: 1,  \n  testMatch: 'test.list.ts',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.locator('xpath=//button').click();", "output": "await page.locator('xpath=//button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "Use [test.describe.serial()](/docs/api/class-test#test-describe-serial) to group dependent tests to ensure they will always run together and in order. If one of the tests fails, all subsequent tests are skipped. All tests in the group are retried together. | Consider the following snippet that uses `test.describe.serial`:", "output": "import { test } from '@playwright/test';  \n  \ntest.describe.configure({ mode: 'serial' });  \n  \ntest.beforeAll(async () => { /* ... */ });  \ntest('first good', async ({ page }) => { /* ... */ });  \ntest('second flaky', async ({ page }) => { /* ... */ });  \ntest('third good', async ({ page }) => { /* ... */ });", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-retries", "type": "fixture"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "You can configure retries in the configuration file: | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Give failing tests 3 retry attempts  \n  retries: 3,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-retries"}}
{"instruction": "Generate a Playwright test for the following scenario: GitHub API requires authorization, so we'll configure the token once for all tests. While at it, we'll also set the `baseURL` to simplify the tests. You can either put them in the configuration file, or in the test file with `test.use()`. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    // All requests we send go to this API endpoint.  \n    baseURL: 'https://api.github.com',  \n    extraHTTPHeaders: {  \n      // We set this header per GitHub guidelines.  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add authorization token to all requests.  \n      // Assuming personal access token available in the environment.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    },  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/api-testing"}}
{"instruction": "Generate a Playwright test for the following scenario: component.spec.ts", "input": "", "output": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('event', async ({ mount }) => {  \n  const component = await mount(Component, { on: { click() {} } });  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        // It is important to define the `viewport` property after destructuring `devices`,  \n        // since devices also define the `viewport` for that device.  \n        viewport: { width: 1280, height: 720 },  \n      },  \n    },  \n  ]  \n});  \n\n\n\n// Create context with given viewport  \nconst context = await browser.newContext({  \n  viewport: { width: 1280, height: 1024 }  \n});", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        // It is important to define the `viewport` property after destructuring `devices`,  \n        // since devices also define the `viewport` for that device.  \n        viewport: { width: 1280, height: 720 },  \n      },  \n    },  \n  ]  \n});  \n\n\n\n// Create context with given viewport  \nconst context = await browser.newContext({  \n  viewport: { width: 1280, height: 1024 }  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/emulation", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const button = page.getByRole('button');  \n  \n// Make sure at least some part of element intersects viewport.  \nawait expect(button).toBeInViewport();  \n  \n// Make sure element is fully outside of viewport.  \nawait expect(button).not.toBeInViewport();  \n  \n// Make sure that at least half of the element intersects viewport.  \nawait expect(button).toBeInViewport({ ratio: 0.5 });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: 'dot',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Important: import our fixtures.  \nimport { test, expect } from '../playwright/fixtures';  \n  \ntest('test', async ({ page }) => {  \n  // page is authenticated  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/auth", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Add to cart", "output": "<ul>  \n  <li>  \n    <h3>Product 1</h3>  \n    <button>Add to cart</button>  \n  </li>  \n  <li>  \n    <h3>Product 2</h3>  \n    <button>Add to cart</button>  \n  </li>  \n</ul>  \n\n\n\nawait page  \n    .getByRole('listitem')  \n    .filter({ has: page.getByRole('heading', { name: 'Product 2' }) })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "navigation"}}
{"instruction": "Generate a Playwright test for the following scenario: Note: **component tests only** , does not affect end-to-end tests. | `playwright-ct.config` configuration file for [component testing](/docs/test-components) now requires calling `defineConfig`.", "input": "", "output": "// Before  \n  \nimport { type PlaywrightTestConfig, devices } from '@playwright/experimental-ct-react';  \nconst config: PlaywrightTestConfig = {  \n  // ... config goes here ...  \n};  \nexport default config;", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.getByLabel('Password').focus();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.locator('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Example\u200b | Here is what a typical component test looks like:", "input": "", "output": "test('event should work', async ({ mount }) => {  \n  let clicked = false;  \n  \n  // Mount a component. Returns locator pointing to the component.  \n  const component = await mount(  \n    <Button title=\"Submit\" onClick={() => { clicked = true }}></Button>  \n  );  \n  \n  // As with any Playwright test, assert locator text.  \n  await expect(component).toContainText('Submit');  \n  \n  // Perform locator click. This will trigger the event.  \n  await component.click();  \n  \n  // Assert that respective events have been fired.  \n  expect(clicked).toBeTruthy();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "Custom config options are a convenient way to parametrize projects with different values. Learn more in [this guide](/docs/test-parameterize#parameterized-projects). | Previously, any fixture introduced through [test.extend()](/docs/api/class-test#test-extend) could be overridden in the [testProject.use](/docs/api/class-testproject#test-project-use) config section. For example,", "output": "// WRONG: THIS SNIPPET DOES NOT WORK SINCE v1.18.  \n  \n// fixtures.js  \nconst test = base.extend({  \n  myParameter: 'default',  \n});  \n  \n// playwright.config.js  \nmodule.exports = {  \n  use: {  \n    myParameter: 'value',  \n  },  \n};", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Filter by text\u200b | Locators can be filtered by text with the [locator.filter()](/docs/api/class-locator#locator-filter) method. It will search for a particular string somewhere inside the element, possibly in a descendant element, case-insensitively. You can also pass a regular expression.", "output": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: 'Product 2' })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Modern pages perform numerous activities after the `load` event was fired. They fetch data lazily, populate UI, load expensive resources, scripts and styles after the `load` event was fired. There is no way to tell that the page is `loaded`, it depends on the page, framework, etc. So when can you start interacting with it? | In Playwright you can interact with the page at any moment. It will automatically wait for the target elements to become [actionable](/docs/actionability).", "output": "// Navigate and click element  \n// Click will auto-wait for the element  \nawait page.goto('https://example.com');  \nawait page.getByText('Example Domain').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/navigations"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "We recommend the modern [text locator](/docs/locators#get-by-text) instead. | Legacy text locator matches elements that contain passed text.", "output": "await page.locator('text=Log in').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/test';  \n  \ntest.beforeEach(async ({ page }) => {  \n  // Runs before each test and signs in each page.  \n  await page.goto('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('username');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n});  \n  \ntest('first', async ({ page }) => {  \n  // page is signed in.  \n});  \n  \ntest('second', async ({ page }) => {  \n  // page is signed in.  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/best-practices", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Navigate and click element  \n// Click will auto-wait for the element  \nawait page.navigate('https://example.com');  \nawait page.getByText('Example Domain').click();", "output": "// Navigate and click element  \n// Click will auto-wait for the element  \nawait page.goto('https://example.com');  \nawait page.getByText('Example Domain').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/navigations", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from './my-test';  \n  \ntest('test 1', async ({ page, person }) => {  \n  await page.navigate(`/index.html`);  \n  await assert(page.locator('#node')).toContainText(person);  \n  // ...  \n});", "output": "import { test } from './my-test';  \n  \ntest('test 1', async ({ page, person }) => {  \n  await page.goto(`/index.html`);  \n  await expect(page.locator('#node')).toContainText(person);  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parameterize", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.route('**/api/fetch_data', route => route.fulfill({  \n  status: 200,  \n  body: testData,  \n}));  \nawait page.navigate('https://example.com');", "output": "await page.route('**/api/fetch_data', route => route.fulfill({  \n  status: 200,  \n  body: testData,  \n}));  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Whether to automatically download all the attachments.  \n    acceptDownloads: false,  \n  \n    // An object containing additional HTTP headers to be sent with every request.  \n    extraHTTPHeaders: {  \n      'X-My-Header': 'value',  \n    },  \n  \n    // Credentials for HTTP authentication.  \n    httpCredentials: {  \n      username: 'user',  \n      password: 'pass',  \n    },  \n  \n    // Whether to ignore HTTPS errors during navigation.  \n    ignoreHTTPSErrors: true,  \n  \n    // Whether to emulate network being offline.  \n    offline: true,  \n  \n    // Proxy settings used for all pages in the test.  \n    proxy: {  \n      server: 'http://myproxy.com:3128',  \n      bypass: 'localhost',  \n    },  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: To ensure that `<x-details>` contains the text \"Details\":", "input": "", "output": "await expect(page.locator('x-details')).toContainText('Details');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Specify `globalSetup`, `baseURL` and `storageState` in the configuration file. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  globalSetup: require.resolve('./global-setup'),  \n  use: {  \n    baseURL: 'http://localhost:3000/',  \n    storageState: 'state.json',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const { webkit, devices } = require('playwright');  \nconst iPhone = devices['iPhone 6'];  \n  \n(async () => {  \n  const browser = await webkit.launch();  \n  const context = await browser.newContext({  \n    ...iPhone  \n  });  \n  const page = await context.newPage();  \n  await page.goto('http://example.com');  \n  // other actions...  \n  await browser.close();  \n})();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/api/class-playwright", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const context = await browser.newContext({  \n  recordHar: { path: 'github.har.zip' }  \n});  \n// ... do stuff ...  \nawait context.close();", "output": "const context = await browser.newContext({  \n  recordHar: { path: 'github.har.zip' }  \n});  \n// ... do stuff ...  \nawait context.close();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Clicks a <button> that has either a \"Log in\" or \"Sign in\" text.  \nawait page.locator('button:has-text(\"Log in\"), button:has-text(\"Sign in\")').click();", "output": "// Clicks a <button> that has either a \"Log in\" or \"Sign in\" text.  \nawait page.locator('button:has-text(\"Log in\"), button:has-text(\"Sign in\")').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Using the following, Playwright will run your WebView2 application as a sub-process, assign a unique user data directory to it and provide the [Page](/docs/api/class-page \"Page\") instance to your test: | webView2Test.ts", "input": "", "output": "import { test as base } from '@playwright/test';  \nimport fs from 'fs';  \nimport os from 'os';  \nimport path from 'path';  \nimport childProcess from 'child_process';  \n  \nconst EXECUTABLE_PATH = path.join(  \n    __dirname,  \n    '../../webview2-app/bin/Debug/net8.0-windows/webview2.exe',  \n);  \n  \nexport const test = base.extend({  \n  browser: async ({ playwright }, use, testInfo) => {  \n    const cdpPort = 10000 + testInfo.workerIndex;  \n    // Make sure that the executable exists and is executable  \n    fs.accessSync(EXECUTABLE_PATH, fs.constants.X_OK);  \n    const userDataDir = path.join(  \n        fs.realpathSync.native(os.tmpdir()),  \n        `playwright-webview2-tests/user-data-dir-${testInfo.workerIndex}`,  \n    );  \n    const webView2Process = childProcess.spawn(EXECUTABLE_PATH, [], {  \n      shell: true,  \n      env: {  \n        ...process.env,  \n        WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS: `--remote-debugging-port=${cdpPort}`,  \n        WEBVIEW2_USER_DATA_FOLDER: userDataDir,  \n      }  \n    });  \n    await new Promise<void>(resolve => webView2Process.stdout.on('data', data => {  \n      if (data.toString().includes('WebView2 initialized'))  \n        resolve();  \n    }));  \n    const browser = await playwright.chromium.connectOverCDP(`http://127.0.0.1:${cdpPort}`);  \n    await use(browser);  \n    await browser.close();  \n    childProcess.execSync(`taskkill /pid ${webView2Process.pid} /T /F`);  \n    fs.rmdirSync(userDataDir, { recursive: true });  \n  },  \n  context: async ({ browser }, use) => {  \n    const context = browser.contexts()[0];  \n    await use(context);  \n  },  \n  page: async ({ context }, use) => {  \n    const page = context.pages()[0];  \n    await use(page);  \n  },  \n});  \n  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/webview2"}}
{"instruction": "Generate a Playwright test for the following scenario: models/PlaywrightDevPage.js", "input": "", "output": "class PlaywrightDevPage {  \n  /**  \n   * @param {import('playwright').Page} page  \n   */  \n  constructor(page) {  \n    this.page = page;  \n    this.getStartedLink = page.locator('a', { hasText: 'Get started' });  \n    this.gettingStartedHeader = page.locator('h1', { hasText: 'Installation' });  \n    this.pomLink = page.locator('li', {  \n      hasText: 'Playwright Test',  \n    }).locator('a', {  \n      hasText: 'Page Object Model',  \n    });  \n    this.tocList = page.locator('article div.markdown ul > li > a');  \n  }  \n  async getStarted() {  \n    await this.getStartedLink.first().click();  \n    await expect(this.gettingStartedHeader).toBeVisible();  \n  }  \n  \n  async pageObjectModel() {  \n    await this.getStarted();  \n    await this.pomLink.click();  \n  }  \n}  \nmodule.exports = { PlaywrightDevPage };", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/pom"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "[  \n  { name: 'Alice', asserted: 'Hello, Alice!' },  \n  { name: 'Bob', asserted: 'Hello, Bob!' },  \n  { name: 'Charlie', asserted: 'Hello, Charlie!' },  \n].forEach(({ name, asserted }) => {  \n  // You can also do it with test.describe() or with multiple tests as long the test name is unique.  \n  test(`testing with ${name}`, async ({ page }) => {  \n    await page.navigate(`https://example.com/greet?name=${name}`);  \n    await assert(page.getByRole('heading')).toHaveText(asserted);  \n  });  \n});", "output": "[  \n  { name: 'Alice', expected: 'Hello, Alice!' },  \n  { name: 'Bob', expected: 'Hello, Bob!' },  \n  { name: 'Charlie', expected: 'Hello, Charlie!' },  \n].forEach(({ name, expected }) => {  \n  // You can also do it with test.describe() or with multiple tests as long the test name is unique.  \n  test(`testing with ${name}`, async ({ page }) => {  \n    await page.goto(`https://example.com/greet?name=${name}`);  \n    await expect(page.getByRole('heading')).toHaveText(expected);  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parameterize", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('unmount', async ({ mount }) => {  \n  const component = await mount(<Component/>);  \n  await component.unmount();  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const { webkit } = require('playwright');  \n  \n(async () => {  \n  const browser = await webkit.launch();  \n  const page = await browser.newPage();  \n  await page.navigate('https://playwright.dev/');  \n  await page.screenshot({ path: `example.png` });  \n  await browser.close();  \n})();", "output": "const { webkit } = require('playwright');  \n  \n(async () => {  \n  const browser = await webkit.launch();  \n  const page = await browser.newPage();  \n  await page.goto('https://playwright.dev/');  \n  await page.screenshot({ path: `example.png` });  \n  await browser.close();  \n})();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/library", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert(page).toHaveTitle(/Playwright/);", "output": "await expect(page).toHaveTitle(/Playwright/);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/writing-tests", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Variations\u200b | Set up route on the entire browser context with [browserContext.route()](/docs/api/class-browsercontext#browser-context-route) or page with [page.route()](/docs/api/class-page#page-route). It will apply to popup windows and opened links.", "output": "await browserContext.route('**/api/login', route => route.fulfill({  \n  status: 200,  \n  body: 'accept',  \n}));  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "component.spec.tsx", "output": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('unmount', async ({ mount }) => {  \n  const component = await mount(<Component/>);  \n  await component.unmount();  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Give failing tests 3 retry attempts  \n  retries: 3,  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Give failing tests 3 retry attempts  \n  retries: 3,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-retries", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Fill an input to the right of \"Username\".  \nawait page.locator('input:right-of(:text(\"Username\"))').fill('value');  \n  \n// Click a button near the promo card.  \nawait page.locator('button:near(.promo-card)').click();  \n  \n// Click the radio input in the list closest to the \"Label 3\".  \nawait page.locator('[type=radio]:left-of(:text(\"Label 3\"))').first().click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect(page.getByRole('heading', { name: 'Sign up' })).toBeVisible();  \n  \nawait page.getByRole('checkbox', { name: 'Subscribe' }).check();  \n  \nawait page.getByRole('button', { name: /submit/i }).click();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Use the count assertion to ensure that the list has 3 items.", "input": "", "output": "await expect(page.getByRole('listitem')).toHaveCount(3);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "<div id=\"current-time\" data-testid=\"current-time\"></div>  \n<script>  \n  const renderTime = () => {  \n    document.getElementById('current-time').textContent =  \n        new Date().toLocaleString();  \n  };  \n  setInterval(renderTime, 1000);  \n</script>  \n\n\n\n// Initialize clock with some time before the test time and let the page load  \n// naturally. `Date.now` will progress as the timers fire.  \nawait page.clock.install({ time: new Date('2024-02-02T08:00:00') });  \nawait page.goto('http://localhost:3333');  \n  \n// Pretend that the user closed the laptop lid and opened it again at 10am,  \n// Pause the time once reached that point.  \nawait page.clock.pauseAt(new Date('2024-02-02T10:00:00'));  \n  \n// Assert the page state.  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \n// Close the laptop lid again and open it at 10:30am.  \nawait page.clock.fastForward('30:00');  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:30:00 AM');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/clock", "type": "completion"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \nimport path from 'path';  \n  \ntest.beforeEach(async ({ page }) => {  \n  // Add script for every test in the beforeEach hook.  \n  // Make sure to correctly resolve the script path.  \n  await page.addInitScript({ path: path.resolve(__dirname, '../mocks/preload.js') });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/evaluating", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest('loads page without images', async ({ page }) => {  \n  // Block png and jpeg images.  \n  await page.route(/(png|jpeg)$/, route => route.abort());  \n  \n  await page.navigate('https://playwright.dev');  \n  // ... test goes here  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('loads page without images', async ({ page }) => {  \n  // Block png and jpeg images.  \n  await page.route(/(png|jpeg)$/, route => route.abort());  \n  \n  await page.goto('https://playwright.dev');  \n  // ... test goes here  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/network", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: The `:has()` pseudo-class is an [experimental CSS pseudo-class](https://developer.mozilla.org/en-US/docs/Web/CSS/:has). It returns an element if any of the selectors passed as parameters relative to the `:scope` of the given element match at least one element. | Following snippet returns text content of an `<article>` element that has a `<div class=promo>` inside.", "input": "", "output": "await page.locator('article:has(div.promo)').textContent();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \nconst REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \n// Request context is reused by all tests in the file.  \nlet apiContext;  \n  \ntest.beforeAll(async ({ playwright }) => {  \n  apiContext = await playwright.request.newContext({  \n    // All requests we send go to this API endpoint.  \n    baseURL: 'https://api.github.com',  \n    extraHTTPHeaders: {  \n      // We set this header per GitHub guidelines.  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add authorization token to all requests.  \n      // Assuming personal access token available in the environment.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    },  \n  });  \n});  \n  \ntest.afterAll(async ({ }) => {  \n  // Dispose all responses.  \n  await apiContext.dispose();  \n});  \n  \ntest('last created issue should be first in the list', async ({ page }) => {  \n  const newIssue = await apiContext.post(`/repos/${USER}/${REPO}/issues`, {  \n    data: {  \n      title: '[Feature] request 1',  \n    }  \n  });  \n  assert(newIssue.ok()).toBeTruthy();  \n  \n  await page.navigate(`https://github.com/${USER}/${REPO}/issues`);  \n  const firstIssue = page.locator(`a[data-hovercard-type='issue']`).first();  \n  await assert(firstIssue).toHaveText('[Feature] request 1');  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \nconst REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \n// Request context is reused by all tests in the file.  \nlet apiContext;  \n  \ntest.beforeAll(async ({ playwright }) => {  \n  apiContext = await playwright.request.newContext({  \n    // All requests we send go to this API endpoint.  \n    baseURL: 'https://api.github.com',  \n    extraHTTPHeaders: {  \n      // We set this header per GitHub guidelines.  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add authorization token to all requests.  \n      // Assuming personal access token available in the environment.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    },  \n  });  \n});  \n  \ntest.afterAll(async ({ }) => {  \n  // Dispose all responses.  \n  await apiContext.dispose();  \n});  \n  \ntest('last created issue should be first in the list', async ({ page }) => {  \n  const newIssue = await apiContext.post(`/repos/${USER}/${REPO}/issues`, {  \n    data: {  \n      title: '[Feature] request 1',  \n    }  \n  });  \n  expect(newIssue.ok()).toBeTruthy();  \n  \n  await page.goto(`https://github.com/${USER}/${REPO}/issues`);  \n  const firstIssue = page.locator(`a[data-hovercard-type='issue']`).first();  \n  await expect(firstIssue).toHaveText('[Feature] request 1');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/api-testing", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: New `caret` option in [page.screenshot()](/docs/api/class-page#page-screenshot) to control text caret. Defaults to `\"hide\"`. | New method `expect.poll` to wait for an arbitrary condition:", "input": "", "output": "// Poll the method until it returns an expected result.  \nawait expect.poll(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  return response.status();  \n}).toBe(200);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: Trace files, screenshots and videos will appear in the test output directory, typically `test-results`. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Capture screenshot after each test failure.  \n    screenshot: 'only-on-failure',  \n  \n    // Record trace only when retrying a test for the first time.  \n    trace: 'on-first-retry',  \n  \n    // Record video only when retrying a test for the first time.  \n    video: 'on-first-retry'  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  // \"page\" belongs to an isolated BrowserContext, created for this specific test.  \n});  \n  \ntest('another test', async ({ page }) => {  \n  // \"page\" in this second test is completely isolated from the first test.  \n});", "output": "import { test } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  // \"page\" belongs to an isolated BrowserContext, created for this specific test.  \n});  \n  \ntest('another test', async ({ page }) => {  \n  // \"page\" in this second test is completely isolated from the first test.  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/writing-tests", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Using `globalSetup` and `globalTeardown` will not produce traces or artifacts, and options like `headless` or `testIdAttribute` specified in the config file are not applied. If you want to produce traces and artifacts and respect config options, use project dependencies. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  globalSetup: require.resolve('./global-setup'),  \n  globalTeardown: require.resolve('./global-teardown'),  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { mergeTests } from '@playwright/test';  \nimport { test as dbTest } from 'database-test-utils';  \nimport { test as a11yTest } from 'a11y-test-utils';  \n  \nexport const test = mergeTests(dbTest, a11yTest);", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from './fixtures';  \nimport { expect } from '@playwright/test';  \n  \ntest('basic', async ({ page }) => {  \n  expect(page).toHaveURL('http://localhost:8000');  \n  await page.goto('https://playwright.dev');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "component.spec.tsx", "output": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('event', async ({ mount }) => {  \n  const component = await mount(<Component v-on:click={() => {}} />);  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "navigation"}}
{"instruction": "Generate a Playwright test for the following scenario: Print dialogs\u200b | In order to assert that a print dialog via [`window.print`](https://developer.mozilla.org/en-US/docs/Web/API/Window/print) was triggered, you can use the following snippet:", "input": "", "output": "await page.goto('<url>');  \n  \nawait page.evaluate('(() => {window.waitForPrintDialog = new Promise(f => window.print = f);})()');  \nawait page.getByText('Print it!').click();  \n  \nawait page.waitForFunction('window.waitForPrintDialog');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/dialogs"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('basic test', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  \n  await expect(page).toHaveTitle(/Playwright/);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Only test what you control. Don't try to test links to external sites or third party servers that you do not control. Not only is it time consuming and can slow down your tests but also you cannot control the content of the page you are linking to, or if there are cookie banners or overlay pages or anything else that might cause your test to fail. | Instead, use the [Playwright Network API](/docs/network#handle-requests) and guarantee the response needed.", "output": "await page.route('**/api/fetch_data_third_party_dependency', route => route.fulfill({  \n  status: 200,  \n  body: testData,  \n}));  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/best-practices", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Clicks a <button> that has either a \"Log in\" or \"Sign in\" text.  \nawait page.locator('button:has-text(\"Log in\"), button:has-text(\"Sign in\")').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('event', async ({ mount }) => {  \n  const component = await mount(Component, { on: { click() {} } });  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: axe-test.ts", "input": "", "output": "import { test as base } from '@playwright/test';  \nimport AxeBuilder from '@axe-core/playwright';  \n  \ntype AxeFixture = {  \n  makeAxeBuilder: () => AxeBuilder;  \n};  \n  \n// Extend base test by providing \"makeAxeBuilder\"  \n//  \n// This new \"test\" can be used in multiple test files, and each of them will get  \n// a consistently configured AxeBuilder instance.  \nexport const test = base.extend<AxeFixture>({  \n  makeAxeBuilder: async ({ page }, use, testInfo) => {  \n    const makeAxeBuilder = () => new AxeBuilder({ page })  \n        .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])  \n        .exclude('#commonly-reused-element-with-known-issue');  \n  \n    await use(makeAxeBuilder);  \n  }  \n});  \nexport { expect } from '@playwright/test';  \n\n\n\n// axe-test.js  \nconst base = require('@playwright/test');  \nconst AxeBuilder = require('@axe-core/playwright').default;  \n  \n// Extend base test by providing \"makeAxeBuilder\"  \n//  \n// This new \"test\" can be used in multiple test files, and each of them will get  \n// a consistently configured AxeBuilder instance.  \nexports.test = base.test.extend({  \n  makeAxeBuilder: async ({ page }, use, testInfo) => {  \n    const makeAxeBuilder = () => new AxeBuilder({ page })  \n        .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])  \n        .exclude('#commonly-reused-element-with-known-issue');  \n  \n    await use(makeAxeBuilder);  \n  }  \n});  \nexports.expect = base.expect;", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/accessibility-testing"}}
{"instruction": "Generate a Playwright test for the following scenario: N-th element locator\u200b | You can narrow down query to the n-th match using the `nth=` locator passing a zero-based index.", "input": "", "output": "// Click first button  \nawait page.locator('button').locator('nth=0').click();  \n  \n// Click last button  \nawait page.locator('button').locator('nth=-1').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/test';  \nimport featureBTests from './feature-b.spec.ts';  \nimport featureATests from './feature-a.spec.ts';  \n  \ntest.describe(featureBTests);  \ntest.describe(featureATests);", "output": "import { test } from '@playwright/test';  \nimport featureBTests from './feature-b.spec.ts';  \nimport featureATests from './feature-a.spec.ts';  \n  \ntest.describe(featureBTests);  \ntest.describe(featureATests);", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: We recommend prioritizing [user-visible locators](/docs/locators#quick-guide) like text or accessible role instead of using XPath that is tied to the implementation and easily break when the page changes. | XPath locators are equivalent to calling [`Document.evaluate`](https://developer.mozilla.org/en/docs/Web/API/Document/evaluate).", "input": "", "output": "await page.locator('xpath=//button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "page.on('dialog', async dialog => {  \n  assert(dialog.type() === 'beforeunload');  \n  await dialog.dismiss();  \n});  \nawait page.close({ runBeforeUnload: true });", "output": "page.on('dialog', async dialog => {  \n  assert(dialog.type() === 'beforeunload');  \n  await dialog.dismiss();  \n});  \nawait page.close({ runBeforeUnload: true });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/dialogs", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Run a test from a specific breakpoint\u200b | To speed up the debugging process you can add a [page.pause()](/docs/api/class-page#page-pause) method to your test. This way you won't have to step through each action of your test to get to the point where you want to debug.", "output": "await page.pause();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/debug"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  helperFixture: [async ({}, use, testInfo) => {  \n    // ...  \n  }, { box: true }],  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "warning | WRONG!", "output": "page.on('dialog', dialog => console.log(dialog.message()));  \nawait page.getByRole('button').click(); // Will hang here", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/dialogs"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        // It is important to define the `isMobile` property after destructuring `devices`,  \n        // since devices also define the `isMobile` for that device.  \n        isMobile: false,  \n      },  \n    },  \n  ]  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/emulation", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Capture screenshot after each test failure.  \n    screenshot: 'only-on-failure',  \n  \n    // Record trace only when retrying a test for the first time.  \n    trace: 'on-first-retry',  \n  \n    // Record video only when retrying a test for the first time.  \n    video: 'on-first-retry'  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Capture screenshot after each test failure.  \n    screenshot: 'only-on-failure',  \n  \n    // Record trace only when retrying a test for the first time.  \n    trace: 'on-first-retry',  \n  \n    // Record video only when retrying a test for the first time.  \n    video: 'on-first-retry'  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: app.spec.tsx", "input": "", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport App from './App';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<App />);  \n  await expect(component).toContainText('Learn React');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "Establishing preconditions\u200b | The following test creates a new issue via API and then navigates to the list of all issues in the project to check that it appears at the top of the list.", "output": "import { test, expect } from '@playwright/test';  \n  \nconst REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \n// Request context is reused by all tests in the file.  \nlet apiContext;  \n  \ntest.beforeAll(async ({ playwright }) => {  \n  apiContext = await playwright.request.newContext({  \n    // All requests we send go to this API endpoint.  \n    baseURL: 'https://api.github.com',  \n    extraHTTPHeaders: {  \n      // We set this header per GitHub guidelines.  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add authorization token to all requests.  \n      // Assuming personal access token available in the environment.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    },  \n  });  \n});  \n  \ntest.afterAll(async ({ }) => {  \n  // Dispose all responses.  \n  await apiContext.dispose();  \n});  \n  \ntest('last created issue should be first in the list', async ({ page }) => {  \n  const newIssue = await apiContext.post(`/repos/${USER}/${REPO}/issues`, {  \n    data: {  \n      title: '[Feature] request 1',  \n    }  \n  });  \n  expect(newIssue.ok()).toBeTruthy();  \n  \n  await page.goto(`https://github.com/${USER}/${REPO}/issues`);  \n  const firstIssue = page.locator(`a[data-hovercard-type='issue']`).first();  \n  await expect(firstIssue).toHaveText('[Feature] request 1');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/api-testing", "type": "fixture"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.addInitScript(() => {  \n  Object.defineProperty(Object.getPrototypeOf(navigator), 'cookieEnabled', { value: false });  \n});", "output": "await page.addInitScript(() => {  \n  Object.defineProperty(Object.getPrototypeOf(navigator), 'cookieEnabled', { value: false });  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/mock-browser-apis", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test('example', async ({ page }) => {  \n  console.log(test.info().tags);  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as base } from '@playwright/test';  \nimport { TodoPage } from './todo-page';  \n  \n// Extend basic test by providing a \"todoPage\" fixture.  \nconst test = base.extend<{ todoPage: TodoPage }>({  \n  todoPage: async ({ page }, use) => {  \n    const todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo('item1');  \n    await todoPage.addToDo('item2');  \n    await use(todoPage);  \n    await todoPage.removeAll();  \n  },  \n});  \n  \ntest('should add an item', async ({ todoPage }) => {  \n  await todoPage.addToDo('my item');  \n  // ...  \n});  \n  \ntest('should remove an item', async ({ todoPage }) => {  \n  await todoPage.remove('item1');  \n  // ...  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: The main difference is that [APIRequestContext](/docs/api/class-apirequestcontext \"APIRequestContext\") accessible via [browserContext.request](/docs/api/class-browsercontext#browser-context-request) and [page.request](/docs/api/class-page#page-request) will populate request's `Cookie` header from the browser context and will automatically update browser cookies if [APIResponse](/docs/api/class-apiresponse \"APIResponse\") has `Set-Cookie` header:", "input": "", "output": "test('context request will share cookie storage with its browser context', async ({  \n  page,  \n  context,  \n}) => {  \n  await context.route('https://www.github.com/', async route => {  \n    // Send an API request that shares cookie storage with the browser context.  \n    const response = await context.request.fetch(route.request());  \n    const responseHeaders = response.headers();  \n  \n    // The response will have 'Set-Cookie' header.  \n    const responseCookies = new Map(responseHeaders['set-cookie']  \n        .split('\\n')  \n        .map(c => c.split(';', 2)[0].split('=')));  \n    // The response will have 3 cookies in 'Set-Cookie' header.  \n    expect(responseCookies.size).toBe(3);  \n    const contextCookies = await context.cookies();  \n    // The browser context will already contain all the cookies from the API response.  \n    expect(new Map(contextCookies.map(({ name, value }) =>  \n      [name, value])  \n    )).toEqual(responseCookies);  \n  \n    await route.fulfill({  \n      response,  \n      headers: { ...responseHeaders, foo: 'bar' },  \n    });  \n  });  \n  await page.goto('https://www.github.com/');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/api-testing"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as baseTest, assert } from '@playwright/test';  \nimport fs from 'fs';  \nimport path from 'path';  \n  \nexport * from '@playwright/test';  \nexport const test = baseTest.extend<{}, { workerStorageState: string }>({  \n  // Use the same storage state for all tests in this worker.  \n  storageState: ({ workerStorageState }, use) => use(workerStorageState),  \n  \n  // Authenticate once per worker with a worker-scoped fixture.  \n  workerStorageState: [async ({ browser }, use) => {  \n    // Use parallelIndex as a unique identifier for each worker.  \n    const id = test.info().parallelIndex;  \n    const fileName = path.resolve(test.info().project.outputDir, `.auth/${id}.json`);  \n  \n    if (fs.existsSync(fileName)) {  \n      // Reuse existing authentication state if any.  \n      await use(fileName);  \n      return;  \n    }  \n  \n    // Important: make sure we authenticate in a clean environment by unsetting storage state.  \n    const page = await browser.newPage({ storageState: undefined });  \n  \n    // Acquire a unique account, for example create a new one.  \n    // Alternatively, you can have a list of precreated accounts for testing.  \n    // Make sure that accounts are unique, so that multiple team members  \n    // can run tests at the same time without interference.  \n    const account = await acquireAccount(id);  \n  \n    // Perform authentication steps. Replace these actions with your own.  \n    await page.navigate('https://github.com/login');  \n    await page.getByLabel('Username or email address').fill(account.username);  \n    await page.getByLabel('Password').fill(account.password);  \n    await page.getByRole('button', { name: 'Sign in' }).click();  \n    // Wait until the page receives the cookies.  \n    //  \n    // Sometimes login flow sets cookies in the process of several redirects.  \n    // Wait for the final URL to ensure that the cookies are actually set.  \n    await page.waitForURL('https://github.com/');  \n    // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n    await assert(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n    // End of authentication steps.  \n  \n    await page.context().storageState({ path: fileName });  \n    await page.close();  \n    await use(fileName);  \n  }, { scope: 'worker' }],  \n});", "output": "import { test as baseTest, expect } from '@playwright/test';  \nimport fs from 'fs';  \nimport path from 'path';  \n  \nexport * from '@playwright/test';  \nexport const test = baseTest.extend<{}, { workerStorageState: string }>({  \n  // Use the same storage state for all tests in this worker.  \n  storageState: ({ workerStorageState }, use) => use(workerStorageState),  \n  \n  // Authenticate once per worker with a worker-scoped fixture.  \n  workerStorageState: [async ({ browser }, use) => {  \n    // Use parallelIndex as a unique identifier for each worker.  \n    const id = test.info().parallelIndex;  \n    const fileName = path.resolve(test.info().project.outputDir, `.auth/${id}.json`);  \n  \n    if (fs.existsSync(fileName)) {  \n      // Reuse existing authentication state if any.  \n      await use(fileName);  \n      return;  \n    }  \n  \n    // Important: make sure we authenticate in a clean environment by unsetting storage state.  \n    const page = await browser.newPage({ storageState: undefined });  \n  \n    // Acquire a unique account, for example create a new one.  \n    // Alternatively, you can have a list of precreated accounts for testing.  \n    // Make sure that accounts are unique, so that multiple team members  \n    // can run tests at the same time without interference.  \n    const account = await acquireAccount(id);  \n  \n    // Perform authentication steps. Replace these actions with your own.  \n    await page.goto('https://github.com/login');  \n    await page.getByLabel('Username or email address').fill(account.username);  \n    await page.getByLabel('Password').fill(account.password);  \n    await page.getByRole('button', { name: 'Sign in' }).click();  \n    // Wait until the page receives the cookies.  \n    //  \n    // Sometimes login flow sets cookies in the process of several redirects.  \n    // Wait for the final URL to ensure that the cookies are actually set.  \n    await page.waitForURL('https://github.com/');  \n    // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n    await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n    // End of authentication steps.  \n  \n    await page.context().storageState({ path: fileName });  \n    await page.close();  \n    await use(fileName);  \n  }, { scope: 'worker' }],  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/auth", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.getByText('orange').click();", "output": "await page.getByText('orange').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "test.beforeEach(async ({ page }) => {  \n  // ...  \n});  \n  \ntest.afterEach(async ({ page }) => {  \n  // ...  \n});  \n  \n[  \n  { name: 'Alice', expected: 'Hello, Alice!' },  \n  { name: 'Bob', expected: 'Hello, Bob!' },  \n  { name: 'Charlie', expected: 'Hello, Charlie!' },  \n].forEach(({ name, expected }) => {  \n  test(`testing with ${name}`, async ({ page }) => {  \n    await page.goto(`https://example.com/greet?name=${name}`);  \n    await expect(page.getByRole('heading')).toHaveText(expected);  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parameterize", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Playwright Test v1.19 now supports _soft assertions_. Failed soft assertions | **do not** terminate test execution, but mark the test as failed.", "output": "// Make a few checks that will not stop the test when failed...  \nawait expect.soft(page.locator('#status')).toHaveText('Success');  \nawait expect.soft(page.locator('#eta')).toHaveText('1 day');  \n  \n// ... and continue the test to check more things.  \nawait page.locator('#next-page').click();  \nawait expect.soft(page.locator('#title')).toHaveText('Make another order');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: Programmatic click\u200b | If you are not interested in testing your app under the real conditions and want to simulate the click by any means possible, you can trigger the [`HTMLElement.click()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click) behavior via simply dispatching a click event on the element with [locator.dispatchEvent()](/docs/api/class-locator#locator-dispatch-event):", "input": "", "output": "await page.getByRole('button').dispatchEvent('click');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Create new array in page.  \nconst myArrayHandle = await page.evaluateHandle(() => {  \n  window.myArray = [1];  \n  return myArray;  \n});  \n  \n// Get the length of the array.  \nconst length = await page.evaluate(a => a.length, myArrayHandle);  \n  \n// Add one more element to the array using the handle  \nawait page.evaluate(arg => arg.myArray.push(arg.newElement), {  \n  myArray: myArrayHandle,  \n  newElement: 2  \n});  \n  \n// Release the object when it's no longer needed.  \nawait myArrayHandle.dispose();", "output": "// Create new array in page.  \nconst myArrayHandle = await page.evaluateHandle(() => {  \n  window.myArray = [1];  \n  return myArray;  \n});  \n  \n// Get the length of the array.  \nconst length = await page.evaluate(a => a.length, myArrayHandle);  \n  \n// Add one more element to the array using the handle  \nawait page.evaluate(arg => arg.myArray.push(arg.newElement), {  \n  myArray: myArrayHandle,  \n  newElement: 2  \n});  \n  \n// Release the object when it's no longer needed.  \nawait myArrayHandle.dispose();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/handles", "type": "modification"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "Now we can use `toHaveAmount` in the test. | example.spec.ts", "output": "import { test, expect } from './fixtures';  \n  \ntest('amount', async () => {  \n  await expect(page.locator('.cart')).toHaveAmount(4);  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-assertions", "type": "fixture"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(Component);  \n  await component.update({  \n    props: { msg: 'greetings' },  \n    on: { click() {} },  \n    slots: { default: 'Child' }  \n  });  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Trace files, screenshots and videos will appear in the test output directory, typically `test-results`. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Capture screenshot after each test failure.  \n    screenshot: 'only-on-failure',  \n  \n    // Record trace only when retrying a test for the first time.  \n    trace: 'on-first-retry',  \n  \n    // Record video only when retrying a test for the first time.  \n    video: 'on-first-retry'  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest('test login page', {  \n  tag: '@fast',  \n}, async ({ page }) => {  \n  // ...  \n});  \n  \ntest('test full report @slow', async ({ page }) => {  \n  // ...  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('test login page', {  \n  tag: '@fast',  \n}, async ({ page }) => {  \n  // ...  \n});  \n  \ntest('test full report @slow', async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You can combine custom matchers from multiple files or modules. | fixtures.ts", "output": "import { mergeTests, mergeExpects } from '@playwright/test';  \nimport { test as dbTest, expect as dbExpect } from 'database-test-utils';  \nimport { test as a11yTest, expect as a11yExpect } from 'a11y-test-utils';  \n  \nexport const expect = mergeExpects(dbExpect, a11yExpect);  \nexport const test = mergeTests(dbTest, a11yTest);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Generate a Playwright test for the following scenario: By setting up projects we can also run a group of tests with different timeouts or retries or run a group of tests against different environments. For example we can run our tests against a staging environment with 2 retries as well as against a production environment with 0 retries. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  timeout: 60000, // Timeout is shared between all tests.  \n  projects: [  \n    {  \n      name: 'staging',  \n      use: {  \n        baseURL: 'staging.example.com',  \n      },  \n      retries: 2,  \n    },  \n    {  \n      name: 'production',  \n      use: {  \n        baseURL: 'production.example.com',  \n      },  \n      retries: 0,  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-projects"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.navigate('https://playwright.dev/');", "output": "await page.goto('https://playwright.dev/');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/writing-tests", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Use web first assertions such as `toBeVisible()` instead.", "output": "// \ud83d\udc4d  \nawait expect(page.getByText('welcome')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/best-practices"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Or wait for a network response after the button click with [page.waitForResponse()](/docs/api/class-page#page-wait-for-response):", "output": "// Use a glob URL pattern. Note no await.  \nconst responsePromise = page.waitForResponse('**/api/fetch_data');  \nawait page.getByText('Update').click();  \nconst response = await responsePromise;", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "<div id=\"current-time\" data-testid=\"current-time\"></div>  \n<script>  \n  const renderTime = () => {  \n    document.getElementById('current-time').textContent =  \n        new Date().toLocaleString();  \n  };  \n  setInterval(renderTime, 1000);  \n</script>  \n\n\n\n// Initialize clock with a specific time, let the page load naturally.  \nawait page.clock.install({ time: new Date('2024-02-02T08:00:00') });  \nawait page.goto('http://localhost:3333');  \n  \n// Pause the time flow, stop the timers, you now have manual control  \n// over the page time.  \nawait page.clock.pauseAt(new Date('2024-02-02T10:00:00'));  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \n// Tick through time manually, firing all timers in the process.  \n// In this case, time will be updated in the screen 2 times.  \nawait page.clock.runFor(2000);  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:02 AM');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/clock", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: React locator allows finding elements by their component name and property values. The syntax is very similar to [CSS attribute selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors) and supports all CSS attribute selector operators. | In React locator, component names are transcribed with **CamelCase**.", "input": "", "output": "await page.locator('_react=BookItem').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test for the following scenario: First script\u200b | In our first script, we will navigate to `https://playwright.dev/` and take a screenshot in WebKit.", "input": "", "output": "const { webkit } = require('playwright');  \n  \n(async () => {  \n  const browser = await webkit.launch();  \n  const page = await browser.newPage();  \n  await page.goto('https://playwright.dev/');  \n  await page.screenshot({ path: `example.png` });  \n  await browser.close();  \n})();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/library"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const button = page.getByRole('button');  \n  \n// Make sure at least some part of element intersects viewport.  \nawait assert(button).toBeInViewport();  \n  \n// Make sure element is fully outside of viewport.  \nawait assert(button).not.toBeInViewport();  \n  \n// Make sure that at least half of the element intersects viewport.  \nawait assert(button).toBeInViewport({ ratio: 0.5 });", "output": "const button = page.getByRole('button');  \n  \n// Make sure at least some part of element intersects viewport.  \nawait expect(button).toBeInViewport();  \n  \n// Make sure element is fully outside of viewport.  \nawait expect(button).not.toBeInViewport();  \n  \n// Make sure that at least half of the element intersects viewport.  \nawait expect(button).toBeInViewport({ ratio: 0.5 });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n    },  \n  \n    {  \n      name: 'firefox',  \n      use: { ...devices['Desktop Firefox'] },  \n    },  \n  \n    {  \n      name: 'webkit',  \n      use: { ...devices['Desktop Safari'] },  \n    },  \n  \n    /* Test against mobile viewports. */  \n    {  \n      name: 'Mobile Chrome',  \n      use: { ...devices['Pixel 5'] },  \n    },  \n    {  \n      name: 'Mobile Safari',  \n      use: { ...devices['iPhone 12'] },  \n    },  \n  \n    /* Test against branded browsers. */  \n    {  \n      name: 'Microsoft Edge',  \n      use: {  \n        ...devices['Desktop Edge'],  \n        channel: 'msedge'  \n      },  \n    },  \n    {  \n      name: 'Google Chrome',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        channel: 'chrome'  \n      },  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-projects", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Advanced Configuration\u200b | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Folder for test artifacts such as screenshots, videos, traces, etc.  \n  outputDir: 'test-results',  \n  \n  // path to the global setup files.  \n  globalSetup: require.resolve('./global-setup'),  \n  \n  // path to the global teardown files.  \n  globalTeardown: require.resolve('./global-teardown'),  \n  \n  // Each test is given 30 seconds.  \n  timeout: 30000,  \n  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-configuration"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Playwright Test comes with the built-in `request` fixture that respects configuration options like `baseURL` or `extraHTTPHeaders` we specified and is ready to send some requests. | Now we can add a few tests that will create new issues in the repository.", "output": "const REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \ntest('should create a bug report', async ({ request }) => {  \n  const newIssue = await request.post(`/repos/${USER}/${REPO}/issues`, {  \n    data: {  \n      title: '[Bug] report 1',  \n      body: 'Bug description',  \n    }  \n  });  \n  expect(newIssue.ok()).toBeTruthy();  \n  \n  const issues = await request.get(`/repos/${USER}/${REPO}/issues`);  \n  expect(issues.ok()).toBeTruthy();  \n  expect(await issues.json()).toContainEqual(expect.objectContaining({  \n    title: '[Bug] report 1',  \n    body: 'Bug description'  \n  }));  \n});  \n  \ntest('should create a feature request', async ({ request }) => {  \n  const newIssue = await request.post(`/repos/${USER}/${REPO}/issues`, {  \n    data: {  \n      title: '[Feature] request 1',  \n      body: 'Feature description',  \n    }  \n  });  \n  expect(newIssue.ok()).toBeTruthy();  \n  \n  const issues = await request.get(`/repos/${USER}/${REPO}/issues`);  \n  expect(issues.ok()).toBeTruthy();  \n  expect(await issues.json()).toContainEqual(expect.objectContaining({  \n    title: '[Feature] request 1',  \n    body: 'Feature description'  \n  }));  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/api-testing"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Fill the input by targeting the label.  \nawait expect(page.locator('label')).toHaveText('Password');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "React locator allows finding elements by their component name and property values. The syntax is very similar to [CSS attribute selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors) and supports all CSS attribute selector operators. | In React locator, component names are transcribed with **CamelCase**.", "output": "await page.locator('_react=BookItem').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('props', async ({ mount }) => {  \n  const component = await mount(<Component msg=\"greetings\" />);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect(page.getByRole('listitem')).toHaveCount(3);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  testDir: './tests',  \n  // ...  \n  projects: [  \n    {  \n      name: 'setup db',  \n      testMatch: /global\\.setup\\.ts/,  \n      teardown: 'cleanup db',  \n    },  \n    {  \n      name: 'cleanup db',  \n      testMatch: /global\\.teardown\\.ts/,  \n    },  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n      dependencies: ['setup db'],  \n    },  \n  ]  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Playwright Library | Playwright module provides a method to launch a browser instance. The following is a typical example of using Playwright to drive automation:", "output": "const { chromium, firefox, webkit } = require('playwright');  \n  \n(async () => {  \n  const browser = await chromium.launch();  // Or 'firefox' or 'webkit'.  \n  const page = await browser.newPage();  \n  await page.goto('http://example.com');  \n  // other actions...  \n  await browser.close();  \n})();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/api/class-playwright"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(Component);  \n  await component.update({  \n    props: { msg: 'greetings' },  \n    on: { click() {} },  \n    slots: { default: 'Child' }  \n  });  \n});", "output": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(Component);  \n  await component.update({  \n    props: { msg: 'greetings' },  \n    on: { click() {} },  \n    slots: { default: 'Child' }  \n  });  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as baseTest, expect } from '@playwright/test';  \n// Import project utils for managing users in the test database.  \nimport { createUserInTestDatabase, deleteUserFromTestDatabase } from './my-db-utils';  \n  \nexport * from '@playwright/test';  \nexport const test = baseTest.extend<{}, { dbUserName: string }>({  \n  // Returns db user name unique for the worker.  \n  dbUserName: [async ({ }, use) => {  \n    // Use workerIndex as a unique identifier for each worker.  \n    const userName = `user-${test.info().workerIndex}`;  \n    // Initialize user in the database.  \n    await createUserInTestDatabase(userName);  \n    await use(userName);  \n    // Clean up after the tests are done.  \n    await deleteUserFromTestDatabase(userName);  \n  }, { scope: 'worker' }],  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parallel", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "When expect fails, the error would look like this:", "output": "Error: should be logged in  \n  \n    Call log:  \n      - expect.toBeVisible with timeout 5000ms  \n      - waiting for \"getByText('Name')\"  \n  \n  \n      2 |  \n      3 | test('example test', async({ page }) => {  \n    > 4 |   await expect(page.getByText('Name'), 'should be logged in').toBeVisible();  \n        |                                                                  ^  \n      5 | });  \n      6 |", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "component.spec.ts", "output": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('props', async ({ mount }) => {  \n  const component = await mount(Component, { props: { msg: 'greetings' } });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.navigate('https://playwright.dev');  \nawait assert(page.locator('body')).toMatchAriaSnapshot(`  \n  - banner:  \n    - heading /Playwright enables reliable/ [level=1]  \n    - link \"Get started\"  \n    - link \"Star microsoft/playwright on GitHub\"  \n  - main:  \n    - img \"Browsers (Chromium, Firefox, WebKit)\"  \n    - heading \"Any browser \u2022 Any platform \u2022 One API\"  \n`);", "output": "await page.goto('https://playwright.dev');  \nawait expect(page.locator('body')).toMatchAriaSnapshot(`  \n  - banner:  \n    - heading /Playwright enables reliable/ [level=1]  \n    - link \"Get started\"  \n    - link \"Star microsoft/playwright on GitHub\"  \n  - main:  \n    - img \"Browsers (Chromium, Firefox, WebKit)\"  \n    - heading \"Any browser \u2022 Any platform \u2022 One API\"  \n`);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "For example, `article:has-text(\"Playwright\")` matches `<article><div>Playwright</div></article>`. | Note that `:has-text()` should be used together with other CSS specifiers, otherwise it will match all the elements containing specified text, including the `<body>`.", "output": "// Wrong, will match many elements including <body>  \nawait page.locator(':has-text(\"Playwright\")').click();  \n// Correct, only matches the <article> element  \nawait page.locator('article:has-text(\"Playwright\")').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('props', async ({ mount }) => {  \n  const component = await mount(Component, { props: { msg: 'greetings' } });  \n});", "output": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('props', async ({ mount }) => {  \n  const component = await mount(Component, { props: { msg: 'greetings' } });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: src/pages/ProductsPage.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/experimental-ct-vue';  \nimport type { HooksConfig } from '../playwright';  \nimport ProductsPage from './pages/ProductsPage.vue';  \n  \ntest('configure routing through hooks config', async ({ page, mount }) => {  \n  const component = await mount<HooksConfig>(ProductsPage, {  \n    hooksConfig: { enableRouting: true },  \n  });  \n  await expect(component.getByRole('link')).toHaveAttribute('href', '/products/42');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.navigate('https://playwright.dev', {  \n  waitUntil: 'domcontentloaded',  \n});", "output": "await page.goto('https://playwright.dev', {  \n  waitUntil: 'domcontentloaded',  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const rows = page.getByRole('listitem');  \nconst count = await rows.count();  \nfor (let i = 0; i < count; ++i)  \n  console.log(await rows.nth(i).textContent());", "output": "const rows = page.getByRole('listitem');  \nconst count = await rows.count();  \nfor (let i = 0; i < count; ++i)  \n  console.log(await rows.nth(i).textContent());", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "By default, the report is written into the `blob-report` directory in the package.json directory or current working directory (if no package.json is found). The report file name looks like `report-<hash>.zip` or `report-<hash>-<shard_number>.zip` when [sharding](/docs/test-sharding) is used. The hash is an optional value computed from `--grep`, `--grepInverted`, `--project` and file filters passed as command line arguments. The hash guarantees that running Playwright with different command line options will produce different but stable between runs report names. The output file name can be overridden in the configuration file or pass as `'PLAYWRIGHT_BLOB_OUTPUT_FILE'` environment variable. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['blob', { outputFile: `./blob-report/report-${os.platform()}.zip` }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test('should not have any accessibility violations outside of rules with known issues', async ({  \n  page,  \n}) => {  \n  await page.navigate('https://your-site.com/page-with-known-issues');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .disableRules(['duplicate-id'])  \n      .analyze();  \n  \n  assert(accessibilityScanResults.violations).toEqual([]);  \n});", "output": "test('should not have any accessibility violations outside of rules with known issues', async ({  \n  page,  \n}) => {  \n  await page.goto('https://your-site.com/page-with-known-issues');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .disableRules(['duplicate-id'])  \n      .analyze();  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/experimental-ct-vue';  \nimport App from './App.vue';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(App);  \n  await assert(component).toContainText('Learn Vue');  \n});", "output": "import { test, expect } from '@playwright/experimental-ct-vue';  \nimport App from './App.vue';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(App);  \n  await expect(component).toContainText('Learn Vue');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest('context fetch', async ({ request }) => {  \n  // Do a GET request on behalf of page  \n  const response = await request.get('http://example.com/foo.json');  \n  // ...  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('context fetch', async ({ request }) => {  \n  // Do a GET request on behalf of page  \n  const response = await request.get('http://example.com/foo.json');  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: tests/example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('specific viewport block', () => {  \n  test.use({ viewport: { width: 1600, height: 1200 } });  \n  \n  test('my test', async ({ page }) => {  \n    // ...  \n  });  \n});  \n\n\n\n// Create context with given viewport  \nconst context = await browser.newContext({  \n  viewport: { width: 1600, height: 1200 }  \n});  \nconst page = await context.newPage();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.route('**/api/settings', async route => {  \n  // Fetch original settings.  \n  const response = await route.fetch();  \n  \n  // Force settings theme to a predefined value.  \n  const json = await response.json();  \n  json.theme = 'Solorized';  \n  \n  // Fulfill with modified data.  \n  await route.fulfill({ json });  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const rows = page.getByRole('listitem');  \nconst texts = await rows.evaluateAll(  \n    list => list.map(element => element.textContent));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(<Component/>);  \n  await component.update(  \n      <Component msg=\"greetings\" v-on:click={() => {}}>Child</Component>  \n  );  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Variations\u200b | Wait for [Response](/docs/api/class-response \"Response\")s with [page.waitForResponse()](/docs/api/class-page#page-wait-for-response)", "input": "", "output": "// Use a RegExp. Note no await.  \nconst responsePromise = page.waitForResponse(/\\.jpeg$/);  \nawait page.getByText('Update').click();  \nconst response = await responsePromise;  \n  \n// Use a predicate taking a Response object. Note no await.  \nconst responsePromise = page.waitForResponse(response => response.url().includes(token));  \nawait page.getByText('Update').click();  \nconst response = await responsePromise;", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \nimport jimp from 'jimp'; // image processing library  \n  \ntest('response interception', async ({ page }) => {  \n  await page.route('**/*.jpeg', async route => {  \n    const response = await page._request.fetch(route.request());  \n    const image = await jimp.read(await response.body());  \n    await image.blur(5);  \n    await route.fulfill({  \n      response,  \n      body: await image.getBufferAsync('image/jpeg'),  \n    });  \n  });  \n  const response = await page.goto('https://playwright.dev');  \n  expect(response.status()).toBe(200);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "We recommend prioritizing [user-visible locators](/docs/locators#quick-guide) like text or accessible role instead of using XPath that is tied to the implementation and easily break when the page changes. | XPath locators are equivalent to calling [`Document.evaluate`](https://developer.mozilla.org/en/docs/Web/API/Document/evaluate).", "output": "await page.locator('xpath=//button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test for the following scenario: component.spec.ts", "input": "", "output": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('slot', async ({ mount }) => {  \n  const component = await mount(Component, { slots: { default: 'Slot' } });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test for the following scenario: You can specify plugins via Vite config for testing settings. Note that once you start specifying plugins, you are responsible for specifying the framework plugin as well, `vue()` in this case:", "input": "", "output": "import { defineConfig, devices } from '@playwright/experimental-ct-vue';  \n  \nimport { resolve } from 'path';  \nimport vue from '@vitejs/plugin-vue';  \nimport AutoImport from 'unplugin-auto-import/vite';  \nimport Components from 'unplugin-vue-components/vite';  \n  \nexport default defineConfig({  \n  testDir: './tests/component',  \n  use: {  \n    trace: 'on-first-retry',  \n    ctViteConfig: {  \n      plugins: [  \n        vue(),  \n        AutoImport({  \n          imports: [  \n            'vue',  \n            'vue-router',  \n            '@vueuse/head',  \n            'pinia',  \n            {  \n              '@/store': ['useStore'],  \n            },  \n          ],  \n          dts: 'src/auto-imports.d.ts',  \n          eslintrc: {  \n            enabled: true,  \n          },  \n        }),  \n        Components({  \n          dirs: ['src/components'],  \n          extensions: ['vue'],  \n        }),  \n      ],  \n      resolve: {  \n        alias: {  \n          '@': resolve(__dirname, './src'),  \n        },  \n      },  \n    },  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test('query params', async ({ request }) => {  \n  const searchParams = new URLSearchParams();  \n  searchParams.set('userId', 1);  \n  const response = await request.get(  \n      'https://jsonplaceholder.typicode.com/posts',  \n      {  \n        params: searchParams // or as a string: 'userId=1'  \n      }  \n  );  \n  // ...  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: A common pattern would be a `setup` dependency with a corresponding `teardown`: | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'setup',  \n      testMatch: /global.setup\\.ts/,  \n      teardown: 'teardown',  \n    },  \n    {  \n      name: 'teardown',  \n      testMatch: /global.teardown\\.ts/,  \n    },  \n    {  \n      name: 'chromium',  \n      use: devices['Desktop Chrome'],  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'firefox',  \n      use: devices['Desktop Firefox'],  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'webkit',  \n      use: devices['Desktop Safari'],  \n      dependencies: ['setup'],  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  globalSetup: require.resolve('./global-setup'),  \n  globalTeardown: require.resolve('./global-teardown'),  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test as base } from '@playwright/test';  \nimport fs from 'fs';  \nimport os from 'os';  \nimport path from 'path';  \nimport childProcess from 'child_process';  \n  \nconst EXECUTABLE_PATH = path.join(  \n    __dirname,  \n    '../../webview2-app/bin/Debug/net8.0-windows/webview2.exe',  \n);  \n  \nexport const test = base.extend({  \n  browser: async ({ playwright }, use, testInfo) => {  \n    const cdpPort = 10000 + testInfo.workerIndex;  \n    // Make sure that the executable exists and is executable  \n    fs.accessSync(EXECUTABLE_PATH, fs.constants.X_OK);  \n    const userDataDir = path.join(  \n        fs.realpathSync.native(os.tmpdir()),  \n        `playwright-webview2-tests/user-data-dir-${testInfo.workerIndex}`,  \n    );  \n    const webView2Process = childProcess.spawn(EXECUTABLE_PATH, [], {  \n      shell: true,  \n      env: {  \n        ...process.env,  \n        WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS: `--remote-debugging-port=${cdpPort}`,  \n        WEBVIEW2_USER_DATA_FOLDER: userDataDir,  \n      }  \n    });  \n    await new Promise<void>(resolve => webView2Process.stdout.on('data', data => {  \n      if (data.toString().includes('WebView2 initialized'))  \n        resolve();  \n    }));  \n    const browser = await playwright.chromium.connectOverCDP(`http://127.0.0.1:${cdpPort}`);  \n    await use(browser);  \n    await browser.close();  \n    childProcess.execSync(`taskkill /pid ${webView2Process.pid} /T /F`);  \n    fs.rmdirSync(userDataDir, { recursive: true });  \n  },  \n  context: async ({ browser }, use) => {  \n    const context = browser.contexts()[0];  \n    await use(context);  \n  },  \n  page: async ({ context }, use) => {  \n    const page = context.pages()[0];  \n    await use(page);  \n  },  \n});  \n  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/webview2", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    actionTimeout: 10 * 1000,  \n    navigationTimeout: 30 * 1000,  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    actionTimeout: 10 * 1000,  \n    navigationTimeout: 30 * 1000,  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-timeouts", "type": "modification"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "An example test illustrating the initial context options are set:", "output": "test('should inherit use options on context when using built-in browser fixture', async ({  \n  browser,  \n}) => {  \n  const context = await browser.newContext();  \n  const page = await context.newPage();  \n  expect(await page.evaluate(() => navigator.userAgent)).toBe('some custom ua');  \n  expect(await page.evaluate(() => window.innerWidth)).toBe(100);  \n  await context.close();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-use-options", "type": "fixture"}}
{"instruction": "Generate a Playwright test for the following scenario: Filter by not having text\u200b | Alternatively, filter by **not having** text:", "input": "", "output": "// 5 in-stock items  \nawait expect(page.getByRole('listitem').filter({ hasNotText: 'Out of stock' })).toHaveCount(5);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const button = page.getByRole('button').and(page.getByTitle('Subscribe'));", "output": "const button = page.getByRole('button').and(page.getByTitle('Subscribe'));", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "This will find both buttons and throw a [strictness](/docs/locators#strictness) violation error:", "output": "await page.locator('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "navigation"}}
{"instruction": "Generate a Playwright test for the following scenario: Just mention fixture in your test function argument, and test runner will take care of it. Fixtures are also available in hooks and other fixtures. If you use TypeScript, fixtures will have the right type. | Below we use the `todoPage` and `settingsPage` fixtures defined above.", "input": "", "output": "import { test, expect } from './my-test';  \n  \ntest.beforeEach(async ({ settingsPage }) => {  \n  await settingsPage.switchToDarkMode();  \n});  \n  \ntest('basic test', async ({ todoPage, page }) => {  \n  await todoPage.addToDo('something nice');  \n  await expect(page.getByTestId('todo-title')).toContainText(['something nice']);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test for the following scenario: We will authenticate multiple times in the setup project. | tests/auth.setup.ts", "input": "", "output": "import { test as setup, expect } from '@playwright/test';  \n  \nconst adminFile = 'playwright/.auth/admin.json';  \n  \nsetup('authenticate as admin', async ({ page }) => {  \n  // Perform authentication steps. Replace these actions with your own.  \n  await page.goto('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('admin');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n  // Wait until the page receives the cookies.  \n  //  \n  // Sometimes login flow sets cookies in the process of several redirects.  \n  // Wait for the final URL to ensure that the cookies are actually set.  \n  await page.waitForURL('https://github.com/');  \n  // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n  await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n  // End of authentication steps.  \n  \n  await page.context().storageState({ path: adminFile });  \n});  \n  \nconst userFile = 'playwright/.auth/user.json';  \n  \nsetup('authenticate as user', async ({ page }) => {  \n  // Perform authentication steps. Replace these actions with your own.  \n  await page.goto('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('user');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n  // Wait until the page receives the cookies.  \n  //  \n  // Sometimes login flow sets cookies in the process of several redirects.  \n  // Wait for the final URL to ensure that the cookies are actually set.  \n  await page.waitForURL('https://github.com/');  \n  // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n  await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n  // End of authentication steps.  \n  \n  await page.context().storageState({ path: userFile });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "First script\u200b | In our first script, we will navigate to `https://playwright.dev/` and take a screenshot in WebKit.", "output": "const { webkit } = require('playwright');  \n  \n(async () => {  \n  const browser = await webkit.launch();  \n  const page = await browser.newPage();  \n  await page.goto('https://playwright.dev/');  \n  await page.screenshot({ path: `example.png` });  \n  await browser.close();  \n})();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/library", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from './fixtures';  \n  \ntest('example test', async ({ page }) => {  \n  await page.navigate('https://example.com');  \n  await assert(page.locator('body')).toHaveText('Changed by my-extension');  \n});  \n  \ntest('popup page', async ({ page, extensionId }) => {  \n  await page.navigate(`chrome-extension://${extensionId}/popup.html`);  \n  await assert(page.locator('body')).toHaveText('my-extension popup');  \n});", "output": "import { test, expect } from './fixtures';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://example.com');  \n  await expect(page.locator('body')).toHaveText('Changed by my-extension');  \n});  \n  \ntest('popup page', async ({ page, extensionId }) => {  \n  await page.goto(`chrome-extension://${extensionId}/popup.html`);  \n  await expect(page.locator('body')).toHaveText('my-extension popup');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/chrome-extensions", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest.use({  \n  locale: 'de-DE',  \n  timezoneId: 'Europe/Berlin',  \n});  \n  \ntest('my test for de lang in Berlin timezone', async ({ page }) => {  \n  await page.navigate('https://www.bing.com');  \n  // ...  \n});  \n\n\n\nconst context = await browser.newContext({  \n  locale: 'de-DE',  \n  timezoneId: 'Europe/Berlin',  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  locale: 'de-DE',  \n  timezoneId: 'Europe/Berlin',  \n});  \n  \ntest('my test for de lang in Berlin timezone', async ({ page }) => {  \n  await page.goto('https://www.bing.com');  \n  // ...  \n});  \n\n\n\nconst context = await browser.newContext({  \n  locale: 'de-DE',  \n  timezoneId: 'Europe/Berlin',  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "page.getByTestId() to locate an element based on its `data-testid` attribute (other attributes can be configured).", "output": "await page.getByLabel('User Name').fill('John');  \n  \nawait page.getByLabel('Password').fill('secret-password');  \n  \nawait page.getByRole('button', { name: 'Sign in' }).click();  \n  \nawait expect(page.getByText('Welcome, John!')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Important: import our fixtures.  \nimport { test, expect } from '../playwright/fixtures';  \n  \ntest('test', async ({ dbUserName }) => {  \n  // Use the user name in the test.  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-parallel", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  await expect(response).toBeOK();  \n}).toPass();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig, devices } from '@playwright/experimental-ct-vue';  \n  \nimport { resolve } from 'path';  \nimport vue from '@vitejs/plugin-vue';  \nimport AutoImport from 'unplugin-auto-import/vite';  \nimport Components from 'unplugin-vue-components/vite';  \n  \nexport default defineConfig({  \n  testDir: './tests/component',  \n  use: {  \n    trace: 'on-first-retry',  \n    ctViteConfig: {  \n      plugins: [  \n        vue(),  \n        AutoImport({  \n          imports: [  \n            'vue',  \n            'vue-router',  \n            '@vueuse/head',  \n            'pinia',  \n            {  \n              '@/store': ['useStore'],  \n            },  \n          ],  \n          dts: 'src/auto-imports.d.ts',  \n          eslintrc: {  \n            enabled: true,  \n          },  \n        }),  \n        Components({  \n          dirs: ['src/components'],  \n          extensions: ['vue'],  \n        }),  \n      ],  \n      resolve: {  \n        alias: {  \n          '@': resolve(__dirname, './src'),  \n        },  \n      },  \n    },  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "Custom fixture title\u200b | Instead of the usual fixture name, you can give fixtures a custom title that will be shown in test reports and error messages.", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  innerFixture: [async ({}, use, testInfo) => {  \n    // ...  \n  }, { title: 'my fixture' }],  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test for the following scenario: If using the built-in `browser` fixture, calling [browser.newContext()](/docs/api/class-browser#browser-new-context) will create a context with options inherited from the config: | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    userAgent: 'some custom ua',  \n    viewport: { width: 100, height: 100 },  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "component.spec.tsx", "output": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('props', async ({ mount }) => {  \n  const component = await mount(<Component msg=\"greetings\" />);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { request } from '@playwright/test';  \nconst REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \n(async () => {  \n  // Create a context that will issue http requests.  \n  const context = await request.newContext({  \n    baseURL: 'https://api.github.com',  \n  });  \n  \n  // Create a repository.  \n  await context.post('/user/repos', {  \n    headers: {  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add GitHub personal access token.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    },  \n    data: {  \n      name: REPO  \n    }  \n  });  \n  \n  // Delete a repository.  \n  await context.delete(`/repos/${USER}/${REPO}`, {  \n    headers: {  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add GitHub personal access token.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    }  \n  });  \n})();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/api-testing", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: `data-test`", "input": "", "output": "// Fill an input with the id \"username\"  \nawait page.locator('id=username').fill('value');  \n  \n// Click an element with data-test-id \"submit\"  \nawait page.locator('data-test-id=submit').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    video: 'on-first-retry',  \n  },  \n});  \n\n\n\nconst context = await browser.newContext({ recordVideo: { dir: 'videos/' } });  \n// Make sure to await close, so that videos are saved.  \nawait context.close();", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    video: 'on-first-retry',  \n  },  \n});  \n\n\n\nconst context = await browser.newContext({ recordVideo: { dir: 'videos/' } });  \n// Make sure to await close, so that videos are saved.  \nawait context.close();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/videos", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Each test in the file will be retried twice and have a timeout of 20 seconds.  \ntest.describe.configure({ retries: 2, timeout: 20_000 });  \ntest('runs first', async ({ page }) => {});  \ntest('runs second', async ({ page }) => {});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Use a glob URL pattern. Note no await.  \nconst responsePromise = page.waitForResponse('**/api/fetch_data');  \nawait page.getByText('Update').click();  \nconst response = await responsePromise;", "output": "// Use a glob URL pattern. Note no await.  \nconst responsePromise = page.waitForResponse('**/api/fetch_data');  \nawait page.getByText('Update').click();  \nconst response = await responsePromise;", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Adding/removing event listener\u200b | Sometimes, events happen in random time and instead of waiting for them, they need to be handled. Playwright supports traditional language mechanisms for subscribing and unsubscribing from the events:", "output": "page.on('request', request => console.log(`Request sent: ${request.url()}`));  \nconst listener = request => console.log(`Request finished: ${request.url()}`);  \npage.on('requestfinished', listener);  \nawait page.goto('https://wikipedia.org');  \n  \npage.off('requestfinished', listener);  \nawait page.goto('https://www.openstreetmap.org/');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/events", "type": "navigation"}}
{"instruction": "Generate a Playwright test for the following scenario: tests/example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  colorScheme: 'dark' // or 'light'  \n});  \n  \ntest('my test with dark mode', async ({ page }) => {  \n  // ...  \n});  \n\n\n\n// Create context with dark mode  \nconst context = await browser.newContext({  \n  colorScheme: 'dark' // or 'light'  \n});  \n  \n// Create page with dark mode  \nconst page = await browser.newPage({  \n  colorScheme: 'dark' // or 'light'  \n});  \n  \n// Change color scheme for the page  \nawait page.emulateMedia({ colorScheme: 'dark' });  \n  \n// Change media for page  \nawait page.emulateMedia({ media: 'print' });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Generate a Playwright test for the following scenario: The new assertions has screenshot-specific defaults, such as:", "input": "", "output": "* disables animations\n* uses CSS scale option\n\n    await page.goto('https://playwright.dev');  \nawait expect(page).toHaveScreenshot();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \ntest('should create a bug report', async ({ request }) => {  \n  const newIssue = await request.post(`/repos/${USER}/${REPO}/issues`, {  \n    data: {  \n      title: '[Bug] report 1',  \n      body: 'Bug description',  \n    }  \n  });  \n  expect(newIssue.ok()).toBeTruthy();  \n  \n  const issues = await request.get(`/repos/${USER}/${REPO}/issues`);  \n  expect(issues.ok()).toBeTruthy();  \n  expect(await issues.json()).toContainEqual(expect.objectContaining({  \n    title: '[Bug] report 1',  \n    body: 'Bug description'  \n  }));  \n});  \n  \ntest('should create a feature request', async ({ request }) => {  \n  const newIssue = await request.post(`/repos/${USER}/${REPO}/issues`, {  \n    data: {  \n      title: '[Feature] request 1',  \n      body: 'Feature description',  \n    }  \n  });  \n  expect(newIssue.ok()).toBeTruthy();  \n  \n  const issues = await request.get(`/repos/${USER}/${REPO}/issues`);  \n  expect(issues.ok()).toBeTruthy();  \n  expect(await issues.json()).toContainEqual(expect.objectContaining({  \n    title: '[Feature] request 1',  \n    body: 'Feature description'  \n  }));  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/api-testing", "type": "website_test"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "`beforeAll` and `afterAll` hooks have a separate timeout, by default equal to test timeout. You can change it separately for each hook by calling [testInfo.setTimeout()](/docs/api/class-testinfo#test-info-set-timeout) inside the hook. | example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.beforeAll(async () => {  \n  // Set timeout for this hook.  \n  test.setTimeout(60000);  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-timeouts", "type": "fixture"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Read more in [our documentation](/docs/test-components). | Role selectors that allow selecting elements by their [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) and [accessible name](https://w3c.github.io/accname/#dfn-accessible-name).", "output": "// Click a button with accessible name \"log in\"  \nawait page.locator('role=button[name=\"log in\"]').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "navigation"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "app.spec.ts", "output": "import { test, expect } from '@playwright/experimental-ct-vue';  \nimport App from './App.vue';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(App);  \n  await expect(component).toContainText('Learn Vue');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({ locale: 'fr-FR' });  \n  \ntest('example', async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-use-options", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    actionTimeout: 10 * 1000,  \n    navigationTimeout: 30 * 1000,  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-timeouts", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: You can make arbitrary data available in your tests from your global setup file by setting them as environment variables via `process.env`. | global-setup.ts", "input": "", "output": "import type { FullConfig } from '@playwright/test';  \n  \nasync function globalSetup(config: FullConfig) {  \n  process.env.FOO = 'some data';  \n  // Or a more complicated data structure as JSON:  \n  process.env.BAR = JSON.stringify({ some: 'data' });  \n}  \n  \nexport default globalSetup;", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Simple test `tests/foo.spec.ts`:", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('basic test', async ({ page }) => {  \n  await page.goto('https://playwright.dev/');  \n  const name = await page.innerText('.navbar__title');  \n  expect(name).toBe('Playwright');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('props', async ({ mount }) => {  \n  const component = await mount(Component, { props: { msg: 'greetings' } });  \n});", "output": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('props', async ({ mount }) => {  \n  const component = await mount(Component, { props: { msg: 'greetings' } });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "You can merge test fixtures from multiple files or modules: | fixtures.ts", "output": "import { mergeTests } from '@playwright/test';  \nimport { test as dbTest } from 'database-test-utils';  \nimport { test as a11yTest } from 'a11y-test-utils';  \n  \nexport const test = mergeTests(dbTest, a11yTest);", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test for the following scenario: WebSocket routing\u200b | New methods [page.routeWebSocket()](/docs/api/class-page#page-route-web-socket) and [browserContext.routeWebSocket()](/docs/api/class-browsercontext#browser-context-route-web-socket) allow to intercept, modify and mock WebSocket connections initiated in the page. Below is a simple example that mocks WebSocket communication by responding to a `\"request\"` with a `\"response\"`.", "input": "", "output": "await page.routeWebSocket('/ws', ws => {  \n  ws.onMessage(message => {  \n    if (message === 'request')  \n      ws.send('response');  \n  });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "In this example the chromium, firefox and webkit projects depend on the setup project. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'setup',  \n      testMatch: '**/*.setup.ts',  \n    },  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'firefox',  \n      use: { ...devices['Desktop Firefox'] },  \n      dependencies: ['setup'],  \n    },  \n    {  \n      name: 'webkit',  \n      use: { ...devices['Desktop Safari'] },  \n      dependencies: ['setup'],  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-projects"}}
{"instruction": "Generate a Playwright test for the following scenario: Automatically capture **full page screenshot** on test failure: | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    screenshot: {  \n      mode: 'only-on-failure',  \n      fullPage: true,  \n    }  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Tests start already authenticated because we specify `storageState` that was populated by global setup.", "output": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  await page.goto('/');  \n  // You are signed in!  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \nimport { PlaywrightDevPage } from './playwright-dev-page';  \n  \ntest('getting started should contain table of contents', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.getStarted();  \n  await expect(playwrightDev.tocList).toHaveText([  \n    `How to install Playwright`,  \n    `What's Installed`,  \n    `How to run the example test`,  \n    `How to open the HTML test report`,  \n    `Write tests using web first assertions, page fixtures and locators`,  \n    `Run single test, multiple tests, headed mode`,  \n    `Generate tests with Codegen`,  \n    `See a trace of your tests`  \n  ]);  \n});  \n  \ntest('should show Page Object Model article', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.pageObjectModel();  \n  await expect(page.locator('article')).toContainText('Page Object Model is a common pattern');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/pom", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "example.spec.ts", "output": "import { test, type Page } from '@playwright/test';  \n  \ntest.describe.configure({ mode: 'serial' });  \n  \nlet page: Page;  \n  \ntest.beforeAll(async ({ browser }) => {  \n  page = await browser.newPage();  \n});  \n  \ntest.afterAll(async () => {  \n  await page.close();  \n});  \n  \ntest('runs first', async () => {  \n  await page.goto('https://playwright.dev/');  \n});  \n  \ntest('runs second', async () => {  \n  await page.getByText('Get Started').click();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-retries"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const product = page.getByRole('listitem').filter({ hasText: 'Product 2' });  \n  \nawait product.getByRole('button', { name: 'Add to cart' }).click();  \n  \nawait assert(product).toHaveCount(1);", "output": "const product = page.getByRole('listitem').filter({ hasText: 'Product 2' });  \n  \nawait product.getByRole('button', { name: 'Add to cart' }).click();  \n  \nawait expect(product).toHaveCount(1);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Make a few checks that will not stop the test when failed...  \nawait expect.soft(page.getByTestId('status')).toHaveText('Success');  \nawait expect.soft(page.getByTestId('eta')).toHaveText('1 day');  \n  \n// ... and continue the test to check more things.  \nawait page.getByRole('link', { name: 'next page' }).click();  \nawait expect.soft(page.getByRole('heading', { name: 'Make another order' })).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest.use({ locale: 'fr-FR' });  \n  \ntest('example', async ({ page }) => {  \n  // ...  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({ locale: 'fr-FR' });  \n  \ntest('example', async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-use-options", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const locator = page.getByRole('button', { name: 'Sign in' });  \n  \nawait locator.hover();  \nawait locator.click();", "output": "const locator = page.getByRole('button', { name: 'Sign in' });  \n  \nawait locator.hover();  \nawait locator.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Overriding fixtures\u200b | In addition to creating your own fixtures, you can also override existing fixtures to fit your needs. Consider the following example which overrides the `page` fixture by automatically navigating to some `baseURL`:", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  page: async ({ baseURL, page }, use) => {  \n    await page.goto(baseURL);  \n    await use(page);  \n  },  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-fixtures", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import type {  \n  FullConfig, FullResult, Reporter, Suite, TestCase, TestResult  \n} from '@playwright/test/reporter';  \n  \nclass MyReporter implements Reporter {  \n  onBegin(config: FullConfig, suite: Suite) {  \n    console.log(`Starting the run with ${suite.allTests().length} tests`);  \n  }  \n  \n  onTestBegin(test: TestCase, result: TestResult) {  \n    console.log(`Starting test ${test.title}`);  \n  }  \n  \n  onTestEnd(test: TestCase, result: TestResult) {  \n    console.log(`Finished test ${test.title}: ${result.status}`);  \n  }  \n  \n  onEnd(result: FullResult) {  \n    console.log(`Finished the run: ${result.status}`);  \n  }  \n}  \n  \nexport default MyReporter;", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-reporters", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page  \n    .getByPlaceholder('name@example.com')  \n    .fill('playwright@microsoft.com');", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Generic click  \nawait page.getByRole('button').click();  \n  \n// Double click  \nawait page.getByText('Item').dblclick();  \n  \n// Right click  \nawait page.getByText('Item').click({ button: 'right' });  \n  \n// Shift + click  \nawait page.getByText('Item').click({ modifiers: ['Shift'] });  \n  \n// Ctrl + click or Windows and Linux  \n// Meta + click on macOS  \nawait page.getByText('Item').click({ modifiers: ['ControlOrMeta'] });  \n  \n// Hover over element  \nawait page.getByText('Item').hover();  \n  \n// Click the top left corner  \nawait page.getByText('Item').click({ position: { x: 0, y: 0 } });", "output": "// Generic click  \nawait page.getByRole('button').click();  \n  \n// Double click  \nawait page.getByText('Item').dblclick();  \n  \n// Right click  \nawait page.getByText('Item').click({ button: 'right' });  \n  \n// Shift + click  \nawait page.getByText('Item').click({ modifiers: ['Shift'] });  \n  \n// Ctrl + click or Windows and Linux  \n// Meta + click on macOS  \nawait page.getByText('Item').click({ modifiers: ['ControlOrMeta'] });  \n  \n// Hover over element  \nawait page.getByText('Item').hover();  \n  \n// Click the top left corner  \nawait page.getByText('Item').click({ position: { x: 0, y: 0 } });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Handle requests\u200b", "input": "", "output": "await page.route('**/api/fetch_data', route => route.fulfill({  \n  status: 200,  \n  body: testData,  \n}));  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Iterate using regular for loop:", "output": "const rows = page.getByRole('listitem');  \nconst count = await rows.count();  \nfor (let i = 0; i < count; ++i)  \n  console.log(await rows.nth(i).textContent());", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test('example', async ({ page }) => {  \n  console.log(test.info().tags);  \n});", "output": "test('example', async ({ page }) => {  \n  console.log(test.info().tags);  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.goto('https://playwright.dev', {  \n  waitUntil: 'domcontentloaded',  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Launch multiple web servers, databases, or other processes by passing an array of configurations: | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  webServer: [  \n    {  \n      command: 'npm run start',  \n      url: 'http://127.0.0.1:3000',  \n      timeout: 120 * 1000,  \n      reuseExistingServer: !process.env.CI,  \n    },  \n    {  \n      command: 'npm run backend',  \n      url: 'http://127.0.0.1:3333',  \n      timeout: 120 * 1000,  \n      reuseExistingServer: !process.env.CI,  \n    }  \n  ],  \n  use: {  \n    baseURL: 'http://localhost:3000/',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Aria snapshots\u200b | New assertion [expect(locator).toMatchAriaSnapshot()](/docs/api/class-locatorassertions#locator-assertions-to-match-aria-snapshot) verifies page structure by comparing to an expected accessibility tree, represented as YAML.", "output": "await page.goto('https://playwright.dev');  \nawait expect(page.locator('body')).toMatchAriaSnapshot(`  \n  - banner:  \n    - heading /Playwright enables reliable/ [level=1]  \n    - link \"Get started\"  \n    - link \"Star microsoft/playwright on GitHub\"  \n  - main:  \n    - img \"Browsers (Chromium, Firefox, WebKit)\"  \n    - heading \"Any browser \u2022 Any platform \u2022 One API\"  \n`);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest.describe('two tests', () => {  \n  test('one', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('two', async ({ page }) => {  \n    // ...  \n  });  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('two tests', () => {  \n  test('one', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('two', async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Most of the time, scripts will need to wait for a particular event to happen. Below are some of the typical event awaiting patterns. | Wait for a request with the specified url using [page.waitForRequest()](/docs/api/class-page#page-wait-for-request):", "output": "// Start waiting for request before goto. Note no await.  \nconst requestPromise = page.waitForRequest('**/*logo*.png');  \nawait page.goto('https://wikipedia.org');  \nconst request = await requestPromise;  \nconsole.log(request.url());", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/events", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Start waiting for request before goto. Note no await.  \nconst requestPromise = page.waitForRequest('**/*logo*.png');  \nawait page.goto('https://wikipedia.org');  \nconst request = await requestPromise;  \nconsole.log(request.url());", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/events", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \nconst REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \n// Request context is reused by all tests in the file.  \nlet apiContext;  \n  \ntest.beforeAll(async ({ playwright }) => {  \n  apiContext = await playwright.request.newContext({  \n    // All requests we send go to this API endpoint.  \n    baseURL: 'https://api.github.com',  \n    extraHTTPHeaders: {  \n      // We set this header per GitHub guidelines.  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add authorization token to all requests.  \n      // Assuming personal access token available in the environment.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    },  \n  });  \n});  \n  \ntest.afterAll(async ({ }) => {  \n  // Dispose all responses.  \n  await apiContext.dispose();  \n});  \n  \ntest('last created issue should be first in the list', async ({ page }) => {  \n  const newIssue = await apiContext.post(`/repos/${USER}/${REPO}/issues`, {  \n    data: {  \n      title: '[Feature] request 1',  \n    }  \n  });  \n  expect(newIssue.ok()).toBeTruthy();  \n  \n  await page.goto(`https://github.com/${USER}/${REPO}/issues`);  \n  const firstIssue = page.locator(`a[data-hovercard-type='issue']`).first();  \n  await expect(firstIssue).toHaveText('[Feature] request 1');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/api-testing", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: 'line',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Any options accepted by [browserType.launch()](/docs/api/class-browsertype#browser-type-launch) or [browser.newContext()](/docs/api/class-browser#browser-new-context) can be put into `launchOptions` or `contextOptions` respectively in the `use` section. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    launchOptions: {  \n      slowMo: 50,  \n    },  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options"}}
{"instruction": "Generate a Playwright test for the following scenario: Library", "input": "", "output": "import { test } from '@playwright/test';  \n  \ntest('example test', async ({ page, context }) => {  \n  // \"context\" is an isolated BrowserContext, created for this specific test.  \n  // \"page\" belongs to this context.  \n});  \n  \ntest('another test', async ({ page, context }) => {  \n  // \"context\" and \"page\" in this second test are completely  \n  // isolated from the first test.  \n});  \n\n\n\nconst browser = await chromium.launch();  \nconst context = await browser.newContext();  \nconst page = await context.newPage();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/browser-contexts"}}
{"instruction": "Generate a Playwright test for the following scenario: [New syntax](/docs/test-annotations#annotate-tests) for test annotations:", "input": "", "output": "test('test full report', {  \n  annotation: [  \n    { type: 'issue', description: 'https://github.com/microsoft/playwright/issues/23180' },  \n    { type: 'docs', description: 'https://playwright.dev/docs/test-annotations#tag-tests' },  \n  ],  \n}, async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the form_interaction pattern.", "input": "Upload files\u200b | You can select input files for upload using the [locator.setInputFiles()](/docs/api/class-locator#locator-set-input-files) method. It expects first argument to point to an [input element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input) with the type `\"file\"`. Multiple files can be passed in the array. If some of the file paths are relative, they are resolved relative to the current working directory. Empty array clears the selected files.", "output": "// Select one file  \nawait page.getByLabel('Upload file').setInputFiles(path.join(__dirname, 'myfile.pdf'));  \n  \n// Select multiple files  \nawait page.getByLabel('Upload files').setInputFiles([  \n  path.join(__dirname, 'file1.txt'),  \n  path.join(__dirname, 'file2.txt'),  \n]);  \n  \n// Select a directory  \nawait page.getByLabel('Upload directory').setInputFiles(path.join(__dirname, 'mydir'));  \n  \n// Remove all the selected files  \nawait page.getByLabel('Upload file').setInputFiles([]);  \n  \n// Upload buffer from memory  \nawait page.getByLabel('Upload file').setInputFiles({  \n  name: 'file.txt',  \n  mimeType: 'text/plain',  \n  buffer: Buffer.from('this is test')  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  geolocation: { longitude: 41.890221, latitude: 12.492348 },  \n  permissions: ['geolocation'],  \n});  \n  \ntest('my test with geolocation', async ({ page }) => {  \n  // ...  \n});  \n\n\n\nconst context = await browser.newContext({  \n  geolocation: { longitude: 41.890221, latitude: 12.492348 },  \n  permissions: ['geolocation']  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Look for test files in the \"tests\" directory, relative to this configuration file.  \n  testDir: 'tests',  \n  \n  // Run all tests in parallel.  \n  fullyParallel: true,  \n  \n  // Fail the build on CI if you accidentally left test.only in the source code.  \n  forbidOnly: !!process.env.CI,  \n  \n  // Retry on CI only.  \n  retries: process.env.CI ? 2 : 0,  \n  \n  // Opt out of parallel tests on CI.  \n  workers: process.env.CI ? 1 : undefined,  \n  \n  // Reporter to use  \n  reporter: 'html',  \n  \n  use: {  \n    // Base URL to use in actions like `await page.navigate('/')`.  \n    baseURL: 'http://127.0.0.1:3000',  \n  \n    // Collect trace when retrying the failed test.  \n    trace: 'on-first-retry',  \n  },  \n  // Configure projects for major browsers.  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n    },  \n  ],  \n  // Run your local dev server before starting the tests.  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n  },  \n});", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Look for test files in the \"tests\" directory, relative to this configuration file.  \n  testDir: 'tests',  \n  \n  // Run all tests in parallel.  \n  fullyParallel: true,  \n  \n  // Fail the build on CI if you accidentally left test.only in the source code.  \n  forbidOnly: !!process.env.CI,  \n  \n  // Retry on CI only.  \n  retries: process.env.CI ? 2 : 0,  \n  \n  // Opt out of parallel tests on CI.  \n  workers: process.env.CI ? 1 : undefined,  \n  \n  // Reporter to use  \n  reporter: 'html',  \n  \n  use: {  \n    // Base URL to use in actions like `await page.goto('/')`.  \n    baseURL: 'http://127.0.0.1:3000',  \n  \n    // Collect trace when retrying the failed test.  \n    trace: 'on-first-retry',  \n  },  \n  // Configure projects for major browsers.  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n    },  \n  ],  \n  // Run your local dev server before starting the tests.  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n  },  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-configuration", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/test';  \n  \ntest('example test', async ({ page, context }) => {  \n  // \"context\" is an isolated BrowserContext, created for this specific test.  \n  // \"page\" belongs to this context.  \n});  \n  \ntest('another test', async ({ page, context }) => {  \n  // \"context\" and \"page\" in this second test are completely  \n  // isolated from the first test.  \n});  \n\n\n\nconst browser = await chromium.launch();  \nconst context = await browser.newContext();  \nconst page = await context.newPage();", "output": "import { test } from '@playwright/test';  \n  \ntest('example test', async ({ page, context }) => {  \n  // \"context\" is an isolated BrowserContext, created for this specific test.  \n  // \"page\" belongs to this context.  \n});  \n  \ntest('another test', async ({ page, context }) => {  \n  // \"context\" and \"page\" in this second test are completely  \n  // isolated from the first test.  \n});  \n\n\n\nconst browser = await chromium.launch();  \nconst context = await browser.newContext();  \nconst page = await context.newPage();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/browser-contexts", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Similarly, configuration file can also read environment variables passed through the command line. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    baseURL: process.env.STAGING === '1' ? 'http://staging.example.test/' : 'http://example.test/',  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "\ud83d\udc3e Steps API with [`test.step`](/docs/api/class-test#test-step)\u200b | Split long tests into multiple steps using `test.step()` API:", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  await test.step('Log in', async () => {  \n    // ...  \n  });  \n  await test.step('news feed', async () => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.getByLabel('User Name').fill('John');  \n  \nawait page.getByLabel('Password').fill('secret-password');  \n  \nawait page.getByRole('button', { name: 'Sign in' }).click();  \n  \nawait expect(page.getByText('Welcome, John!')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Read more in [our documentation](/docs/test-assertions#soft-assertions) | You can now specify a **custom expect message** as a second argument to the `expect` and `expect.soft` functions, for example:", "input": "", "output": "await expect(page.locator('text=Name'), 'should be logged in').toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: Change timeout from a `beforeEach` hook\u200b | example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.beforeEach(async ({ page }, testInfo) => {  \n  // Extend timeout for all tests running this hook by 30 seconds.  \n  testInfo.setTimeout(testInfo.timeout + 30_000);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Run your local dev server before starting the tests  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n    stdout: 'ignore',  \n    stderr: 'pipe',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-webserver", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "New method [locator.all()](/docs/api/class-locator#locator-all) to iterate over all matching elements:", "output": "// Check all checkboxes!  \nconst checkboxes = page.getByRole('checkbox');  \nfor (const checkbox of await checkboxes.all())  \n  await checkbox.check();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Use new options [hasNot](/docs/api/class-locator#locator-filter-option-has-not) and [hasNotText](/docs/api/class-locator#locator-filter-option-has-not-text) in [locator.filter()](/docs/api/class-locator#locator-filter) to find elements that **do not match** certain conditions.", "output": "const rowLocator = page.locator('tr');  \nawait rowLocator  \n    .filter({ hasNotText: 'text in column 1' })  \n    .filter({ hasNot: page.getByRole('button', { name: 'column 2 button' }) })  \n    .screenshot();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: To click `<x-details>`:", "input": "", "output": "await page.locator('x-details', { hasText: 'Details' }).click();  \n\n\n\n<x-details role=button aria-expanded=true aria-controls=inner-details>  \n  <div>Title</div>  \n  #shadow-root  \n    <div id=inner-details>Details</div>  \n</x-details>", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    httpCredentials: {  \n      username: 'bill',  \n      password: 'pa55w0rd',  \n    }  \n  }  \n});  \n\n\n\nconst context = await browser.newContext({  \n  httpCredentials: {  \n    username: 'bill',  \n    password: 'pa55w0rd',  \n  },  \n});  \nconst page = await context.newPage();  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "const slowExpect = expect.configure({ timeout: 10000 });  \nawait slowExpect(locator).toHaveText('Submit');  \n  \n// Always do soft assertions.  \nconst softExpect = expect.configure({ soft: true });  \nawait softExpect(locator).toHaveText('Submit');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: You can also specify custom timeout and retry intervals:", "input": "", "output": "await expect(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  expect(response.status()).toBe(200);  \n}).toPass({  \n  // Probe, wait 1s, probe, wait 2s, probe, wait 10s, probe, wait 10s, probe  \n  // ... Defaults to [100, 250, 500, 1000].  \n  intervals: [1_000, 2_000, 10_000],  \n  timeout: 60_000  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Generate a Playwright test for the following scenario: tests/example.spec.ts", "input": "", "output": "import { test } from '@playwright/test';  \n  \ntest.beforeEach(async ({ context }) => {  \n  // Runs before each test and signs in each page.  \n  await context.grantPermissions(['notifications'], { origin: 'https://skype.com' });  \n});  \n  \ntest('first', async ({ page }) => {  \n  // page has notifications permission for https://skype.com.  \n});  \n\n\n\nawait context.grantPermissions(['notifications'], { origin: 'https://skype.com' });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You can chain methods that create a locator, like [page.getByText()](/docs/api/class-page#page-get-by-text) or [locator.getByRole()](/docs/api/class-locator#locator-get-by-role), to narrow down the search to a particular part of the page. | In this example we first create a locator called product by locating its role of `listitem`. We then filter by text. We can use the product locator again to get by role of button and click it and then use an assertion to make sure there is only one product with the text \"Product 2\".", "output": "const product = page.getByRole('listitem').filter({ hasText: 'Product 2' });  \n  \nawait product.getByRole('button', { name: 'Add to cart' }).click();  \n  \nawait expect(product).toHaveCount(1);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const locator = page.frameLocator('#my-iframe').locator('text=Submit');  \nawait locator.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Only test what you control. Don't try to test links to external sites or third party servers that you do not control. Not only is it time consuming and can slow down your tests but also you cannot control the content of the page you are linking to, or if there are cookie banners or overlay pages or anything else that might cause your test to fail. | Instead, use the [Playwright Network API](/docs/network#handle-requests) and guarantee the response needed.", "input": "", "output": "await page.route('**/api/fetch_data_third_party_dependency', route => route.fulfill({  \n  status: 200,  \n  body: testData,  \n}));  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/best-practices"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "On the other hand, Playwright understands when you perform a multiple-element operation, so the following call works perfectly fine when the locator resolves to multiple elements. | Works fine with multiple elements\u200b", "output": "await page.getByRole('button').count();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Generic click  \nawait page.getByRole('button').click();  \n  \n// Double click  \nawait page.getByText('Item').dblclick();  \n  \n// Right click  \nawait page.getByText('Item').click({ button: 'right' });  \n  \n// Shift + click  \nawait page.getByText('Item').click({ modifiers: ['Shift'] });  \n  \n// Ctrl + click or Windows and Linux  \n// Meta + click on macOS  \nawait page.getByText('Item').click({ modifiers: ['ControlOrMeta'] });  \n  \n// Hover over element  \nawait page.getByText('Item').hover();  \n  \n// Click the top left corner  \nawait page.getByText('Item').click({ position: { x: 0, y: 0 } });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Important: import our fixtures.  \nimport { test, assert } from '../playwright/fixtures';  \n  \ntest('test', async ({ dbUserName }) => {  \n  // Use the user name in the test.  \n});", "output": "// Important: import our fixtures.  \nimport { test, expect } from '../playwright/fixtures';  \n  \ntest('test', async ({ dbUserName }) => {  \n  // Use the user name in the test.  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-parallel", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Modify responses\u200b | To modify a response use [APIRequestContext](/docs/api/class-apirequestcontext \"APIRequestContext\") to get the original response and then pass the response to [route.fulfill()](/docs/api/class-route#route-fulfill). You can override individual fields on the response via options:", "input": "", "output": "await page.route('**/title.html', async route => {  \n  // Fetch original response.  \n  const response = await route.fetch();  \n  // Add a prefix to the title.  \n  let body = await response.text();  \n  body = body.replace('<title>', '<title>My prefix:');  \n  await route.fulfill({  \n    // Pass all fields from the response.  \n    response,  \n    // Override response body.  \n    body,  \n    // Force content type to be html.  \n    headers: {  \n      ...response.headers(),  \n      'content-type': 'text/html'  \n    }  \n  });  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "We recommend prioritizing [user-visible locators](/docs/locators#quick-guide) like text or accessible role instead of using XPath that is tied to the implementation and easily break when the page changes. | XPath locators are equivalent to calling [`Document.evaluate`](https://developer.mozilla.org/en/docs/Web/API/Document/evaluate).", "output": "await page.locator('xpath=//button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.getByRole('button').dispatchEvent('click');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: todo.spec.ts", "input": "", "output": "const { test } = require('@playwright/test');  \nconst { TodoPage } = require('./todo-page');  \n  \ntest.describe('todo tests', () => {  \n  let todoPage;  \n  \n  test.beforeEach(async ({ page }) => {  \n    todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo('item1');  \n    await todoPage.addToDo('item2');  \n  });  \n  \n  test.afterEach(async () => {  \n    await todoPage.removeAll();  \n  });  \n  \n  test('should add an item', async () => {  \n    await todoPage.addToDo('my item');  \n    // ...  \n  });  \n  \n  test('should remove an item', async () => {  \n    await todoPage.remove('item1');  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Start waiting for request before goto. Note no await.  \nconst requestPromise = page.waitForRequest('**/*logo*.png');  \nawait page.navigate('https://wikipedia.org');  \nconst request = await requestPromise;  \nconsole.log(request.url());", "output": "// Start waiting for request before goto. Note no await.  \nconst requestPromise = page.waitForRequest('**/*logo*.png');  \nawait page.goto('https://wikipedia.org');  \nconst request = await requestPromise;  \nconsole.log(request.url());", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/events", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('group', {  \n  tag: '@report',  \n}, () => {  \n  test('test report header', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('test full report', {  \n    tag: ['@slow', '@vrt'],  \n  }, async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Create a locator.  \nconst getStarted = page.getByRole('link', { name: 'Get started' });  \n  \n// Click it.  \nawait getStarted.click();", "output": "// Create a locator.  \nconst getStarted = page.getByRole('link', { name: 'Get started' });  \n  \n// Click it.  \nawait getStarted.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/writing-tests", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const button = page.getByRole('button').and(page.getByTitle('Subscribe'));", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  await page.goto('/');  \n  // You are signed in!  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: You can locate the element by its test id:", "input": "", "output": "await page.getByTestId('directions').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Start waiting for file chooser before clicking. Note no await.  \nconst fileChooserPromise = page.waitForEvent('filechooser');  \nawait page.getByLabel('Upload file').click();  \nconst fileChooser = await fileChooserPromise;  \nawait fileChooser.setFiles(path.join(__dirname, 'myfile.pdf'));", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/test';  \n  \ntest('admin and user', async ({ browser }) => {  \n  // adminContext and all pages inside, including adminPage, are signed in as \"admin\".  \n  const adminContext = await browser.newContext({ storageState: 'playwright/.auth/admin.json' });  \n  const adminPage = await adminContext.newPage();  \n  \n  // userContext and all pages inside, including userPage, are signed in as \"user\".  \n  const userContext = await browser.newContext({ storageState: 'playwright/.auth/user.json' });  \n  const userPage = await userContext.newPage();  \n  \n  // ... interact with both adminPage and userPage ...  \n  \n  await adminContext.close();  \n  await userContext.close();  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/auth", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await page.goto('https://playwright.dev');  \nawait expect(page).toHaveScreenshot({  \n  mask: [page.locator('img')],  \n  maskColor: '#00FF00', // green  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  await expect(page).toHaveScreenshot({ maxDiffPixels: 100 });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as base } from '@playwright/test';  \nimport { TodoPage } from './todo-page';  \nimport { SettingsPage } from './settings-page';  \n  \n// Declare the types of your fixtures.  \ntype MyFixtures = {  \n  todoPage: TodoPage;  \n  settingsPage: SettingsPage;  \n};  \n  \n// Extend base test by providing \"todoPage\" and \"settingsPage\".  \n// This new \"test\" can be used in multiple test files, and each of them will get the fixtures.  \nexport const test = base.extend<MyFixtures>({  \n  todoPage: async ({ page }, use) => {  \n    // Set up the fixture.  \n    const todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo('item1');  \n    await todoPage.addToDo('item2');  \n  \n    // Use the fixture value in the test.  \n    await use(todoPage);  \n  \n    // Clean up the fixture.  \n    await todoPage.removeAll();  \n  },  \n  \n  settingsPage: async ({ page }, use) => {  \n    await use(new SettingsPage(page));  \n  },  \n});  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: If you intend to edit HAR by hand, consider using the `\"minimal\"` HAR recording mode that only records information that is essential for replaying:", "input": "", "output": "const context = await browser.newContext({  \n  recordHar: {  \n    path: 'github.har',  \n    mode: 'minimal',  \n  }  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// 5 in-stock items  \nawait expect(page.getByRole('listitem').filter({ hasNotText: 'Out of stock' })).toHaveCount(5);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Iterate using regular for loop:", "input": "", "output": "const rows = page.getByRole('listitem');  \nconst count = await rows.count();  \nfor (let i = 0; i < count; ++i)  \n  console.log(await rows.nth(i).textContent());", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Use a RegExp. Note no await.  \nconst responsePromise = page.waitForResponse(/\\.jpeg$/);  \nawait page.getByText('Update').click();  \nconst response = await responsePromise;  \n  \n// Use a predicate taking a Response object. Note no await.  \nconst responsePromise = page.waitForResponse(response => response.url().includes(token));  \nawait page.getByText('Update').click();  \nconst response = await responsePromise;", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test('should not have any accessibility violations outside of elements with known issues', async ({  \n  page,  \n}) => {  \n  await page.goto('https://your-site.com/page-with-known-issues');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .exclude('#element-with-known-issue')  \n      .analyze();  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "src/pages/ProductsPage.spec.tsx", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport type { HooksConfig } from '../playwright';  \nimport { ProductsPage } from './pages/ProductsPage';  \n  \ntest('configure routing through hooks config', async ({ page, mount }) => {  \n  const component = await mount<HooksConfig>(<ProductsPage />, {  \n    hooksConfig: { enableRouting: true },  \n  });  \n  await expect(component.getByRole('link')).toHaveAttribute('href', '/products/42');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "* disables animations\n* uses CSS scale option\n\n    await page.goto('https://playwright.dev');  \nawait expect(page).toHaveScreenshot();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: To make environment variables easier to manage, consider something like `.env` files. Here is an example that uses [`dotenv`](https://www.npmjs.com/package/dotenv) package to read environment variables directly in the configuration file. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \nimport dotenv from 'dotenv';  \nimport path from 'path';  \n  \n// Read from \".env\" file.  \ndotenv.config({ path: path.resolve(__dirname, '.env') });  \n  \n// Alternatively, read from \"../my.env\" file.  \ndotenv.config({ path: path.resolve(__dirname, '..', 'my.env') });  \n  \nexport default defineConfig({  \n  use: {  \n    baseURL: process.env.STAGING === '1' ? 'http://staging.example.test/' : 'http://example.test/',  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Generate a Playwright test for the following scenario: tests/example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  viewport: { width: 1600, height: 1200 },  \n});  \n  \ntest('my test', async ({ page }) => {  \n  // ...  \n});  \n\n\n\n// Create context with given viewport  \nconst context = await browser.newContext({  \n  viewport: { width: 1280, height: 1024 }  \n});  \n  \n// Resize viewport for individual page  \nawait page.setViewportSize({ width: 1600, height: 1200 });  \n  \n// Emulate high-DPI  \nconst context = await browser.newContext({  \n  viewport: { width: 2560, height: 1440 },  \n  deviceScaleFactor: 2,  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "You can click on the image after locating it by the text alternative:", "output": "await page.getByAltText('playwright logo').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "navigation"}}
{"instruction": "Generate a Playwright test for the following scenario: > New Headless on the other hand is the real Chrome browser, and is thus more authentic, reliable, and offers more features. This makes it more suitable for high-accuracy end-to-end web app testing or browser extension testing. | See [issue #33566](https://github.com/microsoft/playwright/issues/33566) for details.", "input": "", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'], channel: 'chromium' },  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/browsers"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "A similar configuration in Next.js would look like this: | src/component.spec.jsx", "output": "import { test } from '@playwright/experimental-ct-react';  \nimport { Component } from './mycomponent';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<Component></Component>, {  \n    // Pass mock value from test into `beforeMount`.  \n    hooksConfig: {  \n      router: {  \n        query: { page: 1, per_page: 10 },  \n        asPath: '/posts'  \n      }  \n    }  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "note | If both \"New email\" button and security dialog appear on screen, the \"or\" locator will match both of them, possibly throwing the \"strict mode violation\" error. In this case, you can use [locator.first()](/docs/api/class-locator#locator-first) to only match one of them.", "output": "const newEmail = page.getByRole('button', { name: 'New' });  \nconst dialog = page.getByText('Confirm security settings');  \nawait expect(newEmail.or(dialog).first()).toBeVisible();  \nif (await dialog.isVisible())  \n  await page.getByRole('button', { name: 'Dismiss' }).click();  \nawait newEmail.click();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    baseURL: process.env.STAGING === '1' ? 'http://staging.example.test/' : 'http://example.test/',  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parameterize", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Creating mocks\u200b | Since the page may be calling the API very early while loading it's important to setup all the mocks before the page started loading. The easiest way to achieve that is to call [page.addInitScript()](/docs/api/class-page#page-add-init-script):", "output": "await page.addInitScript(() => {  \n  const mockBattery = {  \n    level: 0.75,  \n    charging: true,  \n    chargingTime: 1800,  \n    dischargingTime: Infinity,  \n    addEventListener: () => { }  \n  };  \n  // Override the method to always return mock battery info.  \n  window.navigator.getBattery = async () => mockBattery;  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/mock-browser-apis"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  timeout: 60000, // Timeout is shared between all tests.  \n  projects: [  \n    {  \n      name: 'Smoke',  \n      testMatch: /.*smoke.spec.ts/,  \n      retries: 0,  \n    },  \n    {  \n      name: 'Default',  \n      testIgnore: /.*smoke.spec.ts/,  \n      retries: 2,  \n    },  \n  ],  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  timeout: 60000, // Timeout is shared between all tests.  \n  projects: [  \n    {  \n      name: 'Smoke',  \n      testMatch: /.*smoke.spec.ts/,  \n      retries: 0,  \n    },  \n    {  \n      name: 'Default',  \n      testIgnore: /.*smoke.spec.ts/,  \n      retries: 2,  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-projects", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const { test, assert } = require('@playwright/test');  \nconst { PlaywrightDevPage } = require('./playwright-dev-page');  \n  \ntest('getting started should contain table of contents', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.getStarted();  \n  await assert(playwrightDev.tocList).toHaveText([  \n    `How to install Playwright`,  \n    `What's Installed`,  \n    `How to run the example test`,  \n    `How to open the HTML test report`,  \n    `Write tests using web first assertions, page fixtures and locators`,  \n    `Run single test, multiple tests, headed mode`,  \n    `Generate tests with Codegen`,  \n    `See a trace of your tests`  \n  ]);  \n});  \n  \ntest('should show Page Object Model article', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.pageObjectModel();  \n  await assert(page.locator('article')).toContainText('Page Object Model is a common pattern');  \n});", "output": "const { test, expect } = require('@playwright/test');  \nconst { PlaywrightDevPage } = require('./playwright-dev-page');  \n  \ntest('getting started should contain table of contents', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.getStarted();  \n  await expect(playwrightDev.tocList).toHaveText([  \n    `How to install Playwright`,  \n    `What's Installed`,  \n    `How to run the example test`,  \n    `How to open the HTML test report`,  \n    `Write tests using web first assertions, page fixtures and locators`,  \n    `Run single test, multiple tests, headed mode`,  \n    `Generate tests with Codegen`,  \n    `See a trace of your tests`  \n  ]);  \n});  \n  \ntest('should show Page Object Model article', async ({ page }) => {  \n  const playwrightDev = new PlaywrightDevPage(page);  \n  await playwrightDev.goto();  \n  await playwrightDev.pageObjectModel();  \n  await expect(page.locator('article')).toContainText('Page Object Model is a common pattern');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/pom", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  // This will navigate to http://127.0.0.1:3000/login  \n  await page.goto('./login');  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-webserver", "type": "website_test"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "Create `playwright/fixtures.ts` file that will [override `storageState` fixture](/docs/test-fixtures#overriding-fixtures) to authenticate once per worker. Use [testInfo.parallelIndex](/docs/api/class-testinfo#test-info-parallel-index) to differentiate between workers. | playwright/fixtures.ts", "output": "import { test as baseTest, expect } from '@playwright/test';  \nimport fs from 'fs';  \nimport path from 'path';  \n  \nexport * from '@playwright/test';  \nexport const test = baseTest.extend<{}, { workerStorageState: string }>({  \n  // Use the same storage state for all tests in this worker.  \n  storageState: ({ workerStorageState }, use) => use(workerStorageState),  \n  \n  // Authenticate once per worker with a worker-scoped fixture.  \n  workerStorageState: [async ({ browser }, use) => {  \n    // Use parallelIndex as a unique identifier for each worker.  \n    const id = test.info().parallelIndex;  \n    const fileName = path.resolve(test.info().project.outputDir, `.auth/${id}.json`);  \n  \n    if (fs.existsSync(fileName)) {  \n      // Reuse existing authentication state if any.  \n      await use(fileName);  \n      return;  \n    }  \n  \n    // Important: make sure we authenticate in a clean environment by unsetting storage state.  \n    const page = await browser.newPage({ storageState: undefined });  \n  \n    // Acquire a unique account, for example create a new one.  \n    // Alternatively, you can have a list of precreated accounts for testing.  \n    // Make sure that accounts are unique, so that multiple team members  \n    // can run tests at the same time without interference.  \n    const account = await acquireAccount(id);  \n  \n    // Perform authentication steps. Replace these actions with your own.  \n    await page.goto('https://github.com/login');  \n    await page.getByLabel('Username or email address').fill(account.username);  \n    await page.getByLabel('Password').fill(account.password);  \n    await page.getByRole('button', { name: 'Sign in' }).click();  \n    // Wait until the page receives the cookies.  \n    //  \n    // Sometimes login flow sets cookies in the process of several redirects.  \n    // Wait for the final URL to ensure that the cookies are actually set.  \n    await page.waitForURL('https://github.com/');  \n    // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n    await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n    // End of authentication steps.  \n  \n    await page.context().storageState({ path: fileName });  \n    await page.close();  \n    await use(fileName);  \n  }, { scope: 'worker' }],  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/auth", "type": "fixture"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest.use({  \n  viewport: { width: 1600, height: 1200 },  \n});  \n  \ntest('my test', async ({ page }) => {  \n  // ...  \n});  \n\n\n\n// Create context with given viewport  \nconst context = await browser.newContext({  \n  viewport: { width: 1280, height: 1024 }  \n});  \n  \n// Resize viewport for individual page  \nawait page.setViewportSize({ width: 1600, height: 1200 });  \n  \n// Emulate high-DPI  \nconst context = await browser.newContext({  \n  viewport: { width: 2560, height: 1440 },  \n  deviceScaleFactor: 2,  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  viewport: { width: 1600, height: 1200 },  \n});  \n  \ntest('my test', async ({ page }) => {  \n  // ...  \n});  \n\n\n\n// Create context with given viewport  \nconst context = await browser.newContext({  \n  viewport: { width: 1280, height: 1024 }  \n});  \n  \n// Resize viewport for individual page  \nawait page.setViewportSize({ width: 1600, height: 1200 });  \n  \n// Emulate high-DPI  \nconst context = await browser.newContext({  \n  viewport: { width: 2560, height: 1440 },  \n  deviceScaleFactor: 2,  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect(page.locator('x-details')).toContainText('Details');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \nimport path from 'path';  \n  \ntest.beforeEach(async ({ page }) => {  \n  // Add script for every test in the beforeEach hook.  \n  // Make sure to correctly resolve the script path.  \n  await page.addInitScript({ path: path.resolve(__dirname, '../mocks/preload.js') });  \n});", "output": "import { test, expect } from '@playwright/test';  \nimport path from 'path';  \n  \ntest.beforeEach(async ({ page }) => {  \n  // Add script for every test in the beforeEach hook.  \n  // Make sure to correctly resolve the script path.  \n  await page.addInitScript({ path: path.resolve(__dirname, '../mocks/preload.js') });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/evaluating", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  geolocation: { longitude: 41.890221, latitude: 12.492348 },  \n  permissions: ['geolocation'],  \n});  \n  \ntest('my test with geolocation', async ({ page, context }) => {  \n  // overwrite the location for this test  \n  await context.setGeolocation({ longitude: 48.858455, latitude: 2.294474 });  \n});  \n\n\n\nawait context.setGeolocation({ longitude: 48.858455, latitude: 2.294474 });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Use parallelism and sharding\u200b | Playwright runs tests in [parallel](/docs/test-parallel) by default. Tests in a single file are run in order, in the same worker process. If you have many independent tests in a single file, you might want to run them in parallel", "input": "", "output": "import { test } from '@playwright/test';  \n  \ntest.describe.configure({ mode: 'parallel' });  \n  \ntest('runs in parallel 1', async ({ page }) => { /* ... */ });  \ntest('runs in parallel 2', async ({ page }) => { /* ... */ });", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/best-practices"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Use a regular expression:", "output": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: /Product 2/ })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "The following snippet is **CORRECT** because it passes the value explicitly as an argument:", "output": "const data = 'some data';  \n// Pass |data| as a parameter.  \nconst result = await page.evaluate(data => {  \n  window.myApp.use(data);  \n}, data);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/evaluating"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('slot', async ({ mount }) => {  \n  const component = await mount(Component, { slots: { default: 'Slot' } });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// This is less fragile than snapshotting the entire violations array.  \nexpect(violationFingerprints(accessibilityScanResults)).toMatchSnapshot();  \n  \n// my-test-utils.js  \nfunction violationFingerprints(accessibilityScanResults) {  \n  const violationFingerprints = accessibilityScanResults.violations.map(violation => ({  \n    rule: violation.id,  \n    // These are CSS selectors which uniquely identify each element with  \n    // a violation of the rule in question.  \n    targets: violation.nodes.map(node => node.target),  \n  }));  \n  \n  return JSON.stringify(violationFingerprints, null, 2);  \n}", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  helperFixture: [async ({}, use, testInfo) => {  \n    // ...  \n  }, { box: true }],  \n});", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend({  \n  helperFixture: [async ({}, use, testInfo) => {  \n    // ...  \n  }, { box: true }],  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Locators are strict. This means that all operations on locators that imply some target DOM element will throw an exception if more than one element matches. For example, the following call throws if there are several buttons in the DOM: | Throws an error if more than one\u200b", "output": "await page.getByRole('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Subscribe to 'request' and 'response' events.  \npage.on('request', request => console.log('>>', request.method(), request.url()));  \npage.on('response', response => console.log('<<', response.status(), response.url()));  \n  \nawait page.navigate('https://example.com');", "output": "// Subscribe to 'request' and 'response' events.  \npage.on('request', request => console.log('>>', request.method(), request.url()));  \npage.on('response', response => console.log('<<', response.status(), response.url()));  \n  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.locator('_react=SubmitButton[enabled=true]').click();  \nawait page.locator('_vue=submit-button[enabled=true]').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: You can match it using the following snapshot template:", "input": "", "output": "await expect(page.locator('body')).toMatchAriaSnapshot(`  \n  - heading \"title\"  \n`);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/aria-snapshots"}}
{"instruction": "Generate a Playwright test for the following scenario: Adding/removing event listener\u200b | Sometimes, events happen in random time and instead of waiting for them, they need to be handled. Playwright supports traditional language mechanisms for subscribing and unsubscribing from the events:", "input": "", "output": "page.on('request', request => console.log(`Request sent: ${request.url()}`));  \nconst listener = request => console.log(`Request finished: ${request.url()}`);  \npage.on('requestfinished', listener);  \nawait page.goto('https://wikipedia.org');  \n  \npage.off('requestfinished', listener);  \nawait page.goto('https://www.openstreetmap.org/');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/events"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "alert(), confirm(), prompt() dialogs\u200b | By default, dialogs are auto-dismissed by Playwright, so you don't have to handle them. However, you can register a dialog handler before the action that triggers the dialog to either [dialog.accept()](/docs/api/class-dialog#dialog-accept) or [dialog.dismiss()](/docs/api/class-dialog#dialog-dismiss) it.", "output": "page.on('dialog', dialog => dialog.accept());  \nawait page.getByRole('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/dialogs"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const rowLocator = page.locator('tr');  \nawait rowLocator  \n    .filter({ hasNotText: 'text in column 1' })  \n    .filter({ hasNot: page.getByRole('button', { name: 'column 2 button' }) })  \n    .screenshot();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Tests have access to the `process.env` properties set in the global setup.", "input": "", "output": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  // environment variables which are set in globalSetup are only available inside test().  \n  const { FOO, BAR } = process.env;  \n  \n  // FOO and BAR properties are populated.  \n  expect(FOO).toEqual('some data');  \n  \n  const complexData = JSON.parse(BAR);  \n  expect(BAR).toEqual({ some: 'data' });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Generate a Playwright test for the following scenario: Filter by text\u200b | Locators can be filtered by text with the [locator.filter()](/docs/api/class-locator#locator-filter) method. It will search for a particular string somewhere inside the element, possibly in a descendant element, case-insensitively. You can also pass a regular expression.", "input": "", "output": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: 'Product 2' })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "component.spec.ts", "output": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('unmount', async ({ mount }) => {  \n  const component = await mount(Component);  \n  await component.unmount();  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "You can create a test list file that will control the order of tests - first run `feature-b` tests, then `feature-a` tests. Note how each test file is wrapped in a `test.describe()` block that calls the function where tests are defined. This way `test.use()` calls only affect tests from a single file. | test.list.ts", "output": "import { test } from '@playwright/test';  \nimport featureBTests from './feature-b.spec.ts';  \nimport featureATests from './feature-a.spec.ts';  \n  \ntest.describe(featureBTests);  \ntest.describe(featureATests);", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as setup, expect } from '@playwright/test';  \nimport path from 'path';  \n  \nconst authFile = path.join(__dirname, '../playwright/.auth/user.json');  \n  \nsetup('authenticate', async ({ page }) => {  \n  // Perform authentication steps. Replace these actions with your own.  \n  await page.goto('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('username');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n  // Wait until the page receives the cookies.  \n  //  \n  // Sometimes login flow sets cookies in the process of several redirects.  \n  // Wait for the final URL to ensure that the cookies are actually set.  \n  await page.waitForURL('https://github.com/');  \n  // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n  await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n  // End of authentication steps.  \n  \n  await page.context().storageState({ path: authFile });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/auth", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "In configuration file, pass options directly: | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['junit', { outputFile: 'results.xml' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Generate a Playwright test for the following scenario: Set timeout for a single test\u200b | example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('slow test', async ({ page }) => {  \n  test.slow(); // Easy way to triple the default timeout  \n  // ...  \n});  \n  \ntest('very slow test', async ({ page }) => {  \n  test.setTimeout(120_000);  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts"}}
{"instruction": "Generate a Playwright test for the following scenario: For example, you can use [`AxeBuilder.include()`](https://github.com/dequelabs/axe-core-npm/blob/develop/packages/playwright/README.md#axebuilderincludeselector-string--string) to constrain an accessibility scan to only run against one specific part of a page. | `AxeBuilder.analyze()` will scan the page _in its current state_ when you call it. To scan parts of a page that are revealed based on UI interactions, use [Locators](/docs/locators) to interact with the page before invoking `analyze()`:", "input": "", "output": "test('navigation menu should not have automatically detectable accessibility violations', async ({  \n  page,  \n}) => {  \n  await page.goto('https://your-site.com/');  \n  \n  await page.getByRole('button', { name: 'Navigation Menu' }).click();  \n  \n  // It is important to waitFor() the page to be in the desired  \n  // state *before* running analyze(). Otherwise, axe might not  \n  // find all the elements your test expects it to scan.  \n  await page.locator('#navigation-menu-flyout').waitFor();  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .include('#navigation-menu-flyout')  \n      .analyze();  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect(page.getByText('Welcome, John', { exact: true })).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.locator('button:visible').click();", "output": "await page.locator('button:visible').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: component.spec.tsx", "input": "", "output": "// Or alternatively, using the `jsx` style  \nimport { test } from '@playwright/experimental-ct-vue';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(<Component/>);  \n  await component.update(  \n      <Component msg=\"greetings\" v-on:click={() => {}}>Child</Component>  \n  );  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test for the following scenario: Evaluated scripts run in the browser environment, while your test runs in a testing environments. This means you cannot use variables from your test in the page and vice versa. Instead, you should pass them explicitly as an argument. | The following snippet is **WRONG** because it uses the variable directly:", "input": "", "output": "const data = 'some data';  \nconst result = await page.evaluate(() => {  \n  // WRONG: there is no \"data\" in the web page.  \n  window.myApp.use(data);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/evaluating"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "React locator allows finding elements by their component name and property values. The syntax is very similar to [CSS attribute selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors) and supports all CSS attribute selector operators. | In React locator, component names are transcribed with **CamelCase**.", "output": "await page.locator('_react=BookItem').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Whether to automatically download all the attachments.  \n    acceptDownloads: false,  \n  \n    // An object containing additional HTTP headers to be sent with every request.  \n    extraHTTPHeaders: {  \n      'X-My-Header': 'value',  \n    },  \n  \n    // Credentials for HTTP authentication.  \n    httpCredentials: {  \n      username: 'user',  \n      password: 'pass',  \n    },  \n  \n    // Whether to ignore HTTPS errors during navigation.  \n    ignoreHTTPSErrors: true,  \n  \n    // Whether to emulate network being offline.  \n    offline: true,  \n  \n    // Proxy settings used for all pages in the test.  \n    proxy: {  \n      server: 'http://myproxy.com:3128',  \n      bypass: 'localhost',  \n    },  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Whether to automatically download all the attachments.  \n    acceptDownloads: false,  \n  \n    // An object containing additional HTTP headers to be sent with every request.  \n    extraHTTPHeaders: {  \n      'X-My-Header': 'value',  \n    },  \n  \n    // Credentials for HTTP authentication.  \n    httpCredentials: {  \n      username: 'user',  \n      password: 'pass',  \n    },  \n  \n    // Whether to ignore HTTPS errors during navigation.  \n    ignoreHTTPSErrors: true,  \n  \n    // Whether to emulate network being offline.  \n    offline: true,  \n  \n    // Proxy settings used for all pages in the test.  \n    proxy: {  \n      server: 'http://myproxy.com:3128',  \n      bypass: 'localhost',  \n    },  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    video: {  \n      mode: 'on-first-retry',  \n      size: { width: 640, height: 480 }  \n    }  \n  },  \n});  \n\n\n\nconst context = await browser.newContext({  \n  recordVideo: {  \n    dir: 'videos/',  \n    size: { width: 640, height: 480 },  \n  }  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/videos"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Test with predefined time\u200b | Often you only need to fake `Date.now` while keeping the timers going. That way the time flows naturally, but `Date.now` always returns a fixed value.", "output": "<div id=\"current-time\" data-testid=\"current-time\"></div>  \n<script>  \n  const renderTime = () => {  \n    document.getElementById('current-time').textContent =  \n        new Date().toLocaleString();  \n  };  \n  setInterval(renderTime, 1000);  \n</script>  \n\n\n\nawait page.clock.setFixedTime(new Date('2024-02-02T10:00:00'));  \nawait page.goto('http://localhost:3333');  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \nawait page.clock.setFixedTime(new Date('2024-02-02T10:30:00'));  \n// We know that the page has a timer that updates the time every second.  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:30:00 AM');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/clock"}}
{"instruction": "Generate a Playwright test for the following scenario: For example, `text=\"Log\"` does not match `<button>Log in</button>` because `<button>` contains a single text node `\"Log in\"` that is not equal to `\"Log\"`. However, `text=\"Log\"` matches `<button> Log <span>in</span></button>`, because `<button>` contains a text node `\" Log \"`. This exact mode implies case-sensitive matching, so `text=\"Download\"` will not match `<button>download</button>`. | Quoted body follows the usual escaping rules, e.g. use `\\\"` to escape double quote in a double-quoted string: `text=\"foo\\\"bar\"`.", "input": "", "output": "await page.locator('text=\"Log in\"').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test for the following scenario: Create a story file for your component: | input-media.story.tsx", "input": "", "output": "import React from 'react';  \nimport InputMedia from './import-media';  \n  \ntype InputMediaForTestProps = {  \n  onMediaChange(mediaName: string): void;  \n};  \n  \nexport function InputMediaForTest(props: InputMediaForTestProps) {  \n  // Instead of sending a complex `media` object to the test, send the media name.  \n  return <InputMedia onChange={media => props.onMediaChange(media.name)} />;  \n}  \n// Export more stories here.", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const context = await browser.newContext({  \n  recordHar: {  \n    path: 'github.har',  \n    mode: 'minimal',  \n  }  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.goto('https://playwright.dev');  \nawait expect(page.locator('body')).toMatchAriaSnapshot(`  \n  - banner:  \n    - heading /Playwright enables reliable/ [level=1]  \n    - link \"Get started\"  \n    - link \"Star microsoft/playwright on GitHub\"  \n  - main:  \n    - img \"Browsers (Chromium, Firefox, WebKit)\"  \n    - heading \"Any browser \u2022 Any platform \u2022 One API\"  \n`);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: > New Headless on the other hand is the real Chrome browser, and is thus more authentic, reliable, and offers more features. This makes it more suitable for high-accuracy end-to-end web app testing or browser extension testing. | See [issue #33566](https://github.com/microsoft/playwright/issues/33566) for the list of possible breakages you could encounter and more details on Chromium headless. Please file an issue if you see any problems after opting in.", "input": "", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'], channel: 'chromium' },  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: Modern pages perform numerous activities after the `load` event was fired. They fetch data lazily, populate UI, load expensive resources, scripts and styles after the `load` event was fired. There is no way to tell that the page is `loaded`, it depends on the page, framework, etc. So when can you start interacting with it? | In Playwright you can interact with the page at any moment. It will automatically wait for the target elements to become [actionable](/docs/actionability).", "input": "", "output": "// Navigate and click element  \n// Click will auto-wait for the element  \nawait page.goto('https://example.com');  \nawait page.getByText('Example Domain').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/navigations"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('props', async ({ mount }) => {  \n  const component = await mount(<Component msg=\"greetings\" />);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('callback', async ({ mount }) => {  \n  const component = await mount(<Component onClick={() => {}} />);  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "By default, [fixture](/docs/test-fixtures) shares timeout with the test. However, for slow fixtures, especially [worker-scoped](/docs/test-fixtures#worker-scoped-fixtures) ones, it is convenient to have a separate timeout. This way you can keep the overall test timeout small, and give the slow fixture more time. | example.spec.ts", "output": "import { test as base, expect } from '@playwright/test';  \n  \nconst test = base.extend<{ slowFixture: string }>({  \n  slowFixture: [async ({}, use) => {  \n    // ... perform a slow operation ...  \n    await use('hello');  \n  }, { timeout: 60_000 }]  \n});  \n  \ntest('example test', async ({ slowFixture }) => {  \n  // ...  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-timeouts"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const snapshot = await page.locator('body').ariaSnapshot();  \nconsole.log(snapshot);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/aria-snapshots", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "assert(await page.screenshot()).toMatchSnapshot({  \n  maxDiffPixels: 27, // allow no more than 27 different pixels.  \n});", "output": "expect(await page.screenshot()).toMatchSnapshot({  \n  maxDiffPixels: 27, // allow no more than 27 different pixels.  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('report tests', {  \n  annotation: { type: 'category', description: 'report' },  \n}, () => {  \n  test('test report header', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('test full report', {  \n    annotation: [  \n      { type: 'issue', description: 'https://github.com/microsoft/playwright/issues/23180' },  \n      { type: 'performance', description: 'very slow test!' },  \n    ],  \n  }, async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: The filtering locator **must be relative** to the original locator and is queried starting with the original locator match, not the document root. Therefore, the following will not work, because the filtering locator starts matching from the `<ul>` list element that is outside of the `<li>` list item matched by the original locator:", "input": "", "output": "// \u2716 WRONG  \nawait expect(page  \n    .getByRole('listitem')  \n    .filter({ has: page.getByRole('list').getByText('Product 2') }))  \n    .toHaveCount(1);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "To ensure that `<x-details>` contains the text \"Details\":", "output": "await expect(page.locator('x-details')).toContainText('Details');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test for the following scenario: For example, consider the following test file that needs a username and a password. It is usually a good idea not to store your secrets in the source code, so we'll need a way to pass secrets from outside. | example.spec.ts", "input": "", "output": "test(`example test`, async ({ page }) => {  \n  // ...  \n  await page.getByLabel('User Name').fill(process.env.USER_NAME);  \n  await page.getByLabel('Password').fill(process.env.PASSWORD);  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Generate a Playwright test for the following scenario: Match with a regular expression:", "input": "", "output": "await expect(page.getByText(/welcome, [A-Za-z]+$/i)).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const rowLocator = page.getByRole('listitem');  \n  \nawait rowLocator  \n    .filter({ hasText: 'Mary' })  \n    .filter({ has: page.getByRole('button', { name: 'Say goodbye' }) })  \n    .screenshot({ path: 'screenshot.png' });", "output": "const rowLocator = page.getByRole('listitem');  \n  \nawait rowLocator  \n    .filter({ hasText: 'Mary' })  \n    .filter({ has: page.getByRole('button', { name: 'Say goodbye' }) })  \n    .screenshot({ path: 'screenshot.png' });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// WRONG: THIS SNIPPET DOES NOT WORK SINCE v1.18.  \n  \n// fixtures.js  \nconst test = base.extend({  \n  myParameter: 'default',  \n});  \n  \n// playwright.config.js  \nmodule.exports = {  \n  use: {  \n    myParameter: 'value',  \n  },  \n};", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: playwright-dev-page.js", "input": "", "output": "const { expect } = require('@playwright/test');  \n  \nexports.PlaywrightDevPage = class PlaywrightDevPage {  \n  \n  /**  \n   * @param {import('@playwright/test').Page} page  \n   */  \n  constructor(page) {  \n    this.page = page;  \n    this.getStartedLink = page.locator('a', { hasText: 'Get started' });  \n    this.gettingStartedHeader = page.locator('h1', { hasText: 'Installation' });  \n    this.pomLink = page.locator('li', {  \n      hasText: 'Guides',  \n    }).locator('a', {  \n      hasText: 'Page Object Model',  \n    });  \n    this.tocList = page.locator('article div.markdown ul > li > a');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://playwright.dev');  \n  }  \n  \n  async getStarted() {  \n    await this.getStartedLink.first().click();  \n    await expect(this.gettingStartedHeader).toBeVisible();  \n  }  \n  \n  async pageObjectModel() {  \n    await this.getStarted();  \n    await this.pomLink.click();  \n  }  \n};", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/pom"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \nimport dotenv from 'dotenv';  \nimport path from 'path';  \n  \n// Read from \".env\" file.  \ndotenv.config({ path: path.resolve(__dirname, '.env') });  \n  \n// Alternatively, read from \"../my.env\" file.  \ndotenv.config({ path: path.resolve(__dirname, '..', 'my.env') });  \n  \nexport default defineConfig({  \n  use: {  \n    baseURL: process.env.STAGING === '1' ? 'http://staging.example.test/' : 'http://example.test/',  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parameterize", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test('example with attachment', async ({ page }, testInfo) => {  \n  await page.navigate('https://your-site.com/');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page }).analyze();  \n  \n  await testInfo.attach('accessibility-scan-results', {  \n    body: JSON.stringify(accessibilityScanResults, null, 2),  \n    contentType: 'application/json'  \n  });  \n  \n  assert(accessibilityScanResults.violations).toEqual([]);  \n});", "output": "test('example with attachment', async ({ page }, testInfo) => {  \n  await page.goto('https://your-site.com/');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page }).analyze();  \n  \n  await testInfo.attach('accessibility-scan-results', {  \n    body: JSON.stringify(accessibilityScanResults, null, 2),  \n    contentType: 'application/json'  \n  });  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You can also specify custom polling intervals:", "output": "await expect.poll(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  return response.status();  \n}, {  \n  // Probe, wait 1s, probe, wait 2s, probe, wait 10s, probe, wait 10s, probe  \n  // ... Defaults to [100, 250, 500, 1000].  \n  intervals: [1_000, 2_000, 10_000],  \n  timeout: 60_000  \n}).toBe(200);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.locator('text=Log in').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Locate an item by its test id of \"orange\" and then click it.", "output": "await page.getByTestId('orange').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "navigation"}}
{"instruction": "Generate a Playwright test for the following scenario: tests/example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({ userAgent: 'My user agent' });  \n  \ntest('my user agent test', async ({ page }) => {  \n  // ...  \n});  \n\n\n\nconst context = await browser.newContext({  \n  userAgent: 'My user agent'  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test('query params', async ({ request }) => {  \n  const searchParams = new URLSearchParams();  \n  searchParams.set('userId', 1);  \n  const response = await request.get(  \n      'https://jsonplaceholder.typicode.com/posts',  \n      {  \n        params: searchParams // or as a string: 'userId=1'  \n      }  \n  );  \n  // ...  \n});", "output": "test('query params', async ({ request }) => {  \n  const searchParams = new URLSearchParams();  \n  searchParams.set('userId', 1);  \n  const response = await request.get(  \n      'https://jsonplaceholder.typicode.com/posts',  \n      {  \n        params: searchParams // or as a string: 'userId=1'  \n      }  \n  );  \n  // ...  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Navigate the page  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/navigations", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Each test should be completely isolated from another test and should run independently with its own local storage, session storage, data, cookies etc. [Test isolation](/docs/browser-contexts) improves reproducibility, makes debugging easier and prevents cascading test failures. | In order to avoid repetition for a particular part of your test you can use [before and after hooks](/docs/api/class-test). Within your test file add a before hook to run a part of your test before each test such as going to a particular URL or logging in to a part of your app. This keeps your tests isolated as no test relies on another. However it is also ok to have a little duplication when tests are simple enough especially if it keeps your tests clearer and easier to read and maintain.", "input": "", "output": "import { test } from '@playwright/test';  \n  \ntest.beforeEach(async ({ page }) => {  \n  // Runs before each test and signs in each page.  \n  await page.goto('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('username');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n});  \n  \ntest('first', async ({ page }) => {  \n  // page is signed in.  \n});  \n  \ntest('second', async ({ page }) => {  \n  // page is signed in.  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/best-practices"}}
{"instruction": "Generate a Playwright test for the following scenario: Tests start already authenticated because we specify `storageState` that was populated by global setup.", "input": "", "output": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  await page.goto('/');  \n  // You are signed in!  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-global-setup-teardown"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.locator('article', {  \n  has: page.locator('.highlight'),  \n}).click();", "output": "await page.locator('article', {  \n  has: page.locator('.highlight'),  \n}).click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "class PlaywrightDevPage {  \n  /**  \n   * @param {import('playwright').Page} page  \n   */  \n  constructor(page) {  \n    this.page = page;  \n    this.getStartedLink = page.locator('a', { hasText: 'Get started' });  \n    this.gettingStartedHeader = page.locator('h1', { hasText: 'Installation' });  \n    this.pomLink = page.locator('li', {  \n      hasText: 'Playwright Test',  \n    }).locator('a', {  \n      hasText: 'Page Object Model',  \n    });  \n    this.tocList = page.locator('article div.markdown ul > li > a');  \n  }  \n  async getStarted() {  \n    await this.getStartedLink.first().click();  \n    await expect(this.gettingStartedHeader).toBeVisible();  \n  }  \n  \n  async pageObjectModel() {  \n    await this.getStarted();  \n    await this.pomLink.click();  \n  }  \n}  \nmodule.exports = { PlaywrightDevPage };", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/pom", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "alert(), confirm(), prompt() dialogs\u200b | By default, dialogs are auto-dismissed by Playwright, so you don't have to handle them. However, you can register a dialog handler before the action that triggers the dialog to either [dialog.accept()](/docs/api/class-dialog#dialog-accept) or [dialog.dismiss()](/docs/api/class-dialog#dialog-dismiss) it.", "output": "page.on('dialog', dialog => dialog.accept());  \nawait page.getByRole('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/dialogs", "type": "navigation"}}
{"instruction": "Generate a Playwright test for the following scenario: \u26d3 Serial mode with [`describe.serial`](/docs/api/class-test#test-describe-serial)\u200b | Declares a group of tests that should always be run serially. If one of the tests fails, all subsequent tests are skipped. All tests in a group are retried together.", "input": "", "output": "test.describe.serial('group', () => {  \n  test('runs first', async ({ page }) => { /* ... */ });  \n  test('runs second', async ({ page }) => { /* ... */ });  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/test';  \n  \ntest.beforeEach(async ({ page }) => {  \n  // Runs before each test and signs in each page.  \n  await page.navigate('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('username');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n});  \n  \ntest('first', async ({ page }) => {  \n  // page is signed in.  \n});  \n  \ntest('second', async ({ page }) => {  \n  // page is signed in.  \n});", "output": "import { test } from '@playwright/test';  \n  \ntest.beforeEach(async ({ page }) => {  \n  // Runs before each test and signs in each page.  \n  await page.goto('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('username');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n});  \n  \ntest('first', async ({ page }) => {  \n  // page is signed in.  \n});  \n  \ntest('second', async ({ page }) => {  \n  // page is signed in.  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/best-practices", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const button = page.getByRole('button').and(page.getByTitle('Subscribe'));", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Get session storage and store as env variable  \nconst sessionStorage = await page.evaluate(() => JSON.stringify(sessionStorage));  \nfs.writeFileSync('playwright/.auth/session.json', sessionStorage, 'utf-8');  \n  \n// Set session storage in a new context  \nconst sessionStorage = JSON.parse(fs.readFileSync('playwright/.auth/session.json', 'utf-8'));  \nawait context.addInitScript(storage => {  \n  if (window.location.hostname === 'example.com') {  \n    for (const [key, value] of Object.entries(storage))  \n      window.sessionStorage.setItem(key, value);  \n  }  \n}, sessionStorage);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/auth", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the page_object pattern.", "input": "playwright-dev-page.js", "output": "const { expect } = require('@playwright/test');  \n  \nexports.PlaywrightDevPage = class PlaywrightDevPage {  \n  \n  /**  \n   * @param {import('@playwright/test').Page} page  \n   */  \n  constructor(page) {  \n    this.page = page;  \n    this.getStartedLink = page.locator('a', { hasText: 'Get started' });  \n    this.gettingStartedHeader = page.locator('h1', { hasText: 'Installation' });  \n    this.pomLink = page.locator('li', {  \n      hasText: 'Guides',  \n    }).locator('a', {  \n      hasText: 'Page Object Model',  \n    });  \n    this.tocList = page.locator('article div.markdown ul > li > a');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://playwright.dev');  \n  }  \n  \n  async getStarted() {  \n    await this.getStartedLink.first().click();  \n    await expect(this.gettingStartedHeader).toBeVisible();  \n  }  \n  \n  async pageObjectModel() {  \n    await this.getStarted();  \n    await this.pomLink.click();  \n  }  \n};", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/pom"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Do something with each element in the list\u200b | Iterate elements:", "output": "for (const row of await page.getByRole('listitem').all())  \n  console.log(await row.textContent());", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test for the following scenario: tests/example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  locale: 'de-DE',  \n  timezoneId: 'Europe/Berlin',  \n});  \n  \ntest('my test for de lang in Berlin timezone', async ({ page }) => {  \n  await page.goto('https://www.bing.com');  \n  // ...  \n});  \n\n\n\nconst context = await browser.newContext({  \n  locale: 'de-DE',  \n  timezoneId: 'Europe/Berlin',  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Or wait for a network response after the button click with [page.waitForResponse()](/docs/api/class-page#page-wait-for-response):", "output": "// Use a glob URL pattern. Note no await.  \nconst responsePromise = page.waitForResponse('**/api/fetch_data');  \nawait page.getByText('Update').click();  \nconst response = await responsePromise;", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import type { Page, Locator } from '@playwright/test';  \n  \nexport class TodoPage {  \n  private readonly inputBox: Locator;  \n  private readonly todoItems: Locator;  \n  \n  constructor(public readonly page: Page) {  \n    this.inputBox = this.page.locator('input.new-todo');  \n    this.todoItems = this.page.getByTestId('todo-item');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://demo.playwright.dev/todomvc/');  \n  }  \n  \n  async addToDo(text: string) {  \n    await this.inputBox.fill(text);  \n    await this.inputBox.press('Enter');  \n  }  \n  \n  async remove(text: string) {  \n    const todo = this.todoItems.filter({ hasText: text });  \n    await todo.hover();  \n    await todo.getByLabel('Delete').click();  \n  }  \n  \n  async removeAll() {  \n    while ((await this.todoItems.count()) > 0) {  \n      await this.todoItems.first().hover();  \n      await this.todoItems.getByLabel('Delete').first().click();  \n    }  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: You can locate in the same way as if the shadow root was not present at all. | To click `<div>Details</div>`:", "input": "", "output": "await page.getByText('Details').click();  \n\n\n\n<x-details role=button aria-expanded=true aria-controls=inner-details>  \n  <div>Title</div>  \n  #shadow-root  \n    <div id=inner-details>Details</div>  \n</x-details>", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import type { FullConfig } from '@playwright/test';  \n  \nasync function globalSetup(config: FullConfig) {  \n  process.env.FOO = 'some data';  \n  // Or a more complicated data structure as JSON:  \n  process.env.BAR = JSON.stringify({ some: 'data' });  \n}  \n  \nexport default globalSetup;", "output": "import type { FullConfig } from '@playwright/test';  \n  \nasync function globalSetup(config: FullConfig) {  \n  process.env.FOO = 'some data';  \n  // Or a more complicated data structure as JSON:  \n  process.env.BAR = JSON.stringify({ some: 'data' });  \n}  \n  \nexport default globalSetup;", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Handle requests\u200b", "output": "await page.route('**/api/fetch_data', route => route.fulfill({  \n  status: 200,  \n  body: testData,  \n}));  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network", "type": "navigation"}}
{"instruction": "Generate a Playwright test for the following scenario: The following snippet is **CORRECT** because it passes the value explicitly as an argument:", "input": "", "output": "const data = 'some data';  \n// Pass |data| as a parameter.  \nconst result = await page.evaluate(data => {  \n  window.myApp.use(data);  \n}, data);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/evaluating"}}
{"instruction": "Generate a Playwright test for the following scenario: To avoid running `beforeEach` hooks, you can put annotations in the hook itself. | example.spec.ts", "input": "", "output": "test.beforeEach(async ({ page, isMobile }) => {  \n  test.fixme(isMobile, 'Settings page does not work in mobile yet');  \n  \n  await page.goto('http://localhost:3000/settings');  \n});  \n  \ntest('user profile', async ({ page }) => {  \n  await page.getByText('My Profile').click();  \n  // ...  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-annotations"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.routeWebSocket('/ws', ws => {  \n  ws.onMessage(message => {  \n    if (message === 'request')  \n      ws.send('response');  \n  });  \n});", "output": "await page.routeWebSocket('/ws', ws => {  \n  ws.onMessage(message => {  \n    if (message === 'request')  \n      ws.send('response');  \n  });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  expect: {  \n    toHaveScreenshot: {  \n      stylePath: './screenshot.css'  \n    },  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import type { Page, Locator } from '@playwright/test';  \n  \nexport class TodoPage {  \n  private readonly inputBox: Locator;  \n  private readonly todoItems: Locator;  \n  \n  constructor(public readonly page: Page) {  \n    this.inputBox = this.page.locator('input.new-todo');  \n    this.todoItems = this.page.getByTestId('todo-item');  \n  }  \n  \n  async goto() {  \n    await this.page.navigate('https://demo.playwright.dev/todomvc/');  \n  }  \n  \n  async addToDo(text: string) {  \n    await this.inputBox.fill(text);  \n    await this.inputBox.press('Enter');  \n  }  \n  \n  async remove(text: string) {  \n    const todo = this.todoItems.filter({ hasText: text });  \n    await todo.hover();  \n    await todo.getByLabel('Delete').click();  \n  }  \n  \n  async removeAll() {  \n    while ((await this.todoItems.count()) > 0) {  \n      await this.todoItems.first().hover();  \n      await this.todoItems.getByLabel('Delete').first().click();  \n    }  \n  }  \n}", "output": "import type { Page, Locator } from '@playwright/test';  \n  \nexport class TodoPage {  \n  private readonly inputBox: Locator;  \n  private readonly todoItems: Locator;  \n  \n  constructor(public readonly page: Page) {  \n    this.inputBox = this.page.locator('input.new-todo');  \n    this.todoItems = this.page.getByTestId('todo-item');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://demo.playwright.dev/todomvc/');  \n  }  \n  \n  async addToDo(text: string) {  \n    await this.inputBox.fill(text);  \n    await this.inputBox.press('Enter');  \n  }  \n  \n  async remove(text: string) {  \n    const todo = this.todoItems.filter({ hasText: text });  \n    await todo.hover();  \n    await todo.getByLabel('Delete').click();  \n  }  \n  \n  async removeAll() {  \n    while ((await this.todoItems.count()) > 0) {  \n      await this.todoItems.first().hover();  \n      await this.todoItems.getByLabel('Delete').first().click();  \n    }  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Now, each test file should import `test` from our fixtures file instead of `@playwright/test`. | tests/example.spec.ts", "input": "", "output": "// Important: import our fixtures.  \nimport { test, expect } from '../playwright/fixtures';  \n  \ntest('test', async ({ dbUserName }) => {  \n  // Use the user name in the test.  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// A primitive value.  \nawait page.evaluate(num => num, 42);  \n  \n// An array.  \nawait page.evaluate(array => array.length, [1, 2, 3]);  \n  \n// An object.  \nawait page.evaluate(object => object.foo, { foo: 'bar' });  \n  \n// A single handle.  \nconst button = await page.evaluateHandle('window.button');  \nawait page.evaluate(button => button.textContent, button);  \n  \n// Alternative notation using JSHandle.evaluate.  \nawait button.evaluate((button, from) => button.textContent.substring(from), 5);  \n  \n// Object with multiple handles.  \nconst button1 = await page.evaluateHandle('window.button1');  \nconst button2 = await page.evaluateHandle('window.button2');  \nawait page.evaluate(  \n    o => o.button1.textContent + o.button2.textContent,  \n    { button1, button2 });  \n  \n// Object destructuring works. Note that property names must match  \n// between the destructured object and the argument.  \n// Also note the required parenthesis.  \nawait page.evaluate(  \n    ({ button1, button2 }) => button1.textContent + button2.textContent,  \n    { button1, button2 });  \n  \n// Array works as well. Arbitrary names can be used for destructuring.  \n// Note the required parenthesis.  \nawait page.evaluate(  \n    ([b1, b2]) => b1.textContent + b2.textContent,  \n    [button1, button2]);  \n  \n// Any mix of serializables and handles works.  \nawait page.evaluate(  \n    x => x.button1.textContent + x.list[0].textContent + String(x.foo),  \n    { button1, list: [button2], foo: null });", "output": "// A primitive value.  \nawait page.evaluate(num => num, 42);  \n  \n// An array.  \nawait page.evaluate(array => array.length, [1, 2, 3]);  \n  \n// An object.  \nawait page.evaluate(object => object.foo, { foo: 'bar' });  \n  \n// A single handle.  \nconst button = await page.evaluateHandle('window.button');  \nawait page.evaluate(button => button.textContent, button);  \n  \n// Alternative notation using JSHandle.evaluate.  \nawait button.evaluate((button, from) => button.textContent.substring(from), 5);  \n  \n// Object with multiple handles.  \nconst button1 = await page.evaluateHandle('window.button1');  \nconst button2 = await page.evaluateHandle('window.button2');  \nawait page.evaluate(  \n    o => o.button1.textContent + o.button2.textContent,  \n    { button1, button2 });  \n  \n// Object destructuring works. Note that property names must match  \n// between the destructured object and the argument.  \n// Also note the required parenthesis.  \nawait page.evaluate(  \n    ({ button1, button2 }) => button1.textContent + button2.textContent,  \n    { button1, button2 });  \n  \n// Array works as well. Arbitrary names can be used for destructuring.  \n// Note the required parenthesis.  \nawait page.evaluate(  \n    ([b1, b2]) => b1.textContent + b2.textContent,  \n    [button1, button2]);  \n  \n// Any mix of serializables and handles works.  \nawait page.evaluate(  \n    x => x.button1.textContent + x.list[0].textContent + String(x.foo),  \n    { button1, list: [button2], foo: null });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/evaluating", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/experimental-ct-vue';  \n  \ntest('props', async ({ mount }) => {  \n  const component = await mount(Component, { props: { msg: 'greetings' } });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const locator = page.locator('iframe[name=\"embedded\"]');  \n// ...  \nconst frameLocator = locator.contentFrame();  \nawait frameLocator.getByRole('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: This will find both buttons and throw a [strictness](/docs/locators#strictness) violation error:", "input": "", "output": "await page.locator('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Initialize clock and let the page load naturally.  \nawait page.clock.install({ time: new Date('2024-02-02T08:00:00') });  \nawait page.goto('http://localhost:3333');  \n  \n// Pretend that the user closed the laptop lid and opened it again at 10am,  \n// Pause the time once reached that point.  \nawait page.clock.pauseAt(new Date('2024-02-02T10:00:00'));  \n  \n// Assert the page state.  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \n// Close the laptop lid again and open it at 10:30am.  \nawait page.clock.fastForward('30:00');  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:30:00 AM');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Using `.zip` path for `recordHar` context option automatically zips the resulting HAR:", "output": "const context = await browser.newContext({  \n  recordHar: {  \n    path: 'github.har.zip',  \n  }  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const button = page.getByRole('button').and(page.getByTitle('Subscribe'));", "output": "const button = page.getByRole('button').and(page.getByTitle('Subscribe'));", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Available options to configure networking: | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Whether to automatically download all the attachments.  \n    acceptDownloads: false,  \n  \n    // An object containing additional HTTP headers to be sent with every request.  \n    extraHTTPHeaders: {  \n      'X-My-Header': 'value',  \n    },  \n  \n    // Credentials for HTTP authentication.  \n    httpCredentials: {  \n      username: 'user',  \n      password: 'pass',  \n    },  \n  \n    // Whether to ignore HTTPS errors during navigation.  \n    ignoreHTTPSErrors: true,  \n  \n    // Whether to emulate network being offline.  \n    offline: true,  \n  \n    // Proxy settings used for all pages in the test.  \n    proxy: {  \n      server: 'http://myproxy.com:3128',  \n      bypass: 'localhost',  \n    },  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-use-options"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.screenshot({ path: 'screenshot.png', fullPage: true });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/screenshots", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport type { HooksConfig } from '../playwright';  \nimport { ProductsPage } from './pages/ProductsPage';  \n  \ntest('configure routing through hooks config', async ({ page, mount }) => {  \n  const component = await mount<HooksConfig>(<ProductsPage />, {  \n    hooksConfig: { enableRouting: true },  \n  });  \n  await expect(component.getByRole('link')).toHaveAttribute('href', '/products/42');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  timeout: 60000, // Timeout is shared between all tests.  \n  projects: [  \n    {  \n      name: 'Smoke',  \n      testMatch: /.*smoke.spec.ts/,  \n      retries: 0,  \n    },  \n    {  \n      name: 'Default',  \n      testIgnore: /.*smoke.spec.ts/,  \n      retries: 2,  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-projects", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Similarly, configuration file can also read environment variables passed through the command line. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    baseURL: process.env.STAGING === '1' ? 'http://staging.example.test/' : 'http://example.test/',  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Generate a Playwright test for the following scenario: Traces are recorded using the new [browserContext.tracing](/docs/api/class-browsercontext#browser-context-tracing) API:", "input": "", "output": "const browser = await chromium.launch();  \nconst context = await browser.newContext();  \n  \n// Start tracing before creating / navigating a page.  \nawait context.tracing.start({ screenshots: true, snapshots: true });  \n  \nconst page = await context.newPage();  \nawait page.goto('https://playwright.dev');  \n  \n// Stop tracing and export it into a zip archive.  \nawait context.tracing.stop({ path: 'trace.zip' });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test for the following scenario: You can extend Playwright assertions by providing custom matchers. These matchers will be available on the expect object. | test.spec.ts", "input": "", "output": "import { expect as baseExpect } from '@playwright/test';  \nexport const expect = baseExpect.extend({  \n  async toHaveAmount(locator: Locator, expected: number, options?: { timeout?: number }) {  \n    // ... see documentation for how to write matchers.  \n  },  \n});  \n  \ntest('pass', async ({ page }) => {  \n  await expect(page.getByTestId('cart')).toHaveAmount(5);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Verifying API calls\u200b | Sometimes it is useful to check if the page made all expected APIs calls. You can record all API method invocations and then compare them with golden result. [page.exposeFunction()](/docs/api/class-page#page-expose-function) may come in handy for passing message from the page back to the test code:", "output": "test('log battery calls', async ({ page }) => {  \n  const log = [];  \n  // Expose function for pushing messages to the Node.js script.  \n  await page.exposeFunction('logCall', msg => log.push(msg));  \n  await page.addInitScript(() => {  \n    const mockBattery = {  \n      level: 0.75,  \n      charging: true,  \n      chargingTime: 1800,  \n      dischargingTime: Infinity,  \n      // Log addEventListener calls.  \n      addEventListener: (name, cb) => logCall(`addEventListener:${name}`)  \n    };  \n    // Override the method to always return mock battery info.  \n    window.navigator.getBattery = async () => {  \n      logCall('getBattery');  \n      return mockBattery;  \n    };  \n  });  \n  \n  await page.goto('/');  \n  await expect(page.locator('.battery-percentage')).toHaveText('75%');  \n  \n  // Compare actual calls with golden.  \n  expect(log).toEqual([  \n    'getBattery',  \n    'addEventListener:chargingchange',  \n    'addEventListener:levelchange'  \n  ]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock-browser-apis"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    offline: true  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/emulation", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Waiting for navigation\u200b | Clicking an element could trigger multiple navigations. In these cases, it is recommended to explicitly [page.waitForURL()](/docs/api/class-page#page-wait-for-url) to a specific url.", "output": "await page.getByText('Click me').click();  \nawait page.waitForURL('**/login');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/navigations", "type": "navigation"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    screenshot: {  \n      mode: 'only-on-failure',  \n      fullPage: true,  \n    }  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "component.spec.ts", "output": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('unmount', async ({ mount }) => {  \n  const component = await mount(Component);  \n  await component.unmount();  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe(() => {  \n  // All tests in this describe group will get 2 retry attempts.  \n  test.describe.configure({ retries: 2 });  \n  \n  test('test 1', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('test 2', async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-retries", "type": "website_test"}}
