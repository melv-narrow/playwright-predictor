{"instruction": "Generate a Playwright test for the following scenario: We can use this option in the test, similarly to [fixtures](/docs/test-fixtures). | example.spec.ts", "input": "", "output": "import { test } from './my-test';  \n  \ntest('test 1', async ({ page, person }) => {  \n  await page.goto(`/index.html`);  \n  await expect(page.locator('#node')).toContainText(person);  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Generate a Playwright test for the following scenario: SettingsPage is similar: | settings-page.ts", "input": "", "output": "import type { Page } from '@playwright/test';  \n  \nexport class SettingsPage {  \n  constructor(public readonly page: Page) {  \n  }  \n  \n  async switchToDarkMode() {  \n    // ...  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test('event should work', async ({ mount }) => {  \n  let clicked = false;  \n  \n  // Mount a component. Returns locator pointing to the component.  \n  const component = await mount(  \n    <Button title=\"Submit\" onClick={() => { clicked = true }}></Button>  \n  );  \n  \n  // As with any Playwright test, assert locator text.  \n  await assert(component).toContainText('Submit');  \n  \n  // Perform locator click. This will trigger the event.  \n  await component.click();  \n  \n  // Assert that respective events have been fired.  \n  assert(clicked).toBeTruthy();  \n});", "output": "test('event should work', async ({ mount }) => {  \n  let clicked = false;  \n  \n  // Mount a component. Returns locator pointing to the component.  \n  const component = await mount(  \n    <Button title=\"Submit\" onClick={() => { clicked = true }}></Button>  \n  );  \n  \n  // As with any Playwright test, assert locator text.  \n  await expect(component).toContainText('Submit');  \n  \n  // Perform locator click. This will trigger the event.  \n  await component.click();  \n  \n  // Assert that respective events have been fired.  \n  expect(clicked).toBeTruthy();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest.describe('report tests', {  \n  annotation: { type: 'category', description: 'report' },  \n}, () => {  \n  test('test report header', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('test full report', {  \n    annotation: [  \n      { type: 'issue', description: 'https://github.com/microsoft/playwright/issues/23180' },  \n      { type: 'performance', description: 'very slow test!' },  \n    ],  \n  }, async ({ page }) => {  \n    // ...  \n  });  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('report tests', {  \n  annotation: { type: 'category', description: 'report' },  \n}, () => {  \n  test('test report header', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('test full report', {  \n    annotation: [  \n      { type: 'issue', description: 'https://github.com/microsoft/playwright/issues/23180' },  \n      { type: 'performance', description: 'very slow test!' },  \n    ],  \n  }, async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "You can't pass data to your component synchronously in a callback:", "output": "test('this will not work', async ({ mount }) => {  \n  // () => 'red' callback lives in Node. If `ColorPicker` component in the browser calls the parameter function  \n  // `colorGetter` it won't get result synchronously. It'll be able to get it via await, but that is not how  \n  // components are typically built.  \n  const component = await mount(<ColorPicker colorGetter={() => 'red'}/>);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You can also specify custom timeout and retry intervals:", "output": "await expect(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  expect(response.status()).toBe(200);  \n}).toPass({  \n  // Probe, wait 1s, probe, wait 2s, probe, wait 10s, probe, wait 10s, probe  \n  // ... Defaults to [100, 250, 500, 1000].  \n  intervals: [1_000, 2_000, 10_000],  \n  timeout: 60_000  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Generate a Playwright test for the following scenario: Create `tests/auth.setup.ts` that will prepare authenticated browser state for all other tests. | tests/auth.setup.ts", "input": "", "output": "import { test as setup, expect } from '@playwright/test';  \nimport path from 'path';  \n  \nconst authFile = path.join(__dirname, '../playwright/.auth/user.json');  \n  \nsetup('authenticate', async ({ page }) => {  \n  // Perform authentication steps. Replace these actions with your own.  \n  await page.goto('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('username');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n  // Wait until the page receives the cookies.  \n  //  \n  // Sometimes login flow sets cookies in the process of several redirects.  \n  // Wait for the final URL to ensure that the cookies are actually set.  \n  await page.waitForURL('https://github.com/');  \n  // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n  await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n  // End of authentication steps.  \n  \n  await page.context().storageState({ path: authFile });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test('gets the json from HAR and checks the new fruit has been added', async ({ page }) => {  \n  // Replay API requests from HAR.  \n  // Either use a matching response from the HAR,  \n  // or abort the request if nothing matches.  \n  await page.routeFromHAR('./hars/fruit.har', {  \n    url: '*/**/api/v1/fruits',  \n    update: false,  \n  });  \n  \n  // Go to the page  \n  await page.goto('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the Playwright fruit is visible  \n  await expect(page.getByText('Playwright', { exact: true })).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "* [page.waitForURL()](/docs/api/class-page#page-wait-for-url) to await navigations to URL\n* [video.delete()](/docs/api/class-video#video-delete) and [video.saveAs()](/docs/api/class-video#video-save-as) to manage screen recording", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Programmatic click\u200b | If you are not interested in testing your app under the real conditions and want to simulate the click by any means possible, you can trigger the [`HTMLElement.click()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click) behavior via simply dispatching a click event on the element with [locator.dispatchEvent()](/docs/api/class-locator#locator-dispatch-event):", "output": "await page.getByRole('button').dispatchEvent('click');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Grant `\"geolocation\"` permissions and set geolocation to a specific area. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Context geolocation  \n    geolocation: { longitude: 12.492507, latitude: 41.889938 },  \n    permissions: ['geolocation'],  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Generate a Playwright test for the following scenario: Forcing the click\u200b | Sometimes, apps use non-trivial logic where hovering the element overlays it with another element that intercepts the click. This behavior is indistinguishable from a bug where element gets covered and the click is dispatched elsewhere. If you know this is taking place, you can bypass the [actionability](/docs/actionability) checks and force the click:", "input": "", "output": "await page.getByRole('button').click({ force: true });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You can constrain an accessibility scan to only run those rules which are \"tagged\" as corresponding to specific WCAG success criteria by using [`AxeBuilder.withTags()`](https://github.com/dequelabs/axe-core-npm/blob/develop/packages/playwright/README.md#axebuilderwithtagstags-stringarray). For example, [Accessibility Insights for Web's Automated Checks](https://accessibilityinsights.io/docs/web/getstarted/fastpass/?referrer=playwright-accessibility-testing-js) only include axe rules that test for violations of WCAG A and AA success criteria; to match that behavior, you would use the tags `wcag2a`, `wcag2aa`, `wcag21a`, and `wcag21aa`. | Note that automated testing cannot detect all types of WCAG violations.", "output": "test('should not have any automatically detectable WCAG A or AA violations', async ({ page }) => {  \n  await page.goto('https://your-site.com/');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])  \n      .analyze();  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport { InputMediaForTest } from './input-media.story.tsx';  \n  \ntest('changes the image', async ({ mount }) => {  \n  let mediaSelected: string | null = null;  \n  \n  const component = await mount(  \n    <InputMediaForTest  \n      onMediaChange={mediaName => {  \n        mediaSelected = mediaName;  \n      }}  \n    />  \n  );  \n  await component  \n    .getByTestId('imageInput')  \n    .setInputFiles('src/assets/logo.png');  \n  \n  await expect(component.getByAltText(/selected image/i)).toBeVisible();  \n  await expect.poll(() => mediaSelected).toBe('logo.png');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.route('**/*.{png,jpg,jpeg}', route => route.abort());  \n  \n// Abort based on the request type  \nawait page.route('**/*', route => {  \n  return route.request().resourceType() === 'image' ? route.abort() : route.continue();  \n});", "output": "await page.route('**/*.{png,jpg,jpeg}', route => route.abort());  \n  \n// Abort based on the request type  \nawait page.route('**/*', route => {  \n  return route.request().resourceType() === 'image' ? route.abort() : route.continue();  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/network", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: You can merge test fixtures from multiple files or modules: | fixtures.ts", "input": "", "output": "import { mergeTests } from '@playwright/test';  \nimport { test as dbTest } from 'database-test-utils';  \nimport { test as a11yTest } from 'a11y-test-utils';  \n  \nexport const test = mergeTests(dbTest, a11yTest);", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test for the following scenario: feature-b.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \nexport default function createTests() {  \n  test.use({ viewport: { width: 500, height: 500 } });  \n  \n  test('feature-b example test', async ({ page }) => {  \n    // ... test goes here  \n  });  \n}", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "await expect(page.getByText('Welcome, John')).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Important: import our fixtures.  \nimport { test, assert } from '../playwright/fixtures';  \n  \ntest('test', async ({ page }) => {  \n  // page is authenticated  \n});", "output": "// Important: import our fixtures.  \nimport { test, expect } from '../playwright/fixtures';  \n  \ntest('test', async ({ page }) => {  \n  // page is authenticated  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/auth", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: playwright.config.ts", "input": "", "output": "import { defineConfig, devices } from '@playwright/test'; // import devices  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n      },  \n    },  \n    {  \n      name: 'Mobile Safari',  \n      use: {  \n        ...devices['iPhone 13'],  \n      },  \n    },  \n  ],  \n});  \n\n\n\nconst { chromium, devices } = require('playwright');  \nconst browser = await chromium.launch();  \n  \nconst iphone13 = devices['iPhone 13'];  \nconst context = await browser.newContext({  \n  ...iphone13,  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const context = await browser.newContext({  \n  recordHar: {  \n    path: 'github.har',  \n    mode: 'minimal',  \n  }  \n});", "output": "const context = await browser.newContext({  \n  recordHar: {  \n    path: 'github.har',  \n    mode: 'minimal',  \n  }  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "component.spec.tsx", "output": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('children', async ({ mount }) => {  \n  const component = await mount(<Component>Child</Component>);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test for the following scenario: However, if the property is [configurable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#configurable), you can still override it using the plain JavaScript:", "input": "", "output": "await page.addInitScript(() => {  \n  Object.defineProperty(Object.getPrototypeOf(navigator), 'cookieEnabled', { value: false });  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/mock-browser-apis"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "test('should not have any automatically detectable WCAG A or AA violations', async ({ page }) => {  \n  await page.goto('https://your-site.com/');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])  \n      .analyze();  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Alternatively, you can record HAR programmatically:", "input": "", "output": "const context = await browser.newContext({  \n  recordHar: { path: 'github.har.zip' }  \n});  \n// ... do stuff ...  \nawait context.close();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/experimental-ct-svelte';  \n  \ntest('slot', async ({ mount }) => {  \n  const component = await mount(Component, { slots: { default: 'Slot' } });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await expect(page).toHaveTitle(/Playwright/);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/writing-tests", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You can convert any synchronous `expect` to an asynchronous polling one using `expect.poll`. | The following method will poll given function until it returns HTTP status 200:", "output": "await expect.poll(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  return response.status();  \n}, {  \n  // Custom expect message for reporting, optional.  \n  message: 'make sure API eventually succeeds',  \n  // Poll for 10 seconds; defaults to 5 seconds. Pass 0 to disable timeout.  \n  timeout: 10000,  \n}).toBe(200);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Overview\u200b | A WebView2 control can be instructed to listen to incoming CDP connections by setting either the `WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS` environment variable with `--remote-debugging-port=9222` or calling [EnsureCoreWebView2Async](https://docs.microsoft.com/en-us/dotnet/api/microsoft.web.webview2.wpf.webview2.ensurecorewebview2async?view=webview2-dotnet-1.0.1343.22) with the `--remote-debugging-port=9222` argument. This will start the WebView2 process with the Chrome DevTools Protocol enabled which allows the automation by Playwright. 9222 is an example port in this case, but any other unused port can be used as well.", "output": "await this.webView.EnsureCoreWebView2Async(await CoreWebView2Environment.CreateAsync(null, null, new CoreWebView2EnvironmentOptions()  \n{  \n  AdditionalBrowserArguments = \"--remote-debugging-port=9222\",  \n})).ConfigureAwait(false);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/webview2"}}
{"instruction": "Generate a Playwright test for the following scenario: JavaScript", "input": "", "output": "import { expect, test, devices } from '@playwright/test';  \n  \ntest.use(devices['iPhone 11']);  \n  \ntest('should be titled', async ({ page, context }) => {  \n  await context.route('**.jpg', route => route.abort());  \n  await page.goto('https://example.com/');  \n  \n  await expect(page).toHaveTitle('Example');  \n});  \n\n\n\nconst { expect, test, devices } = require('@playwright/test');  \n  \ntest.use(devices['iPhone 11']);  \n  \ntest('should be titled', async ({ page, context }) => {  \n  await context.route('**.jpg', route => route.abort());  \n  await page.goto('https://example.com/');  \n  \n  await expect(page).toHaveTitle('Example');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/library"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as base, type Page, type Locator } from '@playwright/test';  \n  \n// Page Object Model for the \"admin\" page.  \n// Here you can add locators and helper methods specific to the admin page.  \nclass AdminPage {  \n  // Page signed in as \"admin\".  \n  page: Page;  \n  \n  // Example locator pointing to \"Welcome, Admin\" greeting.  \n  greeting: Locator;  \n  \n  constructor(page: Page) {  \n    this.page = page;  \n    this.greeting = page.locator('#greeting');  \n  }  \n}  \n  \n// Page Object Model for the \"user\" page.  \n// Here you can add locators and helper methods specific to the user page.  \nclass UserPage {  \n  // Page signed in as \"user\".  \n  page: Page;  \n  \n  // Example locator pointing to \"Welcome, User\" greeting.  \n  greeting: Locator;  \n  \n  constructor(page: Page) {  \n    this.page = page;  \n    this.greeting = page.locator('#greeting');  \n  }  \n}  \n  \n// Declare the types of your fixtures.  \ntype MyFixtures = {  \n  adminPage: AdminPage;  \n  userPage: UserPage;  \n};  \n  \nexport * from '@playwright/test';  \nexport const test = base.extend<MyFixtures>({  \n  adminPage: async ({ browser }, use) => {  \n    const context = await browser.newContext({ storageState: 'playwright/.auth/admin.json' });  \n    const adminPage = new AdminPage(await context.newPage());  \n    await use(adminPage);  \n    await context.close();  \n  },  \n  userPage: async ({ browser }, use) => {  \n    const context = await browser.newContext({ storageState: 'playwright/.auth/user.json' });  \n    const userPage = new UserPage(await context.newPage());  \n    await use(userPage);  \n    await context.close();  \n  },  \n});", "output": "import { test as base, type Page, type Locator } from '@playwright/test';  \n  \n// Page Object Model for the \"admin\" page.  \n// Here you can add locators and helper methods specific to the admin page.  \nclass AdminPage {  \n  // Page signed in as \"admin\".  \n  page: Page;  \n  \n  // Example locator pointing to \"Welcome, Admin\" greeting.  \n  greeting: Locator;  \n  \n  constructor(page: Page) {  \n    this.page = page;  \n    this.greeting = page.locator('#greeting');  \n  }  \n}  \n  \n// Page Object Model for the \"user\" page.  \n// Here you can add locators and helper methods specific to the user page.  \nclass UserPage {  \n  // Page signed in as \"user\".  \n  page: Page;  \n  \n  // Example locator pointing to \"Welcome, User\" greeting.  \n  greeting: Locator;  \n  \n  constructor(page: Page) {  \n    this.page = page;  \n    this.greeting = page.locator('#greeting');  \n  }  \n}  \n  \n// Declare the types of your fixtures.  \ntype MyFixtures = {  \n  adminPage: AdminPage;  \n  userPage: UserPage;  \n};  \n  \nexport * from '@playwright/test';  \nexport const test = base.extend<MyFixtures>({  \n  adminPage: async ({ browser }, use) => {  \n    const context = await browser.newContext({ storageState: 'playwright/.auth/admin.json' });  \n    const adminPage = new AdminPage(await context.newPage());  \n    await use(adminPage);  \n    await context.close();  \n  },  \n  userPage: async ({ browser }, use) => {  \n    const context = await browser.newContext({ storageState: 'playwright/.auth/user.json' });  \n    const userPage = new UserPage(await context.newPage());  \n    await use(userPage);  \n    await context.close();  \n  },  \n});", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/auth", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.locator('text=Log in').click();", "output": "await page.locator('text=Log in').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert(page.getByRole('button')).toHaveAttribute('disabled', '');", "output": "await expect(page.getByRole('button')).toHaveAttribute('disabled', '');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test('this will not work', async ({ mount }) => {  \n  // () => 'red' callback lives in Node. If `ColorPicker` component in the browser calls the parameter function  \n  // `colorGetter` it won't get result synchronously. It'll be able to get it via await, but that is not how  \n  // components are typically built.  \n  const component = await mount(<ColorPicker colorGetter={() => 'red'}/>);  \n});", "output": "test('this will not work', async ({ mount }) => {  \n  // () => 'red' callback lives in Node. If `ColorPicker` component in the browser calls the parameter function  \n  // `colorGetter` it won't get result synchronously. It'll be able to get it via await, but that is not how  \n  // components are typically built.  \n  const component = await mount(<ColorPicker colorGetter={() => 'red'}/>);  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: my-test.ts", "input": "", "output": "import { test as base } from '@playwright/test';  \n  \nexport type TestOptions = {  \n  person: string;  \n};  \n  \nexport const test = base.extend<TestOptions>({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  person: ['John', { option: true }],  \n  \n  // Override default \"page\" fixture.  \n  page: async ({ page, person }, use) => {  \n    await page.goto('/chat');  \n    // We use \"person\" parameter as a \"name\" for the chat room.  \n    await page.getByLabel('User Name').fill(person);  \n    await page.getByText('Enter chat room').click();  \n    // Each test will get a \"page\" that already has the person name.  \n    await use(page);  \n  },  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  // This will navigate to http://127.0.0.1:3000/login  \n  await page.navigate('./login');  \n});", "output": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  // This will navigate to http://127.0.0.1:3000/login  \n  await page.goto('./login');  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-webserver", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Here is what a typical component test looks like: | App.spec.tsx", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport App from './App';  \n  \n// Let's test component in a dark scheme!  \ntest.use({ colorScheme: 'dark' });  \n  \ntest('should render', async ({ mount }) => {  \n  const component = await mount(<App></App>);  \n  \n  // As with any Playwright test, assert locator text.  \n  await expect(component).toContainText('React');  \n  // Or do a screenshot \ud83d\ude80  \n  await expect(component).toHaveScreenshot();  \n  // Or use any Playwright method  \n  await component.click();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend<{}, { forEachWorker: void }>({  \n  forEachWorker: [async ({}, use) => {  \n    // This code runs before all the tests in the worker process.  \n    console.log(`Starting test worker ${test.info().workerIndex}`);  \n    await use();  \n    // This code runs after all the tests in the worker process.  \n    console.log(`Stopping test worker ${test.info().workerIndex}`);  \n  }, { scope: 'worker', auto: true }],  // automatically starts for every worker.  \n});", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend<{}, { forEachWorker: void }>({  \n  forEachWorker: [async ({}, use) => {  \n    // This code runs before all the tests in the worker process.  \n    console.log(`Starting test worker ${test.info().workerIndex}`);  \n    await use();  \n    // This code runs after all the tests in the worker process.  \n    console.log(`Stopping test worker ${test.info().workerIndex}`);  \n  }, { scope: 'worker', auto: true }],  // automatically starts for every worker.  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: If you want to have hooks for each test, you can put them inside a `describe()` \\- so they are executed for each iteration / each individual test: | example.spec.ts", "input": "", "output": "[  \n  { name: 'Alice', expected: 'Hello, Alice!' },  \n  { name: 'Bob', expected: 'Hello, Bob!' },  \n  { name: 'Charlie', expected: 'Hello, Charlie!' },  \n].forEach(({ name, expected }) => {  \n  test.describe(() => {  \n    test.beforeEach(async ({ page }) => {  \n      await page.goto(`https://example.com/greet?name=${name}`);  \n    });  \n    test(`testing with ${expected}`, async ({ page }) => {  \n      await expect(page.getByRole('heading')).toHaveText(expected);  \n    });  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parameterize"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "todo.spec.ts", "output": "const { test } = require('@playwright/test');  \nconst { TodoPage } = require('./todo-page');  \n  \ntest.describe('todo tests', () => {  \n  let todoPage;  \n  \n  test.beforeEach(async ({ page }) => {  \n    todoPage = new TodoPage(page);  \n    await todoPage.goto();  \n    await todoPage.addToDo('item1');  \n    await todoPage.addToDo('item2');  \n  });  \n  \n  test.afterEach(async () => {  \n    await todoPage.removeAll();  \n  });  \n  \n  test('should add an item', async () => {  \n    await todoPage.addToDo('my item');  \n    // ...  \n  });  \n  \n  test('should remove an item', async () => {  \n    await todoPage.remove('item1');  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as base, chromium, type BrowserContext } from '@playwright/test';  \nimport path from 'path';  \n  \nexport const test = base.extend<{  \n  context: BrowserContext;  \n  extensionId: string;  \n}>({  \n  context: async ({ }, use) => {  \n    const pathToExtension = path.join(__dirname, 'my-extension');  \n    const context = await chromium.launchPersistentContext('', {  \n      headless: false,  \n      args: [  \n        `--disable-extensions-except=${pathToExtension}`,  \n        `--load-extension=${pathToExtension}`,  \n      ],  \n    });  \n    await use(context);  \n    await context.close();  \n  },  \n  extensionId: async ({ context }, use) => {  \n    /*  \n    // for manifest v2:  \n    let [background] = context.backgroundPages()  \n    if (!background)  \n      background = await context.waitForEvent('backgroundpage')  \n    */  \n  \n    // for manifest v3:  \n    let [background] = context.serviceWorkers();  \n    if (!background)  \n      background = await context.waitForEvent('serviceworker');  \n  \n    const extensionId = background.url().split('/')[2];  \n    await use(extensionId);  \n  },  \n});  \nexport const assert = test.assert;", "output": "import { test as base, chromium, type BrowserContext } from '@playwright/test';  \nimport path from 'path';  \n  \nexport const test = base.extend<{  \n  context: BrowserContext;  \n  extensionId: string;  \n}>({  \n  context: async ({ }, use) => {  \n    const pathToExtension = path.join(__dirname, 'my-extension');  \n    const context = await chromium.launchPersistentContext('', {  \n      headless: false,  \n      args: [  \n        `--disable-extensions-except=${pathToExtension}`,  \n        `--load-extension=${pathToExtension}`,  \n      ],  \n    });  \n    await use(context);  \n    await context.close();  \n  },  \n  extensionId: async ({ context }, use) => {  \n    /*  \n    // for manifest v2:  \n    let [background] = context.backgroundPages()  \n    if (!background)  \n      background = await context.waitForEvent('backgroundpage')  \n    */  \n  \n    // for manifest v3:  \n    let [background] = context.serviceWorkers();  \n    if (!background)  \n      background = await context.waitForEvent('serviceworker');  \n  \n    const extensionId = background.url().split('/')[2];  \n    await use(extensionId);  \n  },  \n});  \nexport const expect = test.expect;", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/chrome-extensions", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const saveButton = page.getByRole('button', { name: 'Save' });  \n// ...  \nconst dialog = page.getByTestId('settings-dialog');  \nawait dialog.locator(saveButton).click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  viewport: { width: 1600, height: 1200 },  \n});  \n  \ntest('my test', async ({ page }) => {  \n  // ...  \n});  \n\n\n\n// Create context with given viewport  \nconst context = await browser.newContext({  \n  viewport: { width: 1280, height: 1024 }  \n});  \n  \n// Resize viewport for individual page  \nawait page.setViewportSize({ width: 1600, height: 1200 });  \n  \n// Emulate high-DPI  \nconst context = await browser.newContext({  \n  viewport: { width: 2560, height: 1440 },  \n  deviceScaleFactor: 2,  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: src/pinia.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/experimental-ct-vue';  \nimport type { HooksConfig } from '../playwright';  \nimport Store from './Store.vue';  \n  \ntest('override initialState ', async ({ mount }) => {  \n  const component = await mount<HooksConfig>(Store, {  \n    hooksConfig: {  \n      store: { name: 'override initialState' }  \n    }  \n  });  \n  await expect(component).toContainText('override initialState');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Grants specified permissions to the browser context.  \n    permissions: ['notifications'],  \n  },  \n});  \n\n\n\nconst context = await browser.newContext({  \n  permissions: ['notifications'],  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Grants specified permissions to the browser context.  \n    permissions: ['notifications'],  \n  },  \n});  \n\n\n\nconst context = await browser.newContext({  \n  permissions: ['notifications'],  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/emulation", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \nimport { username, password } from '@myhelper/credentials';  \n  \ntest('example', async ({ page }) => {  \n  await page.getByLabel('User Name').fill(username);  \n  await page.getByLabel('Password').fill(password);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-typescript", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const browser = await chromium.launch();  \nconst context = await browser.newContext();  \n  \n// Start tracing before creating / navigating a page.  \nawait context.tracing.start({ screenshots: true, snapshots: true });  \n  \nconst page = await context.newPage();  \nawait page.navigate('https://playwright.dev');  \n  \n// Stop tracing and export it into a zip archive.  \nawait context.tracing.stop({ path: 'trace.zip' });", "output": "const browser = await chromium.launch();  \nconst context = await browser.newContext();  \n  \n// Start tracing before creating / navigating a page.  \nawait context.tracing.start({ screenshots: true, snapshots: true });  \n  \nconst page = await context.newPage();  \nawait page.goto('https://playwright.dev');  \n  \n// Stop tracing and export it into a zip archive.  \nawait context.tracing.stop({ path: 'trace.zip' });", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('menu', async ({ page }) => {  \n  // Your test that depends on the database  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: You can use various [test hooks](/docs/api/class-test) such as `test.describe` to declare a group of tests and `test.beforeEach` and `test.afterEach` which are executed before/after each test. Other hooks include the `test.beforeAll` and `test.afterAll` which are executed once per worker before/after all tests. | tests/example.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('navigation', () => {  \n  test.beforeEach(async ({ page }) => {  \n    // Go to the starting url before each test.  \n    await page.goto('https://playwright.dev/');  \n  });  \n  \n  test('main navigation', async ({ page }) => {  \n    // Assertions use the expect API.  \n    await expect(page).toHaveURL('https://playwright.dev/');  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/writing-tests"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// select the first button among all buttons  \nawait button.click('button >> nth=0');  \n// or if you are using locators, you can use first(), nth() and last()  \nawait page.locator('button').first().click();  \n  \n// click a visible button  \nawait button.click('button >> visible=true');", "output": "// select the first button among all buttons  \nawait button.click('button >> nth=0');  \n// or if you are using locators, you can use first(), nth() and last()  \nawait page.locator('button').first().click();  \n  \n// click a visible button  \nawait button.click('button >> visible=true');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Maximum time each action such as `click()` can take. Defaults to 0 (no limit).  \n    actionTimeout: 0,  \n  \n    // Name of the browser that runs tests. For example `chromium`, `firefox`, `webkit`.  \n    browserName: 'chromium',  \n  \n    // Toggles bypassing Content-Security-Policy.  \n    bypassCSP: true,  \n  \n    // Channel to use, for example \"chrome\", \"chrome-beta\", \"msedge\", \"msedge-beta\".  \n    channel: 'chrome',  \n  \n    // Run browser in headless mode.  \n    headless: false,  \n  \n    // Change the default data-testid attribute.  \n    testIdAttribute: 'pw-test-id',  \n  },  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Maximum time each action such as `click()` can take. Defaults to 0 (no limit).  \n    actionTimeout: 0,  \n  \n    // Name of the browser that runs tests. For example `chromium`, `firefox`, `webkit`.  \n    browserName: 'chromium',  \n  \n    // Toggles bypassing Content-Security-Policy.  \n    bypassCSP: true,  \n  \n    // Channel to use, for example \"chrome\", \"chrome-beta\", \"msedge\", \"msedge-beta\".  \n    channel: 'chrome',  \n  \n    // Run browser in headless mode.  \n    headless: false,  \n  \n    // Change the default data-testid attribute.  \n    testIdAttribute: 'pw-test-id',  \n  },  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-use-options", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  colorScheme: 'dark' // or 'light'  \n});  \n  \ntest('my test with dark mode', async ({ page }) => {  \n  // ...  \n});  \n\n\n\n// Create context with dark mode  \nconst context = await browser.newContext({  \n  colorScheme: 'dark' // or 'light'  \n});  \n  \n// Create page with dark mode  \nconst page = await browser.newPage({  \n  colorScheme: 'dark' // or 'light'  \n});  \n  \n// Change color scheme for the page  \nawait page.emulateMedia({ colorScheme: 'dark' });  \n  \n// Change media for page  \nawait page.emulateMedia({ media: 'print' });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test('should not have any accessibility violations outside of elements with known issues', async ({  \n  page,  \n}) => {  \n  await page.navigate('https://your-site.com/page-with-known-issues');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .exclude('#element-with-known-issue')  \n      .analyze();  \n  \n  assert(accessibilityScanResults.violations).toEqual([]);  \n});", "output": "test('should not have any accessibility violations outside of elements with known issues', async ({  \n  page,  \n}) => {  \n  await page.goto('https://your-site.com/page-with-known-issues');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .exclude('#element-with-known-issue')  \n      .analyze();  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: To record a HAR file we use [page.routeFromHAR()](/docs/api/class-page#page-route-from-har) or [browserContext.routeFromHAR()](/docs/api/class-browsercontext#browser-context-route-from-har) method. This method takes in the path to the HAR file and an optional object of options. The options object can contain the URL so that only requests with the URL matching the specified glob pattern will be served from the HAR File. If not specified, all requests will be served from the HAR file. | Setting `update` option to true will create or update the HAR file with the actual network information instead of serving the requests from the HAR file. Use it when creating a test to populate the HAR with real data.", "input": "", "output": "test('records or updates the HAR file', async ({ page }) => {  \n  // Get the response from the HAR file  \n  await page.routeFromHAR('./hars/fruit.har', {  \n    url: '*/**/api/v1/fruits',  \n    update: true,  \n  });  \n  \n  // Go to the page  \n  await page.goto('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the fruit is visible  \n  await expect(page.getByText('Strawberry')).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Most of the time, you should input text with [locator.fill()](/docs/api/class-locator#locator-fill). See the Text input section above. You only need to type characters if there is special keyboard handling on the page. | Type into the field character by character, as if it was a user with a real keyboard with [locator.pressSequentially()](/docs/api/class-locator#locator-press-sequentially).", "output": "// Press keys one by one  \nawait page.locator('#area').pressSequentially('Hello World!');", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "If you are uploading attachments from data folder to other location, you can use `attachmentsBaseURL` option to let html report where to look for them. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['html', { attachmentsBaseURL: 'https://external-storage.com/' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Run tests on different browsers\u200b | Playwright can run your tests in multiple browsers and configurations by setting up **projects** in the config. You can also add [different options](/docs/test-configuration) for each project.", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    /* Test against desktop browsers */  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n    },  \n    {  \n      name: 'firefox',  \n      use: { ...devices['Desktop Firefox'] },  \n    },  \n    {  \n      name: 'webkit',  \n      use: { ...devices['Desktop Safari'] },  \n    },  \n    /* Test against mobile viewports. */  \n    {  \n      name: 'Mobile Chrome',  \n      use: { ...devices['Pixel 5'] },  \n    },  \n    {  \n      name: 'Mobile Safari',  \n      use: { ...devices['iPhone 12'] },  \n    },  \n    /* Test against branded browsers. */  \n    {  \n      name: 'Google Chrome',  \n      use: { ...devices['Desktop Chrome'], channel: 'chrome' }, // or 'chrome-beta'  \n    },  \n    {  \n      name: 'Microsoft Edge',  \n      use: { ...devices['Desktop Edge'], channel: 'msedge' }, // or 'msedge-dev'  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/browsers"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "playwright.config.ts", "output": "import { defineConfig, devices } from '@playwright/test'; // import devices  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n      },  \n    },  \n    {  \n      name: 'Mobile Safari',  \n      use: {  \n        ...devices['iPhone 13'],  \n      },  \n    },  \n  ],  \n});  \n\n\n\nconst { chromium, devices } = require('playwright');  \nconst browser = await chromium.launch();  \n  \nconst iphone13 = devices['iPhone 13'];  \nconst context = await browser.newContext({  \n  ...iphone13,  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Generate a Playwright test for the following scenario: Here is an example fixture that automatically attaches debug logs when the test fails, so we can later review the logs in the reporter. Note how it uses [TestInfo](/docs/api/class-testinfo \"TestInfo\") object that is available in each test/fixture to retrieve metadata about the test being run. | my-test.ts", "input": "", "output": "import * as debug from 'debug';  \nimport * as fs from 'fs';  \nimport { test as base } from '@playwright/test';  \n  \nexport const test = base.extend<{ saveLogs: void }>({  \n  saveLogs: [async ({}, use, testInfo) => {  \n    // Collecting logs during the test.  \n    const logs = [];  \n    debug.log = (...args) => logs.push(args.map(String).join(''));  \n    debug.enable('myserver');  \n  \n    await use();  \n  \n    // After the test we can check whether the test passed or failed.  \n    if (testInfo.status !== testInfo.expectedStatus) {  \n      // outputPath() API guarantees a unique file name.  \n      const logFile = testInfo.outputPath('logs.txt');  \n      await fs.promises.writeFile(logFile, logs.join('\\n'), 'utf8');  \n      testInfo.attachments.push({ name: 'logs', contentType: 'text/plain', path: logFile });  \n    }  \n  }, { auto: true }],  \n});  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Make a few checks that will not stop the test when failed...  \nawait expect.soft(page.locator('#status')).toHaveText('Success');  \nawait expect.soft(page.locator('#eta')).toHaveText('1 day');  \n  \n// ... and continue the test to check more things.  \nawait page.locator('#next-page').click();  \nawait expect.soft(page.locator('#title')).toHaveText('Make another order');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Checkboxes and radio buttons\u200b | Using [locator.setChecked()](/docs/api/class-locator#locator-set-checked) is the easiest way to check and uncheck a checkbox or a radio button. This method can be used with `input[type=checkbox]`, `input[type=radio]` and `[role=checkbox]` elements.", "input": "", "output": "// Check the checkbox  \nawait page.getByLabel('I agree to the terms above').check();  \n  \n// Assert the checked state  \nexpect(page.getByLabel('Subscribe to newsletter')).toBeChecked();  \n  \n// Select the radio button  \nawait page.getByLabel('XL').check();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/input"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "await page.locator('text=Log in').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('test login page', {  \n  annotation: {  \n    type: 'issue',  \n    description: 'https://github.com/microsoft/playwright/issues/23180',  \n  },  \n}, async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  // page is authenticated  \n});", "output": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  // page is authenticated  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/auth", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.locator('#nav-bar :text(\"Home\")').click();", "output": "await page.locator('#nav-bar :text(\"Home\")').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Playwright 1.17 introduces [frame locators](/docs/api/class-framelocator) \\- a locator to the iframe on the page. Frame locators capture the logic sufficient to retrieve the `iframe` and then locate elements in that iframe. Frame locators are strict by default, will wait for `iframe` to appear and can be used in Web-First assertions. | Frame locators can be created with either [page.frameLocator()](/docs/api/class-page#page-frame-locator) or [locator.frameLocator()](/docs/api/class-locator#locator-frame-locator) method.", "input": "", "output": "const locator = page.frameLocator('#my-iframe').locator('text=Submit');  \nawait locator.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the form_interaction pattern.", "input": "You can fill the input after locating it by the placeholder text:", "output": "await page  \n    .getByPlaceholder('name@example.com')  \n    .fill('playwright@microsoft.com');", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \nconst REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \n// Request context is reused by all tests in the file.  \nlet apiContext;  \n  \ntest.beforeAll(async ({ playwright }) => {  \n  apiContext = await playwright.request.newContext({  \n    // All requests we send go to this API endpoint.  \n    baseURL: 'https://api.github.com',  \n    extraHTTPHeaders: {  \n      // We set this header per GitHub guidelines.  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add authorization token to all requests.  \n      // Assuming personal access token available in the environment.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    },  \n  });  \n});  \n  \ntest.afterAll(async ({ }) => {  \n  // Dispose all responses.  \n  await apiContext.dispose();  \n});  \n  \ntest('last created issue should be on the server', async ({ page }) => {  \n  await page.goto(`https://github.com/${USER}/${REPO}/issues`);  \n  await page.getByText('New Issue').click();  \n  await page.getByRole('textbox', { name: 'Title' }).fill('Bug report 1');  \n  await page.getByRole('textbox', { name: 'Comment body' }).fill('Bug description');  \n  await page.getByText('Submit new issue').click();  \n  const issueId = page.url().substr(page.url().lastIndexOf('/'));  \n  \n  const newIssue = await apiContext.get(  \n      `https://api.github.com/repos/${USER}/${REPO}/issues/${issueId}`  \n  );  \n  expect(newIssue.ok()).toBeTruthy();  \n  expect(newIssue.json()).toEqual(expect.objectContaining({  \n    title: 'Bug report 1'  \n  }));  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/api-testing", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Setup the handler.  \nawait page.addLocatorHandler(  \n    page.getByRole('heading', { name: 'Hej! You are in control of your cookies.' }),  \n    async () => {  \n      await page.getByRole('button', { name: 'Accept all' }).click();  \n    });  \n// Write the test as usual.  \nawait page.navigate('https://www.ikea.com/');  \nawait page.getByRole('link', { name: 'Collection of blue and white' }).click();  \nawait assert(page.getByRole('heading', { name: 'Light and easy' })).toBeVisible();", "output": "// Setup the handler.  \nawait page.addLocatorHandler(  \n    page.getByRole('heading', { name: 'Hej! You are in control of your cookies.' }),  \n    async () => {  \n      await page.getByRole('button', { name: 'Accept all' }).click();  \n    });  \n// Write the test as usual.  \nawait page.goto('https://www.ikea.com/');  \nawait page.getByRole('link', { name: 'Collection of blue and white' }).click();  \nawait expect(page.getByRole('heading', { name: 'Light and easy' })).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Alternatively, you may want to connect to the actual server, but intercept messages in-between and modify or block them. Here is an example that modifies some of the messages sent by the page to the server, and leaves the rest unmodified.", "output": "await page.routeWebSocket('wss://example.com/ws', ws => {  \n  const server = ws.connectToServer();  \n  ws.onMessage(message => {  \n    if (message === 'request')  \n      server.send('request2');  \n    else  \n      server.send(message);  \n  });  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/mock"}}
{"instruction": "Generate a Playwright test for the following scenario: Test Runner\u200b | Configure retries and test timeout for a file or a test with [test.describe.configure()](/docs/api/class-test#test-describe-configure).", "input": "", "output": "// Each test in the file will be retried twice and have a timeout of 20 seconds.  \ntest.describe.configure({ retries: 2, timeout: 20_000 });  \ntest('runs first', async ({ page }) => {});  \ntest('runs second', async ({ page }) => {});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Navigation\u200b | Most of the tests will start with navigating page to the URL. After that, test will be able to interact with the page elements.", "output": "await page.goto('https://playwright.dev/');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/writing-tests"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "When [page.close()](/docs/api/class-page#page-close) is invoked with the truthy [runBeforeUnload](/docs/api/class-page#page-close-option-run-before-unload) value, the page runs its unload handlers. This is the only case when [page.close()](/docs/api/class-page#page-close) does not wait for the page to actually close, because it might be that the page stays open in the end of the operation. | You can register a dialog handler to handle the `beforeunload` dialog yourself:", "output": "page.on('dialog', async dialog => {  \n  assert(dialog.type() === 'beforeunload');  \n  await dialog.dismiss();  \n});  \nawait page.close({ runBeforeUnload: true });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/dialogs"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const locator = page  \n    .frameLocator('#my-frame')  \n    .getByRole('button', { name: 'Sign in' });  \n  \nawait locator.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const context = await browser.newContext({  \n  recordHar: {  \n    path: 'github.har.zip',  \n  }  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// Import test with our new fixtures.  \nimport { test, assert } from '../playwright/fixtures';  \n  \n// Use adminPage and userPage fixtures in the test.  \ntest('admin and user', async ({ adminPage, userPage }) => {  \n  // ... interact with both adminPage and userPage ...  \n  await assert(adminPage.greeting).toHaveText('Welcome, Admin');  \n  await assert(userPage.greeting).toHaveText('Welcome, User');  \n});", "output": "// Import test with our new fixtures.  \nimport { test, expect } from '../playwright/fixtures';  \n  \n// Use adminPage and userPage fixtures in the test.  \ntest('admin and user', async ({ adminPage, userPage }) => {  \n  // ... interact with both adminPage and userPage ...  \n  await expect(adminPage.greeting).toHaveText('Welcome, Admin');  \n  await expect(userPage.greeting).toHaveText('Welcome, User');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/auth", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Emulate the network being offline. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    offline: true  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "We recommend the modern [text locator](/docs/locators#get-by-text) instead. | Legacy text locator matches elements that contain passed text.", "output": "await page.locator('text=Log in').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test for the following scenario: Playwright Test v1.19 now supports _soft assertions_. Failed soft assertions | **do not** terminate test execution, but mark the test as failed.", "input": "", "output": "// Make a few checks that will not stop the test when failed...  \nawait expect.soft(page.locator('#status')).toHaveText('Success');  \nawait expect.soft(page.locator('#eta')).toHaveText('1 day');  \n  \n// ... and continue the test to check more things.  \nawait page.locator('#next-page').click();  \nawait expect.soft(page.locator('#title')).toHaveText('Make another order');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Concise 'dot' for CI, default 'list' when running locally  \n  reporter: process.env.CI ? 'dot' : 'list',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Test Runner\u200b | [test.step()](/docs/api/class-test#test-step) now returns the value of the step function:", "output": "test('should work', async ({ page }) => {  \n  const pageTitle = await test.step('get title', async () => {  \n    await page.goto('https://playwright.dev');  \n    return await page.title();  \n  });  \n  console.log(pageTitle);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.use({  \n  geolocation: { longitude: 41.890221, latitude: 12.492348 },  \n  permissions: ['geolocation'],  \n});  \n  \ntest('my test with geolocation', async ({ page, context }) => {  \n  // overwrite the location for this test  \n  await context.setGeolocation({ longitude: 48.858455, latitude: 2.294474 });  \n});  \n\n\n\nawait context.setGeolocation({ longitude: 48.858455, latitude: 2.294474 });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/emulation", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: app.spec.ts", "input": "", "output": "import { test, expect } from '@playwright/experimental-ct-vue';  \nimport App from './App.vue';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(App);  \n  await expect(component).toContainText('Learn Vue');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { expect as baseExpect } from '@playwright/test';  \nexport const expect = baseExpect.extend({  \n  async toHaveAmount(locator: Locator, expected: number, options?: { timeout?: number }) {  \n    // ... see documentation for how to write matchers.  \n  },  \n});  \n  \ntest('pass', async ({ page }) => {  \n  await expect(page.getByTestId('cart')).toHaveAmount(5);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Legacy text locator has a few variations: | `text=Log in` \\- default matching is case-insensitive, trims whitespace and searches for a substring. For example, `text=Log` matches `<button>Log in</button>`.", "output": "await page.locator('text=Log in').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Here is an example of excluding one element from being scanned in one specific test:", "output": "test('should not have any accessibility violations outside of elements with known issues', async ({  \n  page,  \n}) => {  \n  await page.goto('https://your-site.com/page-with-known-issues');  \n  \n  const accessibilityScanResults = await new AxeBuilder({ page })  \n      .exclude('#element-with-known-issue')  \n      .analyze();  \n  \n  expect(accessibilityScanResults.violations).toEqual([]);  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.locator('x-details', { hasText: 'Details' }).click();  \n\n\n\n<x-details role=button aria-expanded=true aria-controls=inner-details>  \n  <div>Title</div>  \n  #shadow-root  \n    <div id=inner-details>Details</div>  \n</x-details>", "output": "await page.locator('x-details', { hasText: 'Details' }).click();  \n\n\n\n<x-details role=button aria-expanded=true aria-controls=inner-details>  \n  <div>Title</div>  \n  #shadow-root  \n    <div id=inner-details>Details</div>  \n</x-details>", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// \ud83d\udc4e  \nexpect(await page.getByText('welcome').isVisible()).toBe(true);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/best-practices", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Hide implementation details: box test steps\u200b | You can mark a [test.step()](/docs/api/class-test#test-step) as \"boxed\" so that errors inside it point to the step call site.", "output": "async function login(page) {  \n  await test.step('login', async () => {  \n    // ...  \n  }, { box: true });  // Note the \"box\" option here.  \n}  \n\n\n\nError: Timed out 5000ms waiting for expect(locator).toBeVisible()  \n  ... error details omitted ...  \n  \n  14 |   await page.goto('https://github.com/login');  \n> 15 |   await login(page);  \n     |         ^  \n  16 | });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    proxy: {  \n      server: 'http://myproxy.com:3128',  \n      username: 'usr',  \n      password: 'pwd'  \n    }  \n  }  \n});  \n\n\n\nconst browser = await chromium.launch({  \n  proxy: {  \n    server: 'http://myproxy.com:3128',  \n    username: 'usr',  \n    password: 'pwd'  \n  }  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/network", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: `#nav-bar :text(\"Home\")` \\- the `:text()` pseudo-class matches the smallest element containing specified text. Matching is case-insensitive, trims whitespace and searches for a substring. | For example, this will find an element with text \"Home\" somewhere inside the `#nav-bar` element:", "input": "", "output": "await page.locator('#nav-bar :text(\"Home\")').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test for the following scenario: Playwright also includes web-specific [async matchers](/docs/api/class-locatorassertions) that will wait until the expected condition is met. Consider the following example:", "input": "", "output": "await expect(page.getByTestId('status')).toHaveText('Submitted');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Generate a Playwright test for the following scenario: \ud83d\udd75\ufe0f Anonymous Describe\u200b | It is now possible to call [test.describe()](/docs/api/class-test#test-describe) to create suites without a title. This is useful for giving a group of tests a common option with [test.use()](/docs/api/class-test#test-use).", "input": "", "output": "test.describe(() => {  \n  test.use({ colorScheme: 'dark' });  \n  \n  test('one', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('two', async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "// Make a few checks that will not stop the test when failed...  \nawait expect.soft(page.getByTestId('status')).toHaveText('Success');  \nawait expect.soft(page.getByTestId('eta')).toHaveText('1 day');  \n  \n// ... and continue the test to check more things.  \nawait page.getByRole('link', { name: 'next page' }).click();  \nawait expect.soft(page.getByRole('heading', { name: 'Make another order' })).toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const base = require('@playwright/test');  \n  \nexports.test = base.test.extend({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  person: ['John', { option: true }],  \n  \n  // Override default \"page\" fixture.  \n  page: async ({ page, person }, use) => {  \n    await page.navigate('/chat');  \n    // We use \"person\" parameter as a \"name\" for the chat room.  \n    await page.getByLabel('User Name').fill(person);  \n    await page.getByText('Enter chat room').click();  \n    // Each test will get a \"page\" that already has the person name.  \n    await use(page);  \n  },  \n});", "output": "const base = require('@playwright/test');  \n  \nexports.test = base.test.extend({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  person: ['John', { option: true }],  \n  \n  // Override default \"page\" fixture.  \n  page: async ({ page, person }, use) => {  \n    await page.goto('/chat');  \n    // We use \"person\" parameter as a \"name\" for the chat room.  \n    await page.getByLabel('User Name').fill(person);  \n    await page.getByText('Enter chat room').click();  \n    // Each test will get a \"page\" that already has the person name.  \n    await use(page);  \n  },  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-parameterize", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the form_interaction pattern.", "input": "A [Page](/docs/api/class-page \"Page\") can have one or more [Frame](/docs/api/class-frame \"Frame\") objects attached to it. Each page has a main frame and page-level interactions (like `click`) are assumed to operate in the main frame. | A page can have additional frames attached with the `iframe` HTML tag. These frames can be accessed for interactions inside the frame.", "output": "// Locate element inside frame  \nconst username = await page.frameLocator('.frame-class').getByLabel('User Name');  \nawait username.fill('John');", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/frames"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "You can click on the image after locating it by the text alternative:", "output": "await page.getByAltText('playwright logo').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Generate a Playwright test for the following scenario: You can use different reporters locally and on CI. For example, using concise `'dot'` reporter avoids too much output. This is the default on CI. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Concise 'dot' for CI, default 'list' when running locally  \n  reporter: process.env.CI ? 'dot' : 'list',  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-reporters"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as teardown } from '@playwright/test';  \n  \nteardown('delete database', async ({ }) => {  \n  console.log('deleting test database...');  \n  // Delete the database  \n});", "output": "import { test as teardown } from '@playwright/test';  \n  \nteardown('delete database', async ({ }) => {  \n  console.log('deleting test database...');  \n  // Delete the database  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the page_object pattern.", "input": "support for **async predicates** across the API in methods such as [page.waitForRequest()](/docs/api/class-page#page-wait-for-request) and others | new **emulation devices** : Galaxy S8, Galaxy S9+, Galaxy Tab S4, Pixel 3, Pixel 4 | new methods:", "output": "* [page.waitForURL()](/docs/api/class-page#page-wait-for-url) to await navigations to URL\n* [video.delete()](/docs/api/class-video#video-delete) and [video.saveAs()](/docs/api/class-video#video-save-as) to manage screen recording", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "In the configuration file: | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Limit the number of workers on CI, use default locally  \n  workers: process.env.CI ? 2 : undefined,  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Generate a Playwright test for the following scenario: Then test the component via testing the story: | input-media.spec.tsx", "input": "", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport { InputMediaForTest } from './input-media.story.tsx';  \n  \ntest('changes the image', async ({ mount }) => {  \n  let mediaSelected: string | null = null;  \n  \n  const component = await mount(  \n    <InputMediaForTest  \n      onMediaChange={mediaName => {  \n        mediaSelected = mediaName;  \n      }}  \n    />  \n  );  \n  await component  \n    .getByTestId('imageInput')  \n    .setInputFiles('src/assets/logo.png');  \n  \n  await expect(component.getByAltText(/selected image/i)).toBeVisible();  \n  await expect.poll(() => mediaSelected).toBe('logo.png');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('test login page', {  \n  annotation: {  \n    type: 'issue',  \n    description: 'https://github.com/microsoft/playwright/issues/23180',  \n  },  \n}, async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: For example, you can run a group of tests just in Chromium by passing a callback. | example.spec.ts", "input": "", "output": "test.describe('chromium only', () => {  \n  test.skip(({ browserName }) => browserName !== 'chromium', 'Chromium only!');  \n  \n  test.beforeAll(async () => {  \n    // This hook is only run in Chromium.  \n  });  \n  \n  test('test 1', async ({ page }) => {  \n    // This test is only run in Chromium.  \n  });  \n  \n  test('test 2', async ({ page }) => {  \n    // This test is only run in Chromium.  \n  });  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-annotations"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as base } from '@playwright/test';  \nimport fs from 'fs';  \nimport os from 'os';  \nimport path from 'path';  \nimport childProcess from 'child_process';  \n  \nconst EXECUTABLE_PATH = path.join(  \n    __dirname,  \n    '../../webview2-app/bin/Debug/net8.0-windows/webview2.exe',  \n);  \n  \nexport const test = base.extend({  \n  browser: async ({ playwright }, use, testInfo) => {  \n    const cdpPort = 10000 + testInfo.workerIndex;  \n    // Make sure that the executable exists and is executable  \n    fs.accessSync(EXECUTABLE_PATH, fs.constants.X_OK);  \n    const userDataDir = path.join(  \n        fs.realpathSync.native(os.tmpdir()),  \n        `playwright-webview2-tests/user-data-dir-${testInfo.workerIndex}`,  \n    );  \n    const webView2Process = childProcess.spawn(EXECUTABLE_PATH, [], {  \n      shell: true,  \n      env: {  \n        ...process.env,  \n        WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS: `--remote-debugging-port=${cdpPort}`,  \n        WEBVIEW2_USER_DATA_FOLDER: userDataDir,  \n      }  \n    });  \n    await new Promise<void>(resolve => webView2Process.stdout.on('data', data => {  \n      if (data.toString().includes('WebView2 initialized'))  \n        resolve();  \n    }));  \n    const browser = await playwright.chromium.connectOverCDP(`http://127.0.0.1:${cdpPort}`);  \n    await use(browser);  \n    await browser.close();  \n    childProcess.execSync(`taskkill /pid ${webView2Process.pid} /T /F`);  \n    fs.rmdirSync(userDataDir, { recursive: true });  \n  },  \n  context: async ({ browser }, use) => {  \n    const context = browser.contexts()[0];  \n    await use(context);  \n  },  \n  page: async ({ context }, use) => {  \n    const page = context.pages()[0];  \n    await use(page);  \n  },  \n});  \n  \nexport { assert } from '@playwright/test';", "output": "import { test as base } from '@playwright/test';  \nimport fs from 'fs';  \nimport os from 'os';  \nimport path from 'path';  \nimport childProcess from 'child_process';  \n  \nconst EXECUTABLE_PATH = path.join(  \n    __dirname,  \n    '../../webview2-app/bin/Debug/net8.0-windows/webview2.exe',  \n);  \n  \nexport const test = base.extend({  \n  browser: async ({ playwright }, use, testInfo) => {  \n    const cdpPort = 10000 + testInfo.workerIndex;  \n    // Make sure that the executable exists and is executable  \n    fs.accessSync(EXECUTABLE_PATH, fs.constants.X_OK);  \n    const userDataDir = path.join(  \n        fs.realpathSync.native(os.tmpdir()),  \n        `playwright-webview2-tests/user-data-dir-${testInfo.workerIndex}`,  \n    );  \n    const webView2Process = childProcess.spawn(EXECUTABLE_PATH, [], {  \n      shell: true,  \n      env: {  \n        ...process.env,  \n        WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS: `--remote-debugging-port=${cdpPort}`,  \n        WEBVIEW2_USER_DATA_FOLDER: userDataDir,  \n      }  \n    });  \n    await new Promise<void>(resolve => webView2Process.stdout.on('data', data => {  \n      if (data.toString().includes('WebView2 initialized'))  \n        resolve();  \n    }));  \n    const browser = await playwright.chromium.connectOverCDP(`http://127.0.0.1:${cdpPort}`);  \n    await use(browser);  \n    await browser.close();  \n    childProcess.execSync(`taskkill /pid ${webView2Process.pid} /T /F`);  \n    fs.rmdirSync(userDataDir, { recursive: true });  \n  },  \n  context: async ({ browser }, use) => {  \n    const context = browser.contexts()[0];  \n    await use(context);  \n  },  \n  page: async ({ context }, use) => {  \n    const page = context.pages()[0];  \n    await use(page);  \n  },  \n});  \n  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/webview2", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('unmount', async ({ mount }) => {  \n  const component = await mount(<Component/>);  \n  await component.unmount();  \n});", "output": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('unmount', async ({ mount }) => {  \n  const component = await mount(<Component/>);  \n  await component.unmount();  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "GitHub API requires authorization, so we'll configure the token once for all tests. While at it, we'll also set the `baseURL` to simplify the tests. You can either put them in the configuration file, or in the test file with `test.use()`. | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    // All requests we send go to this API endpoint.  \n    baseURL: 'https://api.github.com',  \n    extraHTTPHeaders: {  \n      // We set this header per GitHub guidelines.  \n      'Accept': 'application/vnd.github.v3+json',  \n      // Add authorization token to all requests.  \n      // Assuming personal access token available in the environment.  \n      'Authorization': `token ${process.env.API_TOKEN}`,  \n    },  \n  }  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/api-testing"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "Alternatively, if you cannot find a suitable locator for the parent element, use `xpath=..`. Note that this method is not as reliable, because any changes to the DOM structure will break your tests. Prefer [locator.filter()](/docs/api/class-locator#locator-filter) when possible.", "output": "const parent = page.getByText('Hello').locator('xpath=..');", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/other-locators"}}
{"instruction": "Generate a Playwright test for the following scenario: Tick through time manually, firing all the timers consistently\u200b | In rare cases, you may want to tick through time manually, firing all timers and animation frames in the process to achieve a fine-grained control over the passage of time.", "input": "", "output": "<div id=\"current-time\" data-testid=\"current-time\"></div>  \n<script>  \n  const renderTime = () => {  \n    document.getElementById('current-time').textContent =  \n        new Date().toLocaleString();  \n  };  \n  setInterval(renderTime, 1000);  \n</script>  \n\n\n\n// Initialize clock with a specific time, let the page load naturally.  \nawait page.clock.install({ time: new Date('2024-02-02T08:00:00') });  \nawait page.goto('http://localhost:3333');  \n  \n// Pause the time flow, stop the timers, you now have manual control  \n// over the page time.  \nawait page.clock.pauseAt(new Date('2024-02-02T10:00:00'));  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:00 AM');  \n  \n// Tick through time manually, firing all timers in the process.  \n// In this case, time will be updated in the screen 2 times.  \nawait page.clock.runFor(2000);  \nawait expect(page.getByTestId('current-time')).toHaveText('2/2/2024, 10:00:02 AM');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/clock"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/test';  \nimport featureBTests from './feature-b.spec.ts';  \nimport featureATests from './feature-a.spec.ts';  \n  \ntest.describe(featureBTests);  \ntest.describe(featureATests);", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Interactions\u200b | Performing actions starts with locating the elements. Playwright uses [Locators API](/docs/locators) for that. Locators represent a way to find element(s) on the page at any moment, learn more about the [different types](/docs/locators) of locators available. Playwright will wait for the element to be [actionable](/docs/actionability) prior to performing the action, so there is no need to wait for it to become available.", "input": "", "output": "// Create a locator.  \nconst getStarted = page.getByRole('link', { name: 'Get started' });  \n  \n// Click it.  \nawait getStarted.click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/writing-tests"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "const REPO = 'test-repo-1';  \nconst USER = 'github-username';  \n  \ntest('should create a bug report', async ({ request }) => {  \n  const newIssue = await request.post(`/repos/${USER}/${REPO}/issues`, {  \n    data: {  \n      title: '[Bug] report 1',  \n      body: 'Bug description',  \n    }  \n  });  \n  expect(newIssue.ok()).toBeTruthy();  \n  \n  const issues = await request.get(`/repos/${USER}/${REPO}/issues`);  \n  expect(issues.ok()).toBeTruthy();  \n  expect(await issues.json()).toContainEqual(expect.objectContaining({  \n    title: '[Bug] report 1',  \n    body: 'Bug description'  \n  }));  \n});  \n  \ntest('should create a feature request', async ({ request }) => {  \n  const newIssue = await request.post(`/repos/${USER}/${REPO}/issues`, {  \n    data: {  \n      title: '[Feature] request 1',  \n      body: 'Feature description',  \n    }  \n  });  \n  expect(newIssue.ok()).toBeTruthy();  \n  \n  const issues = await request.get(`/repos/${USER}/${REPO}/issues`);  \n  expect(issues.ok()).toBeTruthy();  \n  expect(await issues.json()).toContainEqual(expect.objectContaining({  \n    title: '[Feature] request 1',  \n    body: 'Feature description'  \n  }));  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/api-testing", "type": "completion"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "Error: should be logged in  \n  \n    Call log:  \n      - assert.toBeVisible with timeout 5000ms  \n      - waiting for \"getByText('Name')\"  \n  \n  \n      2 |  \n      3 | test('example test', async({ page }) => {  \n    > 4 |   await assert(page.locator('text=Name'), 'should be logged in').toBeVisible();  \n        |                                                                  ^  \n      5 | });  \n      6 |", "output": "Error: should be logged in  \n  \n    Call log:  \n      - expect.toBeVisible with timeout 5000ms  \n      - waiting for \"getByText('Name')\"  \n  \n  \n      2 |  \n      3 | test('example test', async({ page }) => {  \n    > 4 |   await expect(page.locator('text=Name'), 'should be logged in').toBeVisible();  \n        |                                                                  ^  \n      5 | });  \n      6 |", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "// \ud83d\udc4e  \nassert(await page.getByText('welcome').isVisible()).toBe(true);", "output": "// \ud83d\udc4e  \nexpect(await page.getByText('welcome').isVisible()).toBe(true);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/best-practices", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Evaluation Argument\u200b | Playwright evaluation methods like [page.evaluate()](/docs/api/class-page#page-evaluate) take a single optional argument. This argument can be a mix of [Serializable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description \"Serializable\") values and [JSHandle](/docs/api/class-jshandle \"JSHandle\") instances. Handles are automatically converted to the value they represent.", "input": "", "output": "// A primitive value.  \nawait page.evaluate(num => num, 42);  \n  \n// An array.  \nawait page.evaluate(array => array.length, [1, 2, 3]);  \n  \n// An object.  \nawait page.evaluate(object => object.foo, { foo: 'bar' });  \n  \n// A single handle.  \nconst button = await page.evaluateHandle('window.button');  \nawait page.evaluate(button => button.textContent, button);  \n  \n// Alternative notation using JSHandle.evaluate.  \nawait button.evaluate((button, from) => button.textContent.substring(from), 5);  \n  \n// Object with multiple handles.  \nconst button1 = await page.evaluateHandle('window.button1');  \nconst button2 = await page.evaluateHandle('window.button2');  \nawait page.evaluate(  \n    o => o.button1.textContent + o.button2.textContent,  \n    { button1, button2 });  \n  \n// Object destructuring works. Note that property names must match  \n// between the destructured object and the argument.  \n// Also note the required parenthesis.  \nawait page.evaluate(  \n    ({ button1, button2 }) => button1.textContent + button2.textContent,  \n    { button1, button2 });  \n  \n// Array works as well. Arbitrary names can be used for destructuring.  \n// Note the required parenthesis.  \nawait page.evaluate(  \n    ([b1, b2]) => b1.textContent + b2.textContent,  \n    [button1, button2]);  \n  \n// Any mix of serializables and handles works.  \nawait page.evaluate(  \n    x => x.button1.textContent + x.list[0].textContent + String(x.foo),  \n    { button1, list: [button2], foo: null });", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/evaluating"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import type { FullConfig } from '@playwright/test';  \n  \nasync function globalSetup(config: FullConfig) {  \n  process.env.FOO = 'some data';  \n  // Or a more complicated data structure as JSON:  \n  process.env.BAR = JSON.stringify({ some: 'data' });  \n}  \n  \nexport default globalSetup;", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await assert(page.getByText('Name'), 'should be logged in').toBeVisible();", "output": "await expect(page.getByText('Name'), 'should be logged in').toBeVisible();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "src/pages/ProductsPage.spec.ts", "output": "import { test, expect } from '@playwright/experimental-ct-vue';  \nimport type { HooksConfig } from '../playwright';  \nimport ProductsPage from './pages/ProductsPage.vue';  \n  \ntest('configure routing through hooks config', async ({ page, mount }) => {  \n  const component = await mount<HooksConfig>(ProductsPage, {  \n    hooksConfig: { enableRouting: true },  \n  });  \n  await expect(component.getByRole('link')).toHaveAttribute('href', '/products/42');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test for the following scenario: `npx playwright test` no longer works if you install both `playwright` and `@playwright/test`. There's no need to install both, since you can always import browser automation APIs from `@playwright/test` directly: | automation.ts", "input": "", "output": "import { chromium, firefox, webkit } from '@playwright/test';  \n/* ... */", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const newEmail = page.getByRole('button', { name: 'New' });  \nconst dialog = page.getByText('Confirm security settings');  \nawait expect(newEmail.or(dialog).first()).toBeVisible();  \nif (await dialog.isVisible())  \n  await page.getByRole('button', { name: 'Dismiss' }).click();  \nawait newEmail.click();", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/locators", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the page_object pattern.", "input": "playwright-dev-page.ts", "output": "import { expect, type Locator, type Page } from '@playwright/test';  \n  \nexport class PlaywrightDevPage {  \n  readonly page: Page;  \n  readonly getStartedLink: Locator;  \n  readonly gettingStartedHeader: Locator;  \n  readonly pomLink: Locator;  \n  readonly tocList: Locator;  \n  \n  constructor(page: Page) {  \n    this.page = page;  \n    this.getStartedLink = page.locator('a', { hasText: 'Get started' });  \n    this.gettingStartedHeader = page.locator('h1', { hasText: 'Installation' });  \n    this.pomLink = page.locator('li', {  \n      hasText: 'Guides',  \n    }).locator('a', {  \n      hasText: 'Page Object Model',  \n    });  \n    this.tocList = page.locator('article div.markdown ul > li > a');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://playwright.dev');  \n  }  \n  \n  async getStarted() {  \n    await this.getStartedLink.first().click();  \n    await expect(this.gettingStartedHeader).toBeVisible();  \n  }  \n  \n  async pageObjectModel() {  \n    await this.getStarted();  \n    await this.pomLink.click();  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/pom"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as base } from '@playwright/test';  \n  \nexport const test = base.extend<{ forEachTest: void }>({  \n  forEachTest: [async ({ page }, use) => {  \n    // This code runs before every test.  \n    await page.goto('http://localhost:8000');  \n    await use();  \n    // This code runs after every test.  \n    console.log('Last URL:', page.url());  \n  }, { auto: true }],  // automatically starts for every test.  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Generate a Playwright test for the following scenario: Frequently asked questions\u200b | What's the difference between `@playwright/test` and `@playwright/experimental-ct-{react,svelte,vue}`?\u200b", "input": "", "output": "test('\u2026', async ({ mount, page, context }) => {  \n  // \u2026  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.locator('_react=SubmitButton[enabled=true]').click();  \nawait page.locator('_vue=submit-button[enabled=true]').click();", "output": "await page.locator('_react=SubmitButton[enabled=true]').click();  \nawait page.locator('_vue=submit-button[enabled=true]').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as base } from '@playwright/test';  \n  \nexport type TestOptions = {  \n  person: string;  \n};  \n  \nexport const test = base.extend<TestOptions>({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  person: ['John', { option: true }],  \n  \n  // Override default \"page\" fixture.  \n  page: async ({ page, person }, use) => {  \n    await page.navigate('/chat');  \n    // We use \"person\" parameter as a \"name\" for the chat room.  \n    await page.getByLabel('User Name').fill(person);  \n    await page.getByText('Enter chat room').click();  \n    // Each test will get a \"page\" that already has the person name.  \n    await use(page);  \n  },  \n});", "output": "import { test as base } from '@playwright/test';  \n  \nexport type TestOptions = {  \n  person: string;  \n};  \n  \nexport const test = base.extend<TestOptions>({  \n  // Define an option and provide a default value.  \n  // We can later override it in the config.  \n  person: ['John', { option: true }],  \n  \n  // Override default \"page\" fixture.  \n  page: async ({ page, person }, use) => {  \n    await page.goto('/chat');  \n    // We use \"person\" parameter as a \"name\" for the chat room.  \n    await page.getByLabel('User Name').fill(person);  \n    await page.getByText('Enter chat room').click();  \n    // Each test will get a \"page\" that already has the person name.  \n    await use(page);  \n  },  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-parameterize", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Basic navigation\u200b | Simplest form of a navigation is opening a URL:", "output": "// Navigate the page  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/navigations"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "Fixture timeout\u200b | By default, fixture shares timeout with the test. However, for slow fixtures, especially worker-scoped ones, it is convenient to have a separate timeout. This way you can keep the overall test timeout small, and give the slow fixture more time.", "output": "import { test as base, expect } from '@playwright/test';  \n  \nconst test = base.extend<{ slowFixture: string }>({  \n  slowFixture: [async ({}, use) => {  \n    // ... perform a slow operation ...  \n    await use('hello');  \n  }, { timeout: 60000 }]  \n});  \n  \ntest('example test', async ({ slowFixture }) => {  \n  // ...  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "fixture"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// CORRECT: THIS SNIPPET WORKS SINCE v1.18.  \n  \n// fixtures.js  \nconst test = base.extend({  \n  // Fixtures marked as \"option: true\" will get a value specified in the config,  \n  // or fallback to the default value.  \n  myParameter: ['default', { option: true }],  \n});  \n  \n// playwright.config.js  \nmodule.exports = {  \n  use: {  \n    myParameter: 'value',  \n  },  \n};", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  expect(await page.textContent('.hero__title')).toMatchSnapshot('hero.txt');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots", "type": "website_test"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "And then import the fixtures in all your tests: | mytest.spec.ts", "output": "import { test } from './fixtures';  \nimport { expect } from '@playwright/test';  \n  \ntest('basic', async ({ page }) => {  \n  expect(page).toHaveURL('http://localhost:8000');  \n  await page.goto('https://playwright.dev');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "fixture"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "You can also annotate all tests in a group or provide multiple annotations:", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.describe('report tests', {  \n  annotation: { type: 'category', description: 'report' },  \n}, () => {  \n  test('test report header', async ({ page }) => {  \n    // ...  \n  });  \n  \n  test('test full report', {  \n    annotation: [  \n      { type: 'issue', description: 'https://github.com/microsoft/playwright/issues/23180' },  \n      { type: 'performance', description: 'very slow test!' },  \n    ],  \n  }, async ({ page }) => {  \n    // ...  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import type {  \n  FullConfig, FullResult, Reporter, Suite, TestCase, TestResult  \n} from '@playwright/test/reporter';  \n  \nclass MyReporter implements Reporter {  \n  onBegin(config: FullConfig, suite: Suite) {  \n    console.log(`Starting the run with ${suite.allTests().length} tests`);  \n  }  \n  \n  onTestBegin(test: TestCase, result: TestResult) {  \n    console.log(`Starting test ${test.title}`);  \n  }  \n  \n  onTestEnd(test: TestCase, result: TestResult) {  \n    console.log(`Finished test ${test.title}: ${result.status}`);  \n  }  \n  \n  onEnd(result: FullResult) {  \n    console.log(`Finished the run: ${result.status}`);  \n  }  \n}  \n  \nexport default MyReporter;", "output": "import type {  \n  FullConfig, FullResult, Reporter, Suite, TestCase, TestResult  \n} from '@playwright/test/reporter';  \n  \nclass MyReporter implements Reporter {  \n  onBegin(config: FullConfig, suite: Suite) {  \n    console.log(`Starting the run with ${suite.allTests().length} tests`);  \n  }  \n  \n  onTestBegin(test: TestCase, result: TestResult) {  \n    console.log(`Starting test ${test.title}`);  \n  }  \n  \n  onTestEnd(test: TestCase, result: TestResult) {  \n    console.log(`Finished test ${test.title}: ${result.status}`);  \n  }  \n  \n  onEnd(result: FullResult) {  \n    console.log(`Finished the run: ${result.status}`);  \n  }  \n}  \n  \nexport default MyReporter;", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-reporters", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "const slowExpect = expect.configure({ timeout: 10000 });  \nawait slowExpect(locator).toHaveText('Submit');  \n  \n// Always do soft assertions.  \nconst softExpect = expect.configure({ soft: true });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the page_object pattern.", "input": "Click to expand the code for the `TodoPage` | todo-page.ts", "output": "import type { Page, Locator } from '@playwright/test';  \n  \nexport class TodoPage {  \n  private readonly inputBox: Locator;  \n  private readonly todoItems: Locator;  \n  \n  constructor(public readonly page: Page) {  \n    this.inputBox = this.page.locator('input.new-todo');  \n    this.todoItems = this.page.getByTestId('todo-item');  \n  }  \n  \n  async goto() {  \n    await this.page.goto('https://demo.playwright.dev/todomvc/');  \n  }  \n  \n  async addToDo(text: string) {  \n    await this.inputBox.fill(text);  \n    await this.inputBox.press('Enter');  \n  }  \n  \n  async remove(text: string) {  \n    const todo = this.todoItems.filter({ hasText: text });  \n    await todo.hover();  \n    await todo.getByLabel('Delete').click();  \n  }  \n  \n  async removeAll() {  \n    while ((await this.todoItems.count()) > 0) {  \n      await this.todoItems.first().hover();  \n      await this.todoItems.getByLabel('Delete').first().click();  \n    }  \n  }  \n}", "metadata": {"pattern": "page_object", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Generate a Playwright test for the following scenario: New method [locator.all()](/docs/api/class-locator#locator-all) to iterate over all matching elements:", "input": "", "output": "// Check all checkboxes!  \nconst checkboxes = page.getByRole('checkbox');  \nfor (const checkbox of await checkboxes.all())  \n  await checkbox.check();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "// Scrolls automatically so that button is visible  \nawait page.getByRole('button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/input", "type": "website_test"}}
{"instruction": "Create a test fixture for setting up test data:", "input": "example.spec.ts", "output": "import { test, type Page } from '@playwright/test';  \n  \ntest.describe.configure({ mode: 'serial' });  \n  \nlet page: Page;  \n  \ntest.beforeAll(async ({ browser }) => {  \n  page = await browser.newPage();  \n});  \n  \ntest.afterAll(async () => {  \n  await page.close();  \n});  \n  \ntest('runs first', async () => {  \n  await page.goto('https://playwright.dev/');  \n});  \n  \ntest('runs second', async () => {  \n  await page.getByText('Get Started').click();  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-retries", "type": "fixture"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.locator('css=button').click();", "output": "await page.locator('css=button').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/other-locators", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test } from '@playwright/test';  \n  \ntest.describe.configure({ mode: 'serial' });  \n  \ntest.beforeAll(async () => { /* ... */ });  \ntest('first good', async ({ page }) => { /* ... */ });  \ntest('second flaky', async ({ page }) => { /* ... */ });  \ntest('third good', async ({ page }) => { /* ... */ });", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-retries", "type": "website_test"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Handling new pages\u200b | The `page` event on browser contexts can be used to get new pages that are created in the context. This can be used to handle new pages opened by `target=\"_blank\"` links.", "output": "// Start waiting for new page before clicking. Note no await.  \nconst pagePromise = context.waitForEvent('page');  \nawait page.getByText('open new tab').click();  \nconst newPage = await pagePromise;  \n// Interact with the new page normally.  \nawait newPage.getByRole('button').click();  \nconsole.log(await newPage.title());", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/pages", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest.beforeEach(async ({ context }) => {  \n  // Block any css requests for each test in this file.  \n  await context.route(/.css$/, route => route.abort());  \n});  \n  \ntest('loads page without css', async ({ page }) => {  \n  await page.navigate('https://playwright.dev');  \n  // ... test goes here  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest.beforeEach(async ({ context }) => {  \n  // Block any css requests for each test in this file.  \n  await context.route(/.css$/, route => route.abort());  \n});  \n  \ntest('loads page without css', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  // ... test goes here  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/network", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Use web first assertions\u200b | Assertions are a way to verify that the expected result and the actual result matched or not. By using [web first assertions](/docs/test-assertions) Playwright will wait until the expected condition is met. For example, when testing an alert message, a test would click a button that makes a message appear and check that the alert message is there. If the alert message takes half a second to appear, assertions such as `toBeVisible()` will wait and retry if needed.", "output": "// \ud83d\udc4d  \nawait expect(page.getByText('welcome')).toBeVisible();  \n  \n// \ud83d\udc4e  \nexpect(await page.getByText('welcome').isVisible()).toBe(true);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/best-practices"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test as baseTest, assert } from '@playwright/test';  \n// Import project utils for managing users in the test database.  \nimport { createUserInTestDatabase, deleteUserFromTestDatabase } from './my-db-utils';  \n  \nexport * from '@playwright/test';  \nexport const test = baseTest.extend<{}, { dbUserName: string }>({  \n  // Returns db user name unique for the worker.  \n  dbUserName: [async ({ }, use) => {  \n    // Use workerIndex as a unique identifier for each worker.  \n    const userName = `user-${test.info().workerIndex}`;  \n    // Initialize user in the database.  \n    await createUserInTestDatabase(userName);  \n    await use(userName);  \n    // Clean up after the tests are done.  \n    await deleteUserFromTestDatabase(userName);  \n  }, { scope: 'worker' }],  \n});", "output": "import { test as baseTest, expect } from '@playwright/test';  \n// Import project utils for managing users in the test database.  \nimport { createUserInTestDatabase, deleteUserFromTestDatabase } from './my-db-utils';  \n  \nexport * from '@playwright/test';  \nexport const test = baseTest.extend<{}, { dbUserName: string }>({  \n  // Returns db user name unique for the worker.  \n  dbUserName: [async ({ }, use) => {  \n    // Use workerIndex as a unique identifier for each worker.  \n    const userName = `user-${test.info().workerIndex}`;  \n    // Initialize user in the database.  \n    await createUserInTestDatabase(userName);  \n    await use(userName);  \n    // Clean up after the tests are done.  \n    await deleteUserFromTestDatabase(userName);  \n  }, { scope: 'worker' }],  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-parallel", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "New options `stderr` and `stdout` in [testConfig.webServer](/docs/api/class-testconfig#test-config-web-server) to configure output handling: | playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Run your local dev server before starting the tests  \n  webServer: {  \n    command: 'npm run start',  \n    url: 'http://127.0.0.1:3000',  \n    reuseExistingServer: !process.env.CI,  \n    stdout: 'pipe',  \n    stderr: 'pipe',  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the general pattern.", "input": "By default, tests in a single file are run in order. If you have many independent tests in a single file, you might want to run them in parallel with [test.describe.configure()](/docs/api/class-test#test-describe-configure). | Note that parallel tests are executed in separate worker processes and cannot share any state or global variables. Each test executes all relevant hooks just for itself, including `beforeAll` and `afterAll`.", "output": "import { test } from '@playwright/test';  \n  \ntest.describe.configure({ mode: 'parallel' });  \n  \ntest('runs in parallel 1', async ({ page }) => { /* ... */ });  \ntest('runs in parallel 2', async ({ page }) => { /* ... */ });", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Read more in [our documentation](/docs/test-components). | Role selectors that allow selecting elements by their [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) and [accessible name](https://w3c.github.io/accname/#dfn-accessible-name).", "output": "// Click a button with accessible name \"log in\"  \nawait page.locator('role=button[name=\"log in\"]').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { handlers } from '@src/mocks/handlers';  \n  \ntest.beforeEach(async ({ router }) => {  \n  // install common handlers before each test  \n  await router.use(...handlers);  \n});  \n  \ntest('example test', async ({ mount }) => {  \n  // test as usual, your handlers are active  \n  // ...  \n});", "output": "import { handlers } from '@src/mocks/handlers';  \n  \ntest.beforeEach(async ({ router }) => {  \n  // install common handlers before each test  \n  await router.use(...handlers);  \n});  \n  \ntest('example test', async ({ mount }) => {  \n  // test as usual, your handlers are active  \n  // ...  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "Add to cart", "output": "<ul>  \n  <li>  \n    <h3>Product 1</h3>  \n    <button>Add to cart</button>  \n  </li>  \n  <li>  \n    <h3>Product 2</h3>  \n    <button>Add to cart</button>  \n  </li>  \n</ul>  \n\n\n\nawait page  \n    .getByRole('listitem')  \n    .filter({ has: page.getByRole('heading', { name: 'Product 2' }) })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "We will authenticate multiple times in the setup project. | tests/auth.setup.ts", "output": "import { test as setup, expect } from '@playwright/test';  \n  \nconst adminFile = 'playwright/.auth/admin.json';  \n  \nsetup('authenticate as admin', async ({ page }) => {  \n  // Perform authentication steps. Replace these actions with your own.  \n  await page.goto('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('admin');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n  // Wait until the page receives the cookies.  \n  //  \n  // Sometimes login flow sets cookies in the process of several redirects.  \n  // Wait for the final URL to ensure that the cookies are actually set.  \n  await page.waitForURL('https://github.com/');  \n  // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n  await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n  // End of authentication steps.  \n  \n  await page.context().storageState({ path: adminFile });  \n});  \n  \nconst userFile = 'playwright/.auth/user.json';  \n  \nsetup('authenticate as user', async ({ page }) => {  \n  // Perform authentication steps. Replace these actions with your own.  \n  await page.goto('https://github.com/login');  \n  await page.getByLabel('Username or email address').fill('user');  \n  await page.getByLabel('Password').fill('password');  \n  await page.getByRole('button', { name: 'Sign in' }).click();  \n  // Wait until the page receives the cookies.  \n  //  \n  // Sometimes login flow sets cookies in the process of several redirects.  \n  // Wait for the final URL to ensure that the cookies are actually set.  \n  await page.waitForURL('https://github.com/');  \n  // Alternatively, you can wait until the page reaches a state where all cookies are set.  \n  await expect(page.getByRole('button', { name: 'View profile and more' })).toBeVisible();  \n  \n  // End of authentication steps.  \n  \n  await page.context().storageState({ path: userFile });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/auth"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "In this example we add a custom `toHaveAmount` function. Custom matcher should return a `pass` flag indicating whether the assertion passed, and a `message` callback that's used when the assertion fails. | fixtures.ts", "output": "import { expect as baseExpect } from '@playwright/test';  \nimport type { Page, Locator } from '@playwright/test';  \n  \nexport { test } from '@playwright/test';  \n  \nexport const expect = baseExpect.extend({  \n  async toHaveAmount(locator: Locator, expected: number, options?: { timeout?: number }) {  \n    const assertionName = 'toHaveAmount';  \n    let pass: boolean;  \n    let matcherResult: any;  \n    try {  \n      await baseExpect(locator).toHaveAttribute('data-amount', String(expected), options);  \n      pass = true;  \n    } catch (e: any) {  \n      matcherResult = e.matcherResult;  \n      pass = false;  \n    }  \n  \n    const message = pass  \n      ? () => this.utils.matcherHint(assertionName, undefined, undefined, { isNot: this.isNot }) +  \n          '\\n\\n' +  \n          `Locator: ${locator}\\n` +  \n          `Expected: not ${this.utils.printExpected(expected)}\\n` +  \n          (matcherResult ? `Received: ${this.utils.printReceived(matcherResult.actual)}` : '')  \n      : () =>  this.utils.matcherHint(assertionName, undefined, undefined, { isNot: this.isNot }) +  \n          '\\n\\n' +  \n          `Locator: ${locator}\\n` +  \n          `Expected: ${this.utils.printExpected(expected)}\\n` +  \n          (matcherResult ? `Received: ${this.utils.printReceived(matcherResult.actual)}` : '');  \n  \n    return {  \n      message,  \n      pass,  \n      name: assertionName,  \n      expected,  \n      actual: matcherResult?.actual,  \n    };  \n  },  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \nimport AxeBuilder from '@axe-core/playwright'; // 1  \n  \ntest.describe('homepage', () => { // 2  \n  test('should not have any automatically detectable accessibility issues', async ({ page }) => {  \n    await page.goto('https://your-site.com/'); // 3  \n  \n    const accessibilityScanResults = await new AxeBuilder({ page }).analyze(); // 4  \n  \n    expect(accessibilityScanResults.violations).toEqual([]); // 5  \n  });  \n});  \n\n\n\nconst { test, expect } = require('@playwright/test');  \nconst AxeBuilder = require('@axe-core/playwright').default; // 1  \n  \ntest.describe('homepage', () => { // 2  \n  test('should not have any automatically detectable accessibility issues', async ({ page }) => {  \n    await page.goto('https://your-site.com/'); // 3  \n  \n    const accessibilityScanResults = await new AxeBuilder({ page }).analyze(); // 4  \n  \n    expect(accessibilityScanResults.violations).toEqual([]); // 5  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing", "type": "completion"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test as base } from '@playwright/test';  \n  \ntype Account = {  \n  username: string;  \n  password: string;  \n};  \n  \n// Note that we pass worker fixture types as a second template parameter.  \nexport const test = base.extend<{}, { account: Account }>({  \n  account: [async ({ browser }, use, workerInfo) => {  \n    // Unique username.  \n    const username = 'user' + workerInfo.workerIndex;  \n    const password = 'verysecure';  \n  \n    // Create the account with Playwright.  \n    const page = await browser.newPage();  \n    await page.goto('/signup');  \n    await page.getByLabel('User Name').fill(username);  \n    await page.getByLabel('Password').fill(password);  \n    await page.getByText('Sign up').click();  \n    // Make sure everything is ok.  \n    await expect(page.getByTestId('result')).toHaveText('Success');  \n    // Do not forget to cleanup.  \n    await page.close();  \n  \n    // Use the account value.  \n    await use({ username, password });  \n  }, { scope: 'worker' }],  \n  \n  page: async ({ page, account }, use) => {  \n    // Sign in with our account.  \n    const { username, password } = account;  \n    await page.goto('/signin');  \n    await page.getByLabel('User Name').fill(username);  \n    await page.getByLabel('Password').fill(password);  \n    await page.getByText('Sign in').click();  \n    await expect(page.getByTestId('userinfo')).toHaveText(username);  \n  \n    // Use signed-in page in the test.  \n    await use(page);  \n  },  \n});  \nexport { expect } from '@playwright/test';", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "Set timeout for a single action\u200b | example.spec.ts", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('basic test', async ({ page }) => {  \n  await page.goto('https://playwright.dev', { timeout: 30000 });  \n  await page.getByText('Get Started').click({ timeout: 10000 });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/test';  \n  \ntest('menu', async ({ page }) => {  \n  // Your test that depends on the database  \n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('menu', async ({ page }) => {  \n  // Your test that depends on the database  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "modification"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('basic test', async ({ page }) => {  \n  await page.goto('https://playwright.dev', { timeout: 30000 });  \n  await page.getByText('Get Started').click({ timeout: 10000 });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-timeouts", "type": "website_test"}}
{"instruction": "Create a Playwright test that demonstrates the form_interaction pattern.", "input": "New APIs\u200b | New method [route.fetch()](/docs/api/class-route#route-fetch) and new option `json` for [route.fulfill()](/docs/api/class-route#route-fulfill):", "output": "await page.route('**/api/settings', async route => {  \n  // Fetch original settings.  \n  const response = await route.fetch();  \n  \n  // Force settings theme to a predefined value.  \n  const json = await response.json();  \n  json.theme = 'Solorized';  \n  \n  // Fulfill with modified data.  \n  await route.fulfill({ json });  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: 'Product 2' })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "output": "await page  \n    .getByRole('listitem')  \n    .filter({ hasText: 'Product 2' })  \n    .getByRole('button', { name: 'Add to cart' })  \n    .click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const href = await page.evaluate(() => document.location.href);", "output": "const href = await page.evaluate(() => document.location.href);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/evaluating", "type": "modification"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "component.spec.tsx", "output": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(<Component/>);  \n  await component.update(  \n      <Component msg=\"greetings\" onClick={() => {}}>Child</Component>  \n  );  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components", "type": "navigation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n    },  \n  \n    {  \n      name: 'firefox',  \n      use: { ...devices['Desktop Firefox'] },  \n    },  \n  \n    {  \n      name: 'webkit',  \n      use: { ...devices['Desktop Safari'] },  \n    },  \n  \n    /* Test against mobile viewports. */  \n    {  \n      name: 'Mobile Chrome',  \n      use: { ...devices['Pixel 5'] },  \n    },  \n    {  \n      name: 'Mobile Safari',  \n      use: { ...devices['iPhone 12'] },  \n    },  \n  \n    /* Test against branded browsers. */  \n    {  \n      name: 'Microsoft Edge',  \n      use: {  \n        ...devices['Desktop Edge'],  \n        channel: 'msedge'  \n      },  \n    },  \n    {  \n      name: 'Google Chrome',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        channel: 'chrome'  \n      },  \n    },  \n  ],  \n});", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n    },  \n  \n    {  \n      name: 'firefox',  \n      use: { ...devices['Desktop Firefox'] },  \n    },  \n  \n    {  \n      name: 'webkit',  \n      use: { ...devices['Desktop Safari'] },  \n    },  \n  \n    /* Test against mobile viewports. */  \n    {  \n      name: 'Mobile Chrome',  \n      use: { ...devices['Pixel 5'] },  \n    },  \n    {  \n      name: 'Mobile Safari',  \n      use: { ...devices['iPhone 12'] },  \n    },  \n  \n    /* Test against branded browsers. */  \n    {  \n      name: 'Microsoft Edge',  \n      use: {  \n        ...devices['Desktop Edge'],  \n        channel: 'msedge'  \n      },  \n    },  \n    {  \n      name: 'Google Chrome',  \n      use: {  \n        ...devices['Desktop Chrome'],  \n        channel: 'chrome'  \n      },  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-projects", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.locator('#item-to-be-dragged').dragTo(page.locator('#item-to-drop-at'));", "output": "await page.locator('#item-to-be-dragged').dragTo(page.locator('#item-to-drop-at'));", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/input", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: You can click on the image after locating it by the text alternative:", "input": "", "output": "await page.getByAltText('playwright logo').click();", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/locators"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('example test', async ({ page }) => {  \n  await page.goto('https://playwright.dev');  \n  await expect(page).toHaveScreenshot({ maxDiffPixels: 100 });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots", "type": "completion"}}
{"instruction": "Add appropriate assertions to verify the page state:", "input": "test(\"check homepage\", async ({ page }) => {\n  await page.goto(\"https://example.com\");\n  // Add assertions here\n});", "output": "async function login(page) {  \n  await test.step('login', async () => {  \n    // ...  \n  }, { box: true });  // Note the \"box\" option here.  \n}  \n\n\n\nError: Timed out 5000ms waiting for expect(locator).toBeVisible()  \n  ... error details omitted ...  \n  \n  14 |   await page.goto('https://github.com/login');  \n> 15 |   await login(page);  \n     |         ^  \n  16 | });", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/release-notes", "type": "completion"}}
{"instruction": "Generate a Playwright test for the following scenario: Advanced Configuration\u200b | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // Folder for test artifacts such as screenshots, videos, traces, etc.  \n  outputDir: 'test-results',  \n  \n  // path to the global setup files.  \n  globalSetup: require.resolve('./global-setup'),  \n  \n  // path to the global teardown files.  \n  globalTeardown: require.resolve('./global-teardown'),  \n  \n  // Each test is given 30 seconds.  \n  timeout: 30000,  \n  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-configuration"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/experimental-ct-react';  \nimport App from './App';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<App />);  \n  await assert(component).toContainText('Learn React');  \n});", "output": "import { test, expect } from '@playwright/experimental-ct-react';  \nimport App from './App';  \n  \ntest('should work', async ({ mount }) => {  \n  const component = await mount(<App />);  \n  await expect(component).toContainText('Learn React');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: You can also opt in for fully-parallel mode for just a few projects: | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  // runs all tests in all files of a specific project in parallel  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n      fullyParallel: true,  \n    },  \n  ]  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/test-parallel"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  // environment variables which are set in globalSetup are only available inside test().  \n  const { FOO, BAR } = process.env;  \n  \n  // FOO and BAR properties are populated.  \n  assert(FOO).toEqual('some data');  \n  \n  const complexData = JSON.parse(BAR);  \n  assert(BAR).toEqual({ some: 'data' });  \n});", "output": "import { test } from '@playwright/test';  \n  \ntest('test', async ({ page }) => {  \n  // environment variables which are set in globalSetup are only available inside test().  \n  const { FOO, BAR } = process.env;  \n  \n  // FOO and BAR properties are populated.  \n  expect(FOO).toEqual('some data');  \n  \n  const complexData = JSON.parse(BAR);  \n  expect(BAR).toEqual({ some: 'data' });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-global-setup-teardown", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "playwright.config.ts", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  use: {  \n    // Grants specified permissions to the browser context.  \n    permissions: ['notifications'],  \n  },  \n});  \n\n\n\nconst context = await browser.newContext({  \n  permissions: ['notifications'],  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/emulation"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "const data = 'some data';  \n// Pass |data| as a parameter.  \nconst result = await page.evaluate(data => {  \n  window.myApp.use(data);  \n}, data);", "output": "const data = 'some data';  \n// Pass |data| as a parameter.  \nconst result = await page.evaluate(data => {  \n  window.myApp.use(data);  \n}, data);", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/evaluating", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the wait_strategy pattern.", "input": "Multiple methods like [locator.click()](/docs/api/class-locator#locator-click) or [locator.press()](/docs/api/class-locator#locator-press) now support a `ControlOrMeta` modifier key. This key maps to `Meta` on macOS and maps to `Control` on Windows and Linux.", "output": "// Press the common keyboard shortcut Control+S or Meta+S to trigger a \"Save\" operation.  \nawait page.keyboard.press('ControlOrMeta+S');", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/release-notes"}}
{"instruction": "Create a Playwright test that demonstrates the navigation pattern.", "input": "component.spec.tsx", "output": "import { test } from '@playwright/experimental-ct-react';  \n  \ntest('update', async ({ mount }) => {  \n  const component = await mount(<Component/>);  \n  await component.update(  \n      <Component msg=\"greetings\" onClick={() => {}}>Child</Component>  \n  );  \n});", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/test-components"}}
{"instruction": "Generate a Playwright test for the following scenario: By default the [playwright.config](/docs/trace-viewer#recording-a-trace-on-ci) file will contain the configuration needed to create a `trace.zip` file for each test. Traces are setup to run `on-first-retry` meaning they will be run on the first retry of a failed test. Also `retries` are set to 2 when running on CI and 0 locally. This means the traces will be recorded on the first retry of a failed test but not on the first run and not on the second retry. | playwright.config.ts", "input": "", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  retries: process.env.CI ? 2 : 0, // set to 2 when running on CI  \n  // ...  \n  use: {  \n    trace: 'on-first-retry', // record traces on first retry of each test  \n  },  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/trace-viewer-intro"}}
{"instruction": "Generate a Playwright test suite for a website. The test should:", "input": "1. Navigate to the homepage\n2. Verify key elements are present\n3. Test main user interactions\n4. Handle any errors or loading states\n5. Follow Playwright best practices", "output": "import { test, expect } from '@playwright/test';  \n  \ntest('test login page', {  \n  tag: '@fast',  \n}, async ({ page }) => {  \n  // ...  \n});  \n  \ntest('test full report @slow', async ({ page }) => {  \n  // ...  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-annotations", "type": "website_test"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { test, assert } from '@playwright/experimental-ct-vue';  \nimport type { HooksConfig } from '../playwright';  \nimport Store from './Store.vue';  \n  \ntest('override initialState ', async ({ mount }) => {  \n  const component = await mount<HooksConfig>(Store, {  \n    hooksConfig: {  \n      store: { name: 'override initialState' }  \n    }  \n  });  \n  await assert(component).toContainText('override initialState');  \n});", "output": "import { test, expect } from '@playwright/experimental-ct-vue';  \nimport type { HooksConfig } from '../playwright';  \nimport Store from './Store.vue';  \n  \ntest('override initialState ', async ({ mount }) => {  \n  const component = await mount<HooksConfig>(Store, {  \n    hooksConfig: {  \n      store: { name: 'override initialState' }  \n    }  \n  });  \n  await expect(component).toContainText('override initialState');  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-components", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: You can also specify custom polling intervals:", "input": "", "output": "await expect.poll(async () => {  \n  const response = await page.request.get('https://api.example.com');  \n  return response.status();  \n}, {  \n  // Probe, wait 1s, probe, wait 2s, probe, wait 10s, probe, wait 10s, probe  \n  // ... Defaults to [100, 250, 500, 1000].  \n  intervals: [1_000, 2_000, 10_000],  \n  timeout: 60_000  \n}).toBe(200);", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-assertions"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "test(\"mocks a fruit and doesn't call api\", async ({ page }) => {  \n  // Mock the api call before navigating  \n  await page.route('*/**/api/v1/fruits', async route => {  \n    const json = [{ name: 'Strawberry', id: 21 }];  \n    await route.fulfill({ json });  \n  });  \n  // Go to the page  \n  await page.navigate('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the Strawberry fruit is visible  \n  await assert(page.getByText('Strawberry')).toBeVisible();  \n});", "output": "test(\"mocks a fruit and doesn't call api\", async ({ page }) => {  \n  // Mock the api call before navigating  \n  await page.route('*/**/api/v1/fruits', async route => {  \n    const json = [{ name: 'Strawberry', id: 21 }];  \n    await route.fulfill({ json });  \n  });  \n  // Go to the page  \n  await page.goto('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the Strawberry fruit is visible  \n  await expect(page.getByText('Strawberry')).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['html', { host: 'localhost', port: '9223' }]],  \n});", "output": "import { defineConfig } from '@playwright/test';  \n  \nexport default defineConfig({  \n  reporter: [['html', { host: 'localhost', port: '9223' }]],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/release-notes", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: JavaScript", "input": "", "output": "import { test, expect } from '@playwright/test';  \nimport AxeBuilder from '@axe-core/playwright'; // 1  \n  \ntest.describe('homepage', () => { // 2  \n  test('should not have any automatically detectable accessibility issues', async ({ page }) => {  \n    await page.goto('https://your-site.com/'); // 3  \n  \n    const accessibilityScanResults = await new AxeBuilder({ page }).analyze(); // 4  \n  \n    expect(accessibilityScanResults.violations).toEqual([]); // 5  \n  });  \n});  \n\n\n\nconst { test, expect } = require('@playwright/test');  \nconst AxeBuilder = require('@axe-core/playwright').default; // 1  \n  \ntest.describe('homepage', () => { // 2  \n  test('should not have any automatically detectable accessibility issues', async ({ page }) => {  \n    await page.goto('https://your-site.com/'); // 3  \n  \n    const accessibilityScanResults = await new AxeBuilder({ page }).analyze(); // 4  \n  \n    expect(accessibilityScanResults.violations).toEqual([]); // 5  \n  });  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/accessibility-testing"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    proxy: {  \n      server: 'http://myproxy.com:3128',  \n      username: 'usr',  \n      password: 'pwd'  \n    }  \n  }  \n});  \n\n\n\nconst browser = await chromium.launch({  \n  proxy: {  \n    server: 'http://myproxy.com:3128',  \n    username: 'usr',  \n    password: 'pwd'  \n  }  \n});", "output": "import { defineConfig } from '@playwright/test';  \nexport default defineConfig({  \n  use: {  \n    proxy: {  \n      server: 'http://myproxy.com:3128',  \n      username: 'usr',  \n      password: 'pwd'  \n    }  \n  }  \n});  \n\n\n\nconst browser = await chromium.launch({  \n  proxy: {  \n    server: 'http://myproxy.com:3128',  \n    username: 'usr',  \n    password: 'pwd'  \n  }  \n});", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/network", "type": "modification"}}
{"instruction": "Create a Playwright test that demonstrates the assertion pattern.", "input": "The snapshot name `example-test-1-chromium-darwin.png` consists of a few parts: | `example-test-1.png` \\- an auto-generated name of the snapshot. Alternatively you can specify snapshot name as the first argument of the `toHaveScreenshot()` method:", "output": "await expect(page).toHaveScreenshot('landing.png');", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/test-snapshots"}}
{"instruction": "Create a test that navigates through multiple pages:", "input": "Network events\u200b | You can monitor all the [Request](/docs/api/class-request \"Request\")s and [Response](/docs/api/class-response \"Response\")s:", "output": "// Subscribe to 'request' and 'response' events.  \npage.on('request', request => console.log('>>', request.method(), request.url()));  \npage.on('response', response => console.log('<<', response.status(), response.url()));  \n  \nawait page.goto('https://example.com');", "metadata": {"pattern": "navigation", "source": "https://playwright.dev/docs/network", "type": "navigation"}}
{"instruction": "Create a Playwright test that demonstrates the fixture pattern.", "input": "And then import the fixtures in all your tests: | mytest.spec.ts", "output": "import { test } from './fixtures';  \nimport { expect } from '@playwright/test';  \n  \ntest('basic', async ({ }) => {  \n  // ...  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig } from '@playwright/test';  \nimport type { MyOptions } from './my-test';  \n  \nexport default defineConfig<MyOptions>({  \n  projects: [  \n    {  \n      name: 'shopping',  \n      use: { defaultItem: 'Buy milk' },  \n    },  \n    {  \n      name: 'wellbeing',  \n      use: { defaultItem: 'Exercise!' },  \n    },  \n  ]  \n});", "output": "import { defineConfig } from '@playwright/test';  \nimport type { MyOptions } from './my-test';  \n  \nexport default defineConfig<MyOptions>({  \n  projects: [  \n    {  \n      name: 'shopping',  \n      use: { defaultItem: 'Buy milk' },  \n    },  \n    {  \n      name: 'wellbeing',  \n      use: { defaultItem: 'Exercise!' },  \n    },  \n  ]  \n});", "metadata": {"pattern": "form_interaction", "source": "https://playwright.dev/docs/test-fixtures", "type": "modification"}}
{"instruction": "Generate a Playwright test for the following scenario: Sometimes, it is essential to make an API request, but the response needs to be patched to allow for reproducible testing. In that case, instead of mocking the request, one can perform the request and fulfill it with the modified response. | In the example below we intercept the call to the fruit API and add a new fruit called 'Loquat', to the data. We then go to the url and assert that this data is there:", "input": "", "output": "test('gets the json from api and adds a new fruit', async ({ page }) => {  \n  // Get the response and add to it  \n  await page.route('*/**/api/v1/fruits', async route => {  \n    const response = await route.fetch();  \n    const json = await response.json();  \n    json.push({ name: 'Loquat', id: 100 });  \n    // Fulfill using the original response, while patching the response body  \n    // with the given JSON object.  \n    await route.fulfill({ response, json });  \n  });  \n  \n  // Go to the page  \n  await page.goto('https://demo.playwright.dev/api-mocking');  \n  \n  // Assert that the new fruit is visible  \n  await expect(page.getByText('Loquat', { exact: true })).toBeVisible();  \n});", "metadata": {"pattern": "assertion", "source": "https://playwright.dev/docs/mock"}}
{"instruction": "Generate a Playwright test for the following scenario: And then import the fixtures in all your tests: | mytest.spec.ts", "input": "", "output": "import { test } from './fixtures';  \nimport { expect } from '@playwright/test';  \n  \ntest('basic', async ({ page }) => {  \n  expect(page).toHaveURL('http://localhost:8000');  \n  await page.goto('https://playwright.dev');  \n});", "metadata": {"pattern": "fixture", "source": "https://playwright.dev/docs/test-fixtures"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "await page.pause();", "output": "await page.pause();", "metadata": {"pattern": "wait_strategy", "source": "https://playwright.dev/docs/debug", "type": "modification"}}
{"instruction": "Modify this test to follow Playwright best practices:", "input": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n    },  \n    {  \n      name: 'firefox',  \n      use: { ...devices['Desktop Firefox'] },  \n    },  \n    {  \n      name: 'webkit',  \n      use: { ...devices['Desktop Safari'] },  \n    },  \n  ],  \n});", "output": "import { defineConfig, devices } from '@playwright/test';  \n  \nexport default defineConfig({  \n  projects: [  \n    {  \n      name: 'chromium',  \n      use: { ...devices['Desktop Chrome'] },  \n    },  \n    {  \n      name: 'firefox',  \n      use: { ...devices['Desktop Firefox'] },  \n    },  \n    {  \n      name: 'webkit',  \n      use: { ...devices['Desktop Safari'] },  \n    },  \n  ],  \n});", "metadata": {"pattern": "general", "source": "https://playwright.dev/docs/best-practices", "type": "modification"}}
